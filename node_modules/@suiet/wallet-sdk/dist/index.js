var xe = Object.defineProperty;
var Se = (r, i, c) => i in r ? xe(r, i, { enumerable: !0, configurable: !0, writable: !0, value: c }) : r[i] = c;
var m = (r, i, c) => (Se(r, typeof i != "symbol" ? i + "" : i, c), c);
import { SuiClient as Pt } from "@mysten/sui.js/client";
import { SUI_TYPE_ARG as Ce } from "@mysten/sui.js/utils";
import { verifyPersonalMessage as me } from "@mysten/sui.js/verify";
class ze extends TypeError {
  constructor(i, c) {
    let u;
    const { message: I, explanation: g, ...A } = i, { path: a } = i, h = a.length === 0 ? I : `At path: ${a.join(".")} -- ${I}`;
    super(g ?? h), g != null && (this.cause = h), Object.assign(this, A), this.name = this.constructor.name, this.failures = () => u ?? (u = [i, ...c()]);
  }
}
function Oe(r) {
  return Y(r) && typeof r[Symbol.iterator] == "function";
}
function Y(r) {
  return typeof r == "object" && r != null;
}
function F(r) {
  return typeof r == "symbol" ? r.toString() : typeof r == "string" ? JSON.stringify(r) : `${r}`;
}
function be(r) {
  const { done: i, value: c } = r.next();
  return i ? void 0 : c;
}
function Ue(r, i, c, u) {
  if (r === !0)
    return;
  r === !1 ? r = {} : typeof r == "string" && (r = { message: r });
  const { path: I, branch: g } = i, { type: A } = c, { refinement: a, message: h = `Expected a value of type \`${A}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${F(u)}\`` } = r;
  return {
    value: u,
    type: A,
    refinement: a,
    key: I[I.length - 1],
    path: I,
    branch: g,
    ...r,
    message: h
  };
}
function* Zt(r, i, c, u) {
  Oe(r) || (r = [r]);
  for (const I of r) {
    const g = Ue(I, i, c, u);
    g && (yield g);
  }
}
function* Tt(r, i, c = {}) {
  const { path: u = [], branch: I = [r], coerce: g = !1, mask: A = !1 } = c, a = { path: u, branch: I };
  if (g && (r = i.coercer(r, a), A && i.type !== "type" && Y(i.schema) && Y(r) && !Array.isArray(r)))
    for (const j in r)
      i.schema[j] === void 0 && delete r[j];
  let h = "valid";
  for (const j of i.validator(r, a))
    j.explanation = c.message, h = "not_valid", yield [j, void 0];
  for (let [j, p, x] of i.entries(r, a)) {
    const Q = Tt(p, x, {
      path: j === void 0 ? u : [...u, j],
      branch: j === void 0 ? I : [...I, p],
      coerce: g,
      mask: A,
      message: c.message
    });
    for (const S of Q)
      S[0] ? (h = S[0].refinement != null ? "not_refined" : "not_valid", yield [S[0], void 0]) : g && (p = S[1], j === void 0 ? r = p : r instanceof Map ? r.set(j, p) : r instanceof Set ? r.add(p) : Y(r) && (p !== void 0 || j in r) && (r[j] = p));
  }
  if (h !== "not_valid")
    for (const j of i.refiner(r, a))
      j.explanation = c.message, h = "not_refined", yield [j, void 0];
  h === "valid" && (yield [void 0, r]);
}
class P {
  constructor(i) {
    const { type: c, schema: u, validator: I, refiner: g, coercer: A = (h) => h, entries: a = function* () {
    } } = i;
    this.type = c, this.schema = u, this.entries = a, this.coercer = A, I ? this.validator = (h, j) => {
      const p = I(h, j);
      return Zt(p, j, this, h);
    } : this.validator = () => [], g ? this.refiner = (h, j) => {
      const p = g(h, j);
      return Zt(p, j, this, h);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(i, c) {
    return Be(i, this, c);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(i, c) {
    return Re(i, this, c);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(i) {
    return ke(i, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(i, c) {
    return Ye(i, this, c);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(i, c = {}) {
    return ut(i, this, c);
  }
}
function Be(r, i, c) {
  const u = ut(r, i, { message: c });
  if (u[0])
    throw u[0];
}
function Re(r, i, c) {
  const u = ut(r, i, { coerce: !0, message: c });
  if (u[0])
    throw u[0];
  return u[1];
}
function Ye(r, i, c) {
  const u = ut(r, i, { coerce: !0, mask: !0, message: c });
  if (u[0])
    throw u[0];
  return u[1];
}
function ke(r, i) {
  return !ut(r, i)[0];
}
function ut(r, i, c = {}) {
  const u = Tt(r, i, c), I = be(u);
  return I[0] ? [new ze(I[0], function* () {
    for (const A of u)
      A[0] && (yield A[0]);
  }), void 0] : [void 0, I[1]];
}
function st(...r) {
  const i = r[0].type === "type", c = r.map((I) => I.schema), u = Object.assign({}, ...c);
  return i ? Ge(u) : f(u);
}
function v(r, i) {
  return new P({ type: r, schema: null, validator: i });
}
function Fe() {
  return v("any", () => !0);
}
function Lt(r) {
  return new P({
    type: "array",
    schema: r,
    *entries(i) {
      if (r && Array.isArray(i))
        for (const [c, u] of i.entries())
          yield [c, u, r];
    },
    coercer(i) {
      return Array.isArray(i) ? i.slice() : i;
    },
    validator(i) {
      return Array.isArray(i) || `Expected an array value, but received: ${F(i)}`;
    }
  });
}
function Qe() {
  return v("bigint", (r) => typeof r == "bigint");
}
function k() {
  return v("boolean", (r) => typeof r == "boolean");
}
function b(r) {
  const i = F(r), c = typeof r;
  return new P({
    type: "literal",
    schema: c === "string" || c === "number" || c === "boolean" ? r : null,
    validator(u) {
      return u === r || `Expected the literal \`${i}\`, but received: ${F(u)}`;
    }
  });
}
function vt() {
  return v("never", () => !1);
}
function L(r) {
  return new P({
    ...r,
    validator: (i, c) => i === null || r.validator(i, c),
    refiner: (i, c) => i === null || r.refiner(i, c)
  });
}
function ct() {
  return v("number", (r) => typeof r == "number" && !isNaN(r) || `Expected a number, but received: ${F(r)}`);
}
function f(r) {
  const i = r ? Object.keys(r) : [], c = vt();
  return new P({
    type: "object",
    schema: r || null,
    *entries(u) {
      if (r && Y(u)) {
        const I = new Set(Object.keys(u));
        for (const g of i)
          I.delete(g), yield [g, u[g], r[g]];
        for (const g of I)
          yield [g, u[g], c];
      }
    },
    validator(u) {
      return Y(u) || `Expected an object, but received: ${F(u)}`;
    },
    coercer(u) {
      return Y(u) ? { ...u } : u;
    }
  });
}
function E(r) {
  return new P({
    ...r,
    validator: (i, c) => i === void 0 || r.validator(i, c),
    refiner: (i, c) => i === void 0 || r.refiner(i, c)
  });
}
function K(r, i) {
  return new P({
    type: "record",
    schema: null,
    *entries(c) {
      if (Y(c))
        for (const u in c) {
          const I = c[u];
          yield [u, u, r], yield [u, I, i];
        }
    },
    validator(c) {
      return Y(c) || `Expected an object, but received: ${F(c)}`;
    }
  });
}
function N() {
  return v("string", (r) => typeof r == "string" || `Expected a string, but received: ${F(r)}`);
}
function We(r) {
  const i = vt();
  return new P({
    type: "tuple",
    schema: null,
    *entries(c) {
      if (Array.isArray(c)) {
        const u = Math.max(r.length, c.length);
        for (let I = 0; I < u; I++)
          yield [I, c[I], r[I] || i];
      }
    },
    validator(c) {
      return Array.isArray(c) || `Expected an array, but received: ${F(c)}`;
    }
  });
}
function Ge(r) {
  const i = Object.keys(r);
  return new P({
    type: "type",
    schema: r,
    *entries(c) {
      if (Y(c))
        for (const u of i)
          yield [u, c[u], r[u]];
    },
    validator(c) {
      return Y(c) || `Expected an object, but received: ${F(c)}`;
    },
    coercer(c) {
      return Y(c) ? { ...c } : c;
    }
  });
}
function Z(r) {
  const i = r.map((c) => c.type).join(" | ");
  return new P({
    type: "union",
    schema: null,
    coercer(c) {
      for (const u of r) {
        const [I, g] = u.validate(c, { coerce: !0 });
        if (!I)
          return g;
      }
      return c;
    },
    validator(c, u) {
      const I = [];
      for (const g of r) {
        const [...A] = Tt(c, g, u), [a] = A;
        if (a[0])
          for (const [h] of A)
            h && I.push(h);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${i}\`, but received: ${F(c)}`,
        ...I
      ];
    }
  });
}
function Pe() {
  return v("unknown", () => !0);
}
const xt = Z([
  f({
    AddressOwner: N()
  }),
  f({
    ObjectOwner: N()
  }),
  f({
    Shared: f({
      initial_shared_version: L(N())
    })
  }),
  b("Immutable")
]);
v("SuiJsonValue", () => !0);
const Ze = Z([
  f({ u32: N() }),
  f({ u64: N() }),
  f({ f64: N() })
]);
f({
  attributes: K(N(), L(Ze)),
  featureFlags: K(N(), k()),
  maxSupportedProtocolVersion: N(),
  minSupportedProtocolVersion: N(),
  protocolVersion: N()
});
Z([N(), b("package")]);
const gt = f({
  /** Base64 string representing the object digest */
  digest: N(),
  /** Hex code as string representing the object id */
  objectId: N(),
  /** Object version */
  version: Z([ct(), N(), Qe()])
});
f({
  owner: xt,
  reference: gt
});
f({
  objectId: N(),
  sequenceNumber: N()
});
f({
  payment: Lt(gt),
  /** Gas Object's owner */
  owner: N(),
  price: N(),
  budget: N()
});
const Ve = st(
  gt,
  f({
    type: N(),
    owner: xt,
    previousTransaction: N()
  })
), Xe = K(N(), Fe()), Je = K(N(), Pe()), He = f({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: N(),
  /** Fields and values stored inside the Move object */
  fields: Xe,
  hasPublicTransfer: k()
}), ve = f({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: Je
}), qe = Z([
  st(He, f({ dataType: b("moveObject") })),
  st(ve, f({ dataType: b("package") }))
]), Ke = f({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: N(),
  hasPublicTransfer: k(),
  version: N(),
  bcsBytes: N()
}), _e = f({
  id: N(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: K(N(), N())
}), $e = Z([
  st(Ke, f({ dataType: b("moveObject") })),
  st(_e, f({ dataType: b("package") }))
]);
BigInt(1e9);
const qt = f({
  code: N(),
  error: E(N()),
  object_id: E(N()),
  parent_object_id: E(N()),
  version: E(N()),
  digest: E(N())
}), tr = f({
  data: L(E(K(N(), N()))),
  error: L(E(qt))
}), er = Z([
  tr,
  E(K(N(), N()))
]), Kt = f({
  objectId: N(),
  version: N(),
  digest: N(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: L(E(N())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: L(E(qe)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: L(E($e)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: L(E(xt)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: L(E(N())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: L(E(N())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: L(E(er))
});
f({
  /* Whether to fetch the object type, default to be true */
  showType: L(E(k())),
  /* Whether to fetch the object content, default to be false */
  showContent: L(E(k())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: L(E(k())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: L(E(k())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: L(E(k())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: L(E(k())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: L(E(k()))
});
Z([
  b("Exists"),
  b("notExists"),
  b("Deleted")
]);
Lt(Ve);
const rr = f({
  data: L(E(Kt)),
  error: L(E(qt))
});
function _t(r) {
  return r.data;
}
function nr(r) {
  if (r.error && "object_id" in r.error && "version" in r.error && "digest" in r.error) {
    const i = r.error;
    return {
      objectId: i.object_id,
      version: i.version,
      digest: i.digest
    };
  }
}
function ir(r) {
  if (r.error && "object_id" in r.error && !("version" in r.error) && !("digest" in r.error))
    return r.error.object_id;
}
function or(r) {
  if ("reference" in r)
    return r.reference;
  const i = _t(r);
  return i ? {
    objectId: i.objectId,
    version: i.version,
    digest: i.digest
  } : nr(r);
}
function cr(r) {
  return "objectId" in r ? r.objectId : or(r)?.objectId ?? ir(r);
}
function sr(r) {
  return r.data !== void 0;
}
function ur(r) {
  const i = sr(r) ? r.data : r;
  return !i?.type && "data" in r ? i?.content?.dataType === "package" ? "package" : ar(r) : i?.type;
}
function ar(r) {
  return $t(r)?.type;
}
function Mr(r) {
  return "fields" in r ? r.fields : $t(r)?.fields;
}
function lr(r) {
  return r.content !== void 0;
}
function $t(r) {
  const i = "data" in r ? _t(r) : r;
  if (!(!i || !lr(i) || i.content.dataType !== "moveObject"))
    return i.content;
}
f({
  objectId: N(),
  atCheckpoint: E(ct())
});
f({
  data: Lt(rr),
  nextCursor: E(L(N())),
  hasNextPage: k()
});
Z([
  f({
    details: Kt,
    status: b("VersionFound")
  }),
  f({
    details: N(),
    status: b("ObjectNotExists")
  }),
  f({
    details: gt,
    status: b("ObjectDeleted")
  }),
  f({
    details: We([N(), ct()]),
    status: b("VersionNotFound")
  }),
  f({
    details: f({
      asked_version: ct(),
      latest_version: ct(),
      object_id: N()
    }),
    status: b("VersionTooHigh")
  })
]);
const Ir = 32;
function gr(r, i = !1) {
  let c = r.toLowerCase();
  return !i && c.startsWith("0x") && (c = c.slice(2)), `0x${c.padStart(Ir * 2, "0")}`;
}
function Ar(r, i = !1) {
  return gr(r, i);
}
const Vt = /^0x2::coin::Coin<(.+)>$/;
function Nr(r) {
  return !!r.data || !!r.type;
}
class B {
  static isCoin(i) {
    return B.getType(i)?.match(Vt) != null;
  }
  static getCoinType(i) {
    const [, c] = i.match(Vt) ?? [];
    return c || null;
  }
  static getCoinTypeArg(i) {
    const c = B.getType(i);
    return c ? B.getCoinType(c) : null;
  }
  static isSUI(i) {
    const c = B.getCoinTypeArg(i);
    return c ? B.getCoinSymbol(c) === "SUI" : !1;
  }
  static getCoinSymbol(i) {
    return i.substring(i.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(i) {
    return {
      address: Ar(i.split("::")[0]),
      module: i.split("::")[1],
      name: i.split("::")[2],
      typeParams: []
    };
  }
  static getID(i) {
    return "fields" in i ? i.fields.id.id : cr(i);
  }
  static totalBalance(i) {
    return i.reduce(
      (c, u) => c + B.getBalanceFromCoinStruct(u),
      BigInt(0)
    );
  }
  /**
   * Sort coin by balance in an ascending order
   */
  static sortByBalance(i) {
    return [...i].sort(
      (c, u) => B.getBalanceFromCoinStruct(c) < B.getBalanceFromCoinStruct(u) ? -1 : B.getBalanceFromCoinStruct(c) > B.getBalanceFromCoinStruct(u) ? 1 : 0
    );
  }
  static getBalanceFromCoinStruct(i) {
    return BigInt(i.balance);
  }
  static getBalance(i) {
    if (!B.isCoin(i))
      return;
    const c = Mr(i)?.balance;
    return BigInt(c);
  }
  static getType(i) {
    return Nr(i) ? ur(i) : i.type;
  }
}
class St {
  constructor(i, c, u) {
    m(this, "_objectId");
    m(this, "_typeArg");
    m(this, "_balance");
    m(this, "_symbol");
    this._objectId = i, this._balance = u, this._typeArg = c, this._symbol = B.getCoinSymbol(c);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(i) {
    return new St(i.objectId, i.typeArg, i.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
}
var hr = /* @__PURE__ */ ((r) => (r.DISCONNECTED = "disconnected", r.CONNECTED = "connected", r.CONNECTING = "connecting", r))(hr || {});
class yr {
  constructor(i) {
    m(this, "client");
    this.client = i;
  }
  async getOwnedObjects(i) {
    let c = !0, u = null, I = [];
    for (; c; ) {
      const g = await this.client.getOwnedObjects({
        owner: i,
        cursor: u,
        options: {
          showType: !0,
          showDisplay: !0,
          showContent: !0,
          showOwner: !0
        }
      });
      g.data?.forEach((a) => {
        const h = a.data;
        h && I.push(h);
      }), c = g.hasNextPage, u = g.nextCursor;
    }
    return I;
  }
  getSuiClient() {
    return this.client;
  }
  setSuiClient(i) {
    this.client = i;
  }
}
class fr extends yr {
  constructor(c, u) {
    super(c);
    m(this, "coinType");
    this.coinType = u;
  }
  /**
   * Get the coin object of one specific token type
   */
  async getOwnedCoins(c) {
    let u = !0, I = null, g = [];
    for (; u; ) {
      const A = await this.client.getCoins({
        owner: c,
        coinType: this.coinType,
        cursor: I
      });
      A.data.forEach((a) => {
        g.push(
          new St(a.coinObjectId, a.coinType, BigInt(a.balance))
        );
      }), u = A.hasNextPage, I = A.nextCursor;
    }
    return g;
  }
  async getBalance(c) {
    const u = await this.client.getBalance({
      owner: c,
      coinType: this.coinType
    });
    return BigInt(u.totalBalance);
  }
}
class an {
  constructor(i, c) {
    m(this, "address");
    m(this, "chainRpcUrl");
    m(this, "suiClient");
    this.address = i, this.chainRpcUrl = c.chainRpcUrl, this.suiClient = new Pt({
      url: c.chainRpcUrl
    });
  }
  getAddress() {
    return this.address;
  }
  getCoinBalance(i) {
    return new fr(this.suiClient, i).getBalance(this.address);
  }
  getSuiBalance() {
    return this.getCoinBalance(Ce);
  }
  getChainRpcUrl() {
    return this.chainRpcUrl;
  }
  setChainRpcUrl(i) {
    this.chainRpcUrl = i, this.suiClient = new Pt({
      url: i
    });
  }
}
const Xt = 1e6, jt = 1e9, pt = 1e12;
function Mn(r, i) {
  return te(
    r,
    Object.assign(
      {
        decimals: 9
      },
      i
    )
  );
}
function te(r, i) {
  const { decimals: c = 0, withAbbr: u = !0 } = i ?? {};
  if (typeof r == "bigint" && !pr(r))
    return re(BigInt(r), {
      decimals: c,
      withAbbr: u
    });
  if (Number(r) === 0)
    return "0";
  if (Number(r) < 0)
    return "-" + te(-Number(r), i);
  const I = Number(r) / 10 ** c;
  return I > 0 && I < 1 ? jr(I) : ee(I, u);
}
function ee(r, i) {
  if (i) {
    if (r >= Xt && r < jt)
      return Dt(r, Xt, "M");
    if (r >= jt && r < pt)
      return Dt(r, jt, "B");
    if (r >= pt)
      return Dt(r, pt, "T");
  }
  return Intl.NumberFormat("en-US").format(r);
}
function Dt(r, i, c) {
  let u;
  typeof r == "bigint" ? u = String(r / (BigInt(i) / 1000n)) : u = String(Math.floor(r / (i / 1e3)));
  const I = u.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(I)).replace(",", ".") + c;
}
function jr(r) {
  if (r <= 0)
    return "0";
  const i = Math.ceil(-Math.log10(r));
  return Number(r) % Math.pow(10, 10 - (i + 2)) === 0 && Number(r) % Math.pow(10, 10 - (i + 1)) === 0 ? Et(r, i) : Number(r) % Math.pow(10, 10 - (i + 2)) === 0 && Number(r) % Math.pow(10, 10 - (i + 1)) !== 0 ? Et(r, i + 1) : Et(r, i + 2);
}
function Et(r, i) {
  function c(u) {
    if (isNaN(u))
      return u.toString();
    const I = "" + u;
    return /e/i.test(I) ? u.toFixed(18).replace(/\.?0+$/, "") : u.toString();
  }
  return i = i || 0, i = Math.pow(10, i), c(Math.floor(r * i) / i);
}
function re(r, i) {
  if (r === 0n)
    return "0";
  if (r < 0n)
    return "-" + re(-r, i);
  const { decimals: c = 9, withAbbr: u = !0 } = i ?? {}, I = r / 10n ** BigInt(c);
  return ee(I, u);
}
function pr(r) {
  const i = Number.MIN_SAFE_INTEGER, c = Number.MAX_SAFE_INTEGER;
  return r >= BigInt(i) && r <= BigInt(c);
}
function ln(r) {
  return typeof r != "string" ? "" : !r || !r.startsWith("0x") ? r : r.slice(0, 7) + "...." + r.slice(-4, r.length);
}
function ne(r) {
  return Uint8Array.from(atob(r), (i) => i.charCodeAt(0));
}
var wt = {}, At = {};
At.byteLength = dr;
At.toByteArray = Tr;
At.fromByteArray = Sr;
var G = [], R = [], Dr = typeof Uint8Array < "u" ? Uint8Array : Array, dt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var tt = 0, Er = dt.length; tt < Er; ++tt)
  G[tt] = dt[tt], R[dt.charCodeAt(tt)] = tt;
R[45] = 62;
R[95] = 63;
function ie(r) {
  var i = r.length;
  if (i % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = r.indexOf("=");
  c === -1 && (c = i);
  var u = c === i ? 0 : 4 - c % 4;
  return [c, u];
}
function dr(r) {
  var i = ie(r), c = i[0], u = i[1];
  return (c + u) * 3 / 4 - u;
}
function wr(r, i, c) {
  return (i + c) * 3 / 4 - c;
}
function Tr(r) {
  var i, c = ie(r), u = c[0], I = c[1], g = new Dr(wr(r, u, I)), A = 0, a = I > 0 ? u - 4 : u, h;
  for (h = 0; h < a; h += 4)
    i = R[r.charCodeAt(h)] << 18 | R[r.charCodeAt(h + 1)] << 12 | R[r.charCodeAt(h + 2)] << 6 | R[r.charCodeAt(h + 3)], g[A++] = i >> 16 & 255, g[A++] = i >> 8 & 255, g[A++] = i & 255;
  return I === 2 && (i = R[r.charCodeAt(h)] << 2 | R[r.charCodeAt(h + 1)] >> 4, g[A++] = i & 255), I === 1 && (i = R[r.charCodeAt(h)] << 10 | R[r.charCodeAt(h + 1)] << 4 | R[r.charCodeAt(h + 2)] >> 2, g[A++] = i >> 8 & 255, g[A++] = i & 255), g;
}
function Lr(r) {
  return G[r >> 18 & 63] + G[r >> 12 & 63] + G[r >> 6 & 63] + G[r & 63];
}
function xr(r, i, c) {
  for (var u, I = [], g = i; g < c; g += 3)
    u = (r[g] << 16 & 16711680) + (r[g + 1] << 8 & 65280) + (r[g + 2] & 255), I.push(Lr(u));
  return I.join("");
}
function Sr(r) {
  for (var i, c = r.length, u = c % 3, I = [], g = 16383, A = 0, a = c - u; A < a; A += g)
    I.push(xr(r, A, A + g > a ? a : A + g));
  return u === 1 ? (i = r[c - 1], I.push(
    G[i >> 2] + G[i << 4 & 63] + "=="
  )) : u === 2 && (i = (r[c - 2] << 8) + r[c - 1], I.push(
    G[i >> 10] + G[i >> 4 & 63] + G[i << 2 & 63] + "="
  )), I.join("");
}
var Ct = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Ct.read = function(r, i, c, u, I) {
  var g, A, a = I * 8 - u - 1, h = (1 << a) - 1, j = h >> 1, p = -7, x = c ? I - 1 : 0, Q = c ? -1 : 1, S = r[i + x];
  for (x += Q, g = S & (1 << -p) - 1, S >>= -p, p += a; p > 0; g = g * 256 + r[i + x], x += Q, p -= 8)
    ;
  for (A = g & (1 << -p) - 1, g >>= -p, p += u; p > 0; A = A * 256 + r[i + x], x += Q, p -= 8)
    ;
  if (g === 0)
    g = 1 - j;
  else {
    if (g === h)
      return A ? NaN : (S ? -1 : 1) * (1 / 0);
    A = A + Math.pow(2, u), g = g - j;
  }
  return (S ? -1 : 1) * A * Math.pow(2, g - u);
};
Ct.write = function(r, i, c, u, I, g) {
  var A, a, h, j = g * 8 - I - 1, p = (1 << j) - 1, x = p >> 1, Q = I === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = u ? 0 : g - 1, rt = u ? 1 : -1, nt = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
  for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (a = isNaN(i) ? 1 : 0, A = p) : (A = Math.floor(Math.log(i) / Math.LN2), i * (h = Math.pow(2, -A)) < 1 && (A--, h *= 2), A + x >= 1 ? i += Q / h : i += Q * Math.pow(2, 1 - x), i * h >= 2 && (A++, h /= 2), A + x >= p ? (a = 0, A = p) : A + x >= 1 ? (a = (i * h - 1) * Math.pow(2, I), A = A + x) : (a = i * Math.pow(2, x - 1) * Math.pow(2, I), A = 0)); I >= 8; r[c + S] = a & 255, S += rt, a /= 256, I -= 8)
    ;
  for (A = A << I | a, j += I; j > 0; r[c + S] = A & 255, S += rt, A /= 256, j -= 8)
    ;
  r[c + S - rt] |= nt * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const i = At, c = Ct, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = a, r.SlowBuffer = se, r.INSPECT_MAX_BYTES = 50;
  const I = 2147483647;
  r.kMaxLength = I, a.TYPED_ARRAY_SUPPORT = g(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function g() {
    try {
      const n = new Uint8Array(1), t = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(n, t), n.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function A(n) {
    if (n > I)
      throw new RangeError('The value "' + n + '" is invalid for option "size"');
    const t = new Uint8Array(n);
    return Object.setPrototypeOf(t, a.prototype), t;
  }
  function a(n, t, e) {
    if (typeof n == "number") {
      if (typeof t == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return x(n);
    }
    return h(n, t, e);
  }
  a.poolSize = 8192;
  function h(n, t, e) {
    if (typeof n == "string")
      return Q(n, t);
    if (ArrayBuffer.isView(n))
      return rt(n);
    if (n == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n
      );
    if (W(n, ArrayBuffer) || n && W(n.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (W(n, SharedArrayBuffer) || n && W(n.buffer, SharedArrayBuffer)))
      return nt(n, t, e);
    if (typeof n == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const o = n.valueOf && n.valueOf();
    if (o != null && o !== n)
      return a.from(o, t, e);
    const s = ce(n);
    if (s)
      return s;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof n[Symbol.toPrimitive] == "function")
      return a.from(n[Symbol.toPrimitive]("string"), t, e);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n
    );
  }
  a.from = function(n, t, e) {
    return h(n, t, e);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function j(n) {
    if (typeof n != "number")
      throw new TypeError('"size" argument must be of type number');
    if (n < 0)
      throw new RangeError('The value "' + n + '" is invalid for option "size"');
  }
  function p(n, t, e) {
    return j(n), n <= 0 ? A(n) : t !== void 0 ? typeof e == "string" ? A(n).fill(t, e) : A(n).fill(t) : A(n);
  }
  a.alloc = function(n, t, e) {
    return p(n, t, e);
  };
  function x(n) {
    return j(n), A(n < 0 ? 0 : Nt(n) | 0);
  }
  a.allocUnsafe = function(n) {
    return x(n);
  }, a.allocUnsafeSlow = function(n) {
    return x(n);
  };
  function Q(n, t) {
    if ((typeof t != "string" || t === "") && (t = "utf8"), !a.isEncoding(t))
      throw new TypeError("Unknown encoding: " + t);
    const e = mt(n, t) | 0;
    let o = A(e);
    const s = o.write(n, t);
    return s !== e && (o = o.slice(0, s)), o;
  }
  function S(n) {
    const t = n.length < 0 ? 0 : Nt(n.length) | 0, e = A(t);
    for (let o = 0; o < t; o += 1)
      e[o] = n[o] & 255;
    return e;
  }
  function rt(n) {
    if (W(n, Uint8Array)) {
      const t = new Uint8Array(n);
      return nt(t.buffer, t.byteOffset, t.byteLength);
    }
    return S(n);
  }
  function nt(n, t, e) {
    if (t < 0 || n.byteLength < t)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (n.byteLength < t + (e || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let o;
    return t === void 0 && e === void 0 ? o = new Uint8Array(n) : e === void 0 ? o = new Uint8Array(n, t) : o = new Uint8Array(n, t, e), Object.setPrototypeOf(o, a.prototype), o;
  }
  function ce(n) {
    if (a.isBuffer(n)) {
      const t = Nt(n.length) | 0, e = A(t);
      return e.length === 0 || n.copy(e, 0, 0, t), e;
    }
    if (n.length !== void 0)
      return typeof n.length != "number" || ft(n.length) ? A(0) : S(n);
    if (n.type === "Buffer" && Array.isArray(n.data))
      return S(n.data);
  }
  function Nt(n) {
    if (n >= I)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + I.toString(16) + " bytes");
    return n | 0;
  }
  function se(n) {
    return +n != n && (n = 0), a.alloc(+n);
  }
  a.isBuffer = function(t) {
    return t != null && t._isBuffer === !0 && t !== a.prototype;
  }, a.compare = function(t, e) {
    if (W(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), W(e, Uint8Array) && (e = a.from(e, e.offset, e.byteLength)), !a.isBuffer(t) || !a.isBuffer(e))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (t === e)
      return 0;
    let o = t.length, s = e.length;
    for (let M = 0, l = Math.min(o, s); M < l; ++M)
      if (t[M] !== e[M]) {
        o = t[M], s = e[M];
        break;
      }
    return o < s ? -1 : s < o ? 1 : 0;
  }, a.isEncoding = function(t) {
    switch (String(t).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(t, e) {
    if (!Array.isArray(t))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (t.length === 0)
      return a.alloc(0);
    let o;
    if (e === void 0)
      for (e = 0, o = 0; o < t.length; ++o)
        e += t[o].length;
    const s = a.allocUnsafe(e);
    let M = 0;
    for (o = 0; o < t.length; ++o) {
      let l = t[o];
      if (W(l, Uint8Array))
        M + l.length > s.length ? (a.isBuffer(l) || (l = a.from(l)), l.copy(s, M)) : Uint8Array.prototype.set.call(
          s,
          l,
          M
        );
      else if (a.isBuffer(l))
        l.copy(s, M);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      M += l.length;
    }
    return s;
  };
  function mt(n, t) {
    if (a.isBuffer(n))
      return n.length;
    if (ArrayBuffer.isView(n) || W(n, ArrayBuffer))
      return n.byteLength;
    if (typeof n != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof n
      );
    const e = n.length, o = arguments.length > 2 && arguments[2] === !0;
    if (!o && e === 0)
      return 0;
    let s = !1;
    for (; ; )
      switch (t) {
        case "ascii":
        case "latin1":
        case "binary":
          return e;
        case "utf8":
        case "utf-8":
          return yt(n).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return e * 2;
        case "hex":
          return e >>> 1;
        case "base64":
          return Gt(n).length;
        default:
          if (s)
            return o ? -1 : yt(n).length;
          t = ("" + t).toLowerCase(), s = !0;
      }
  }
  a.byteLength = mt;
  function ue(n, t, e) {
    let o = !1;
    if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((e === void 0 || e > this.length) && (e = this.length), e <= 0) || (e >>>= 0, t >>>= 0, e <= t))
      return "";
    for (n || (n = "utf8"); ; )
      switch (n) {
        case "hex":
          return fe(this, t, e);
        case "utf8":
        case "utf-8":
          return bt(this, t, e);
        case "ascii":
          return he(this, t, e);
        case "latin1":
        case "binary":
          return ye(this, t, e);
        case "base64":
          return Ae(this, t, e);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, t, e);
        default:
          if (o)
            throw new TypeError("Unknown encoding: " + n);
          n = (n + "").toLowerCase(), o = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function q(n, t, e) {
    const o = n[t];
    n[t] = n[e], n[e] = o;
  }
  a.prototype.swap16 = function() {
    const t = this.length;
    if (t % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let e = 0; e < t; e += 2)
      q(this, e, e + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const t = this.length;
    if (t % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let e = 0; e < t; e += 4)
      q(this, e, e + 3), q(this, e + 1, e + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const t = this.length;
    if (t % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let e = 0; e < t; e += 8)
      q(this, e, e + 7), q(this, e + 1, e + 6), q(this, e + 2, e + 5), q(this, e + 3, e + 4);
    return this;
  }, a.prototype.toString = function() {
    const t = this.length;
    return t === 0 ? "" : arguments.length === 0 ? bt(this, 0, t) : ue.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(t) {
    if (!a.isBuffer(t))
      throw new TypeError("Argument must be a Buffer");
    return this === t ? !0 : a.compare(this, t) === 0;
  }, a.prototype.inspect = function() {
    let t = "";
    const e = r.INSPECT_MAX_BYTES;
    return t = this.toString("hex", 0, e).replace(/(.{2})/g, "$1 ").trim(), this.length > e && (t += " ... "), "<Buffer " + t + ">";
  }, u && (a.prototype[u] = a.prototype.inspect), a.prototype.compare = function(t, e, o, s, M) {
    if (W(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(t))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t
      );
    if (e === void 0 && (e = 0), o === void 0 && (o = t ? t.length : 0), s === void 0 && (s = 0), M === void 0 && (M = this.length), e < 0 || o > t.length || s < 0 || M > this.length)
      throw new RangeError("out of range index");
    if (s >= M && e >= o)
      return 0;
    if (s >= M)
      return -1;
    if (e >= o)
      return 1;
    if (e >>>= 0, o >>>= 0, s >>>= 0, M >>>= 0, this === t)
      return 0;
    let l = M - s, y = o - e;
    const w = Math.min(l, y), d = this.slice(s, M), T = t.slice(e, o);
    for (let D = 0; D < w; ++D)
      if (d[D] !== T[D]) {
        l = d[D], y = T[D];
        break;
      }
    return l < y ? -1 : y < l ? 1 : 0;
  };
  function zt(n, t, e, o, s) {
    if (n.length === 0)
      return -1;
    if (typeof e == "string" ? (o = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, ft(e) && (e = s ? 0 : n.length - 1), e < 0 && (e = n.length + e), e >= n.length) {
      if (s)
        return -1;
      e = n.length - 1;
    } else if (e < 0)
      if (s)
        e = 0;
      else
        return -1;
    if (typeof t == "string" && (t = a.from(t, o)), a.isBuffer(t))
      return t.length === 0 ? -1 : Ot(n, t, e, o, s);
    if (typeof t == "number")
      return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? s ? Uint8Array.prototype.indexOf.call(n, t, e) : Uint8Array.prototype.lastIndexOf.call(n, t, e) : Ot(n, [t], e, o, s);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ot(n, t, e, o, s) {
    let M = 1, l = n.length, y = t.length;
    if (o !== void 0 && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
      if (n.length < 2 || t.length < 2)
        return -1;
      M = 2, l /= 2, y /= 2, e /= 2;
    }
    function w(T, D) {
      return M === 1 ? T[D] : T.readUInt16BE(D * M);
    }
    let d;
    if (s) {
      let T = -1;
      for (d = e; d < l; d++)
        if (w(n, d) === w(t, T === -1 ? 0 : d - T)) {
          if (T === -1 && (T = d), d - T + 1 === y)
            return T * M;
        } else
          T !== -1 && (d -= d - T), T = -1;
    } else
      for (e + y > l && (e = l - y), d = e; d >= 0; d--) {
        let T = !0;
        for (let D = 0; D < y; D++)
          if (w(n, d + D) !== w(t, D)) {
            T = !1;
            break;
          }
        if (T)
          return d;
      }
    return -1;
  }
  a.prototype.includes = function(t, e, o) {
    return this.indexOf(t, e, o) !== -1;
  }, a.prototype.indexOf = function(t, e, o) {
    return zt(this, t, e, o, !0);
  }, a.prototype.lastIndexOf = function(t, e, o) {
    return zt(this, t, e, o, !1);
  };
  function ae(n, t, e, o) {
    e = Number(e) || 0;
    const s = n.length - e;
    o ? (o = Number(o), o > s && (o = s)) : o = s;
    const M = t.length;
    o > M / 2 && (o = M / 2);
    let l;
    for (l = 0; l < o; ++l) {
      const y = parseInt(t.substr(l * 2, 2), 16);
      if (ft(y))
        return l;
      n[e + l] = y;
    }
    return l;
  }
  function Me(n, t, e, o) {
    return at(yt(t, n.length - e), n, e, o);
  }
  function le(n, t, e, o) {
    return at(de(t), n, e, o);
  }
  function Ie(n, t, e, o) {
    return at(Gt(t), n, e, o);
  }
  function ge(n, t, e, o) {
    return at(we(t, n.length - e), n, e, o);
  }
  a.prototype.write = function(t, e, o, s) {
    if (e === void 0)
      s = "utf8", o = this.length, e = 0;
    else if (o === void 0 && typeof e == "string")
      s = e, o = this.length, e = 0;
    else if (isFinite(e))
      e = e >>> 0, isFinite(o) ? (o = o >>> 0, s === void 0 && (s = "utf8")) : (s = o, o = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const M = this.length - e;
    if ((o === void 0 || o > M) && (o = M), t.length > 0 && (o < 0 || e < 0) || e > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    s || (s = "utf8");
    let l = !1;
    for (; ; )
      switch (s) {
        case "hex":
          return ae(this, t, e, o);
        case "utf8":
        case "utf-8":
          return Me(this, t, e, o);
        case "ascii":
        case "latin1":
        case "binary":
          return le(this, t, e, o);
        case "base64":
          return Ie(this, t, e, o);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ge(this, t, e, o);
        default:
          if (l)
            throw new TypeError("Unknown encoding: " + s);
          s = ("" + s).toLowerCase(), l = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Ae(n, t, e) {
    return t === 0 && e === n.length ? i.fromByteArray(n) : i.fromByteArray(n.slice(t, e));
  }
  function bt(n, t, e) {
    e = Math.min(n.length, e);
    const o = [];
    let s = t;
    for (; s < e; ) {
      const M = n[s];
      let l = null, y = M > 239 ? 4 : M > 223 ? 3 : M > 191 ? 2 : 1;
      if (s + y <= e) {
        let w, d, T, D;
        switch (y) {
          case 1:
            M < 128 && (l = M);
            break;
          case 2:
            w = n[s + 1], (w & 192) === 128 && (D = (M & 31) << 6 | w & 63, D > 127 && (l = D));
            break;
          case 3:
            w = n[s + 1], d = n[s + 2], (w & 192) === 128 && (d & 192) === 128 && (D = (M & 15) << 12 | (w & 63) << 6 | d & 63, D > 2047 && (D < 55296 || D > 57343) && (l = D));
            break;
          case 4:
            w = n[s + 1], d = n[s + 2], T = n[s + 3], (w & 192) === 128 && (d & 192) === 128 && (T & 192) === 128 && (D = (M & 15) << 18 | (w & 63) << 12 | (d & 63) << 6 | T & 63, D > 65535 && D < 1114112 && (l = D));
        }
      }
      l === null ? (l = 65533, y = 1) : l > 65535 && (l -= 65536, o.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), o.push(l), s += y;
    }
    return Ne(o);
  }
  const Ut = 4096;
  function Ne(n) {
    const t = n.length;
    if (t <= Ut)
      return String.fromCharCode.apply(String, n);
    let e = "", o = 0;
    for (; o < t; )
      e += String.fromCharCode.apply(
        String,
        n.slice(o, o += Ut)
      );
    return e;
  }
  function he(n, t, e) {
    let o = "";
    e = Math.min(n.length, e);
    for (let s = t; s < e; ++s)
      o += String.fromCharCode(n[s] & 127);
    return o;
  }
  function ye(n, t, e) {
    let o = "";
    e = Math.min(n.length, e);
    for (let s = t; s < e; ++s)
      o += String.fromCharCode(n[s]);
    return o;
  }
  function fe(n, t, e) {
    const o = n.length;
    (!t || t < 0) && (t = 0), (!e || e < 0 || e > o) && (e = o);
    let s = "";
    for (let M = t; M < e; ++M)
      s += Te[n[M]];
    return s;
  }
  function je(n, t, e) {
    const o = n.slice(t, e);
    let s = "";
    for (let M = 0; M < o.length - 1; M += 2)
      s += String.fromCharCode(o[M] + o[M + 1] * 256);
    return s;
  }
  a.prototype.slice = function(t, e) {
    const o = this.length;
    t = ~~t, e = e === void 0 ? o : ~~e, t < 0 ? (t += o, t < 0 && (t = 0)) : t > o && (t = o), e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), e < t && (e = t);
    const s = this.subarray(t, e);
    return Object.setPrototypeOf(s, a.prototype), s;
  };
  function C(n, t, e) {
    if (n % 1 !== 0 || n < 0)
      throw new RangeError("offset is not uint");
    if (n + t > e)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(t, e, o) {
    t = t >>> 0, e = e >>> 0, o || C(t, e, this.length);
    let s = this[t], M = 1, l = 0;
    for (; ++l < e && (M *= 256); )
      s += this[t + l] * M;
    return s;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(t, e, o) {
    t = t >>> 0, e = e >>> 0, o || C(t, e, this.length);
    let s = this[t + --e], M = 1;
    for (; e > 0 && (M *= 256); )
      s += this[t + --e] * M;
    return s;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(t, e) {
    return t = t >>> 0, e || C(t, 1, this.length), this[t];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(t, e) {
    return t = t >>> 0, e || C(t, 2, this.length), this[t] | this[t + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(t, e) {
    return t = t >>> 0, e || C(t, 2, this.length), this[t] << 8 | this[t + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
  }, a.prototype.readBigUInt64LE = V(function(t) {
    t = t >>> 0, $(t, "offset");
    const e = this[t], o = this[t + 7];
    (e === void 0 || o === void 0) && it(t, this.length - 8);
    const s = e + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, M = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + o * 2 ** 24;
    return BigInt(s) + (BigInt(M) << BigInt(32));
  }), a.prototype.readBigUInt64BE = V(function(t) {
    t = t >>> 0, $(t, "offset");
    const e = this[t], o = this[t + 7];
    (e === void 0 || o === void 0) && it(t, this.length - 8);
    const s = e * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], M = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + o;
    return (BigInt(s) << BigInt(32)) + BigInt(M);
  }), a.prototype.readIntLE = function(t, e, o) {
    t = t >>> 0, e = e >>> 0, o || C(t, e, this.length);
    let s = this[t], M = 1, l = 0;
    for (; ++l < e && (M *= 256); )
      s += this[t + l] * M;
    return M *= 128, s >= M && (s -= Math.pow(2, 8 * e)), s;
  }, a.prototype.readIntBE = function(t, e, o) {
    t = t >>> 0, e = e >>> 0, o || C(t, e, this.length);
    let s = e, M = 1, l = this[t + --s];
    for (; s > 0 && (M *= 256); )
      l += this[t + --s] * M;
    return M *= 128, l >= M && (l -= Math.pow(2, 8 * e)), l;
  }, a.prototype.readInt8 = function(t, e) {
    return t = t >>> 0, e || C(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
  }, a.prototype.readInt16LE = function(t, e) {
    t = t >>> 0, e || C(t, 2, this.length);
    const o = this[t] | this[t + 1] << 8;
    return o & 32768 ? o | 4294901760 : o;
  }, a.prototype.readInt16BE = function(t, e) {
    t = t >>> 0, e || C(t, 2, this.length);
    const o = this[t + 1] | this[t] << 8;
    return o & 32768 ? o | 4294901760 : o;
  }, a.prototype.readInt32LE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
  }, a.prototype.readInt32BE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
  }, a.prototype.readBigInt64LE = V(function(t) {
    t = t >>> 0, $(t, "offset");
    const e = this[t], o = this[t + 7];
    (e === void 0 || o === void 0) && it(t, this.length - 8);
    const s = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (o << 24);
    return (BigInt(s) << BigInt(32)) + BigInt(e + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
  }), a.prototype.readBigInt64BE = V(function(t) {
    t = t >>> 0, $(t, "offset");
    const e = this[t], o = this[t + 7];
    (e === void 0 || o === void 0) && it(t, this.length - 8);
    const s = (e << 24) + // Overflow
    this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
    return (BigInt(s) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + o);
  }), a.prototype.readFloatLE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), c.read(this, t, !0, 23, 4);
  }, a.prototype.readFloatBE = function(t, e) {
    return t = t >>> 0, e || C(t, 4, this.length), c.read(this, t, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(t, e) {
    return t = t >>> 0, e || C(t, 8, this.length), c.read(this, t, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(t, e) {
    return t = t >>> 0, e || C(t, 8, this.length), c.read(this, t, !1, 52, 8);
  };
  function O(n, t, e, o, s, M) {
    if (!a.isBuffer(n))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t > s || t < M)
      throw new RangeError('"value" argument is out of bounds');
    if (e + o > n.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(t, e, o, s) {
    if (t = +t, e = e >>> 0, o = o >>> 0, !s) {
      const y = Math.pow(2, 8 * o) - 1;
      O(this, t, e, o, y, 0);
    }
    let M = 1, l = 0;
    for (this[e] = t & 255; ++l < o && (M *= 256); )
      this[e + l] = t / M & 255;
    return e + o;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(t, e, o, s) {
    if (t = +t, e = e >>> 0, o = o >>> 0, !s) {
      const y = Math.pow(2, 8 * o) - 1;
      O(this, t, e, o, y, 0);
    }
    let M = o - 1, l = 1;
    for (this[e + M] = t & 255; --M >= 0 && (l *= 256); )
      this[e + M] = t / l & 255;
    return e + o;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 1, 255, 0), this[e] = t & 255, e + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 2, 65535, 0), this[e] = t & 255, this[e + 1] = t >>> 8, e + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = t & 255, e + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = t & 255, e + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255, e + 4;
  };
  function Bt(n, t, e, o, s) {
    Wt(t, o, s, n, e, 7);
    let M = Number(t & BigInt(4294967295));
    n[e++] = M, M = M >> 8, n[e++] = M, M = M >> 8, n[e++] = M, M = M >> 8, n[e++] = M;
    let l = Number(t >> BigInt(32) & BigInt(4294967295));
    return n[e++] = l, l = l >> 8, n[e++] = l, l = l >> 8, n[e++] = l, l = l >> 8, n[e++] = l, e;
  }
  function Rt(n, t, e, o, s) {
    Wt(t, o, s, n, e, 7);
    let M = Number(t & BigInt(4294967295));
    n[e + 7] = M, M = M >> 8, n[e + 6] = M, M = M >> 8, n[e + 5] = M, M = M >> 8, n[e + 4] = M;
    let l = Number(t >> BigInt(32) & BigInt(4294967295));
    return n[e + 3] = l, l = l >> 8, n[e + 2] = l, l = l >> 8, n[e + 1] = l, l = l >> 8, n[e] = l, e + 8;
  }
  a.prototype.writeBigUInt64LE = V(function(t, e = 0) {
    return Bt(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = V(function(t, e = 0) {
    return Rt(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(t, e, o, s) {
    if (t = +t, e = e >>> 0, !s) {
      const w = Math.pow(2, 8 * o - 1);
      O(this, t, e, o, w - 1, -w);
    }
    let M = 0, l = 1, y = 0;
    for (this[e] = t & 255; ++M < o && (l *= 256); )
      t < 0 && y === 0 && this[e + M - 1] !== 0 && (y = 1), this[e + M] = (t / l >> 0) - y & 255;
    return e + o;
  }, a.prototype.writeIntBE = function(t, e, o, s) {
    if (t = +t, e = e >>> 0, !s) {
      const w = Math.pow(2, 8 * o - 1);
      O(this, t, e, o, w - 1, -w);
    }
    let M = o - 1, l = 1, y = 0;
    for (this[e + M] = t & 255; --M >= 0 && (l *= 256); )
      t < 0 && y === 0 && this[e + M + 1] !== 0 && (y = 1), this[e + M] = (t / l >> 0) - y & 255;
    return e + o;
  }, a.prototype.writeInt8 = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[e] = t & 255, e + 1;
  }, a.prototype.writeInt16LE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 2, 32767, -32768), this[e] = t & 255, this[e + 1] = t >>> 8, e + 2;
  }, a.prototype.writeInt16BE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = t & 255, e + 2;
  }, a.prototype.writeInt32LE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 4, 2147483647, -2147483648), this[e] = t & 255, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4;
  }, a.prototype.writeInt32BE = function(t, e, o) {
    return t = +t, e = e >>> 0, o || O(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255, e + 4;
  }, a.prototype.writeBigInt64LE = V(function(t, e = 0) {
    return Bt(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = V(function(t, e = 0) {
    return Rt(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Yt(n, t, e, o, s, M) {
    if (e + o > n.length)
      throw new RangeError("Index out of range");
    if (e < 0)
      throw new RangeError("Index out of range");
  }
  function kt(n, t, e, o, s) {
    return t = +t, e = e >>> 0, s || Yt(n, t, e, 4), c.write(n, t, e, o, 23, 4), e + 4;
  }
  a.prototype.writeFloatLE = function(t, e, o) {
    return kt(this, t, e, !0, o);
  }, a.prototype.writeFloatBE = function(t, e, o) {
    return kt(this, t, e, !1, o);
  };
  function Ft(n, t, e, o, s) {
    return t = +t, e = e >>> 0, s || Yt(n, t, e, 8), c.write(n, t, e, o, 52, 8), e + 8;
  }
  a.prototype.writeDoubleLE = function(t, e, o) {
    return Ft(this, t, e, !0, o);
  }, a.prototype.writeDoubleBE = function(t, e, o) {
    return Ft(this, t, e, !1, o);
  }, a.prototype.copy = function(t, e, o, s) {
    if (!a.isBuffer(t))
      throw new TypeError("argument should be a Buffer");
    if (o || (o = 0), !s && s !== 0 && (s = this.length), e >= t.length && (e = t.length), e || (e = 0), s > 0 && s < o && (s = o), s === o || t.length === 0 || this.length === 0)
      return 0;
    if (e < 0)
      throw new RangeError("targetStart out of bounds");
    if (o < 0 || o >= this.length)
      throw new RangeError("Index out of range");
    if (s < 0)
      throw new RangeError("sourceEnd out of bounds");
    s > this.length && (s = this.length), t.length - e < s - o && (s = t.length - e + o);
    const M = s - o;
    return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(e, o, s) : Uint8Array.prototype.set.call(
      t,
      this.subarray(o, s),
      e
    ), M;
  }, a.prototype.fill = function(t, e, o, s) {
    if (typeof t == "string") {
      if (typeof e == "string" ? (s = e, e = 0, o = this.length) : typeof o == "string" && (s = o, o = this.length), s !== void 0 && typeof s != "string")
        throw new TypeError("encoding must be a string");
      if (typeof s == "string" && !a.isEncoding(s))
        throw new TypeError("Unknown encoding: " + s);
      if (t.length === 1) {
        const l = t.charCodeAt(0);
        (s === "utf8" && l < 128 || s === "latin1") && (t = l);
      }
    } else
      typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
    if (e < 0 || this.length < e || this.length < o)
      throw new RangeError("Out of range index");
    if (o <= e)
      return this;
    e = e >>> 0, o = o === void 0 ? this.length : o >>> 0, t || (t = 0);
    let M;
    if (typeof t == "number")
      for (M = e; M < o; ++M)
        this[M] = t;
    else {
      const l = a.isBuffer(t) ? t : a.from(t, s), y = l.length;
      if (y === 0)
        throw new TypeError('The value "' + t + '" is invalid for argument "value"');
      for (M = 0; M < o - e; ++M)
        this[M + e] = l[M % y];
    }
    return this;
  };
  const _ = {};
  function ht(n, t, e) {
    _[n] = class extends e {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: t.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${n}]`, this.stack, delete this.name;
      }
      get code() {
        return n;
      }
      set code(s) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: s,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${n}]: ${this.message}`;
      }
    };
  }
  ht(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(n) {
      return n ? `${n} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ht(
    "ERR_INVALID_ARG_TYPE",
    function(n, t) {
      return `The "${n}" argument must be of type number. Received type ${typeof t}`;
    },
    TypeError
  ), ht(
    "ERR_OUT_OF_RANGE",
    function(n, t, e) {
      let o = `The value of "${n}" is out of range.`, s = e;
      return Number.isInteger(e) && Math.abs(e) > 2 ** 32 ? s = Qt(String(e)) : typeof e == "bigint" && (s = String(e), (e > BigInt(2) ** BigInt(32) || e < -(BigInt(2) ** BigInt(32))) && (s = Qt(s)), s += "n"), o += ` It must be ${t}. Received ${s}`, o;
    },
    RangeError
  );
  function Qt(n) {
    let t = "", e = n.length;
    const o = n[0] === "-" ? 1 : 0;
    for (; e >= o + 4; e -= 3)
      t = `_${n.slice(e - 3, e)}${t}`;
    return `${n.slice(0, e)}${t}`;
  }
  function pe(n, t, e) {
    $(t, "offset"), (n[t] === void 0 || n[t + e] === void 0) && it(t, n.length - (e + 1));
  }
  function Wt(n, t, e, o, s, M) {
    if (n > e || n < t) {
      const l = typeof t == "bigint" ? "n" : "";
      let y;
      throw t === 0 || t === BigInt(0) ? y = `>= 0${l} and < 2${l} ** ${(M + 1) * 8}${l}` : y = `>= -(2${l} ** ${(M + 1) * 8 - 1}${l}) and < 2 ** ${(M + 1) * 8 - 1}${l}`, new _.ERR_OUT_OF_RANGE("value", y, n);
    }
    pe(o, s, M);
  }
  function $(n, t) {
    if (typeof n != "number")
      throw new _.ERR_INVALID_ARG_TYPE(t, "number", n);
  }
  function it(n, t, e) {
    throw Math.floor(n) !== n ? ($(n, e), new _.ERR_OUT_OF_RANGE("offset", "an integer", n)) : t < 0 ? new _.ERR_BUFFER_OUT_OF_BOUNDS() : new _.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${t}`,
      n
    );
  }
  const De = /[^+/0-9A-Za-z-_]/g;
  function Ee(n) {
    if (n = n.split("=")[0], n = n.trim().replace(De, ""), n.length < 2)
      return "";
    for (; n.length % 4 !== 0; )
      n = n + "=";
    return n;
  }
  function yt(n, t) {
    t = t || 1 / 0;
    let e;
    const o = n.length;
    let s = null;
    const M = [];
    for (let l = 0; l < o; ++l) {
      if (e = n.charCodeAt(l), e > 55295 && e < 57344) {
        if (!s) {
          if (e > 56319) {
            (t -= 3) > -1 && M.push(239, 191, 189);
            continue;
          } else if (l + 1 === o) {
            (t -= 3) > -1 && M.push(239, 191, 189);
            continue;
          }
          s = e;
          continue;
        }
        if (e < 56320) {
          (t -= 3) > -1 && M.push(239, 191, 189), s = e;
          continue;
        }
        e = (s - 55296 << 10 | e - 56320) + 65536;
      } else
        s && (t -= 3) > -1 && M.push(239, 191, 189);
      if (s = null, e < 128) {
        if ((t -= 1) < 0)
          break;
        M.push(e);
      } else if (e < 2048) {
        if ((t -= 2) < 0)
          break;
        M.push(
          e >> 6 | 192,
          e & 63 | 128
        );
      } else if (e < 65536) {
        if ((t -= 3) < 0)
          break;
        M.push(
          e >> 12 | 224,
          e >> 6 & 63 | 128,
          e & 63 | 128
        );
      } else if (e < 1114112) {
        if ((t -= 4) < 0)
          break;
        M.push(
          e >> 18 | 240,
          e >> 12 & 63 | 128,
          e >> 6 & 63 | 128,
          e & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return M;
  }
  function de(n) {
    const t = [];
    for (let e = 0; e < n.length; ++e)
      t.push(n.charCodeAt(e) & 255);
    return t;
  }
  function we(n, t) {
    let e, o, s;
    const M = [];
    for (let l = 0; l < n.length && !((t -= 2) < 0); ++l)
      e = n.charCodeAt(l), o = e >> 8, s = e % 256, M.push(s), M.push(o);
    return M;
  }
  function Gt(n) {
    return i.toByteArray(Ee(n));
  }
  function at(n, t, e, o) {
    let s;
    for (s = 0; s < o && !(s + e >= t.length || s >= n.length); ++s)
      t[s + e] = n[s];
    return s;
  }
  function W(n, t) {
    return n instanceof t || n != null && n.constructor != null && n.constructor.name != null && n.constructor.name === t.name;
  }
  function ft(n) {
    return n !== n;
  }
  const Te = function() {
    const n = "0123456789abcdef", t = new Array(256);
    for (let e = 0; e < 16; ++e) {
      const o = e * 16;
      for (let s = 0; s < 16; ++s)
        t[o + s] = n[e] + n[s];
    }
    return t;
  }();
  function V(n) {
    return typeof BigInt > "u" ? Le : n;
  }
  function Le() {
    throw new Error("BigInt not supported");
  }
})(wt);
class Cr {
  static toHex(i) {
    return wt.Buffer.from(i).toString("hex");
  }
  static ensureUint8Array(i) {
    return typeof i == "string" ? Uint8Array.from(wt.Buffer.from(i, "base64")) : i instanceof Uint8Array ? i : Uint8Array.from(i);
  }
  static bytesEqual(i, c) {
    if (i === c)
      return !0;
    if (i.length !== c.length)
      return !1;
    for (let u = 0; u < i.length; u++)
      if (i[u] !== c[u])
        return !1;
    return !0;
  }
}
function It(r, i) {
  return Object.prototype.hasOwnProperty.call(r, i);
}
async function gn(r, i) {
  let c;
  if (It(r, "bytes"))
    c = r.bytes;
  else if (It(r, "messageBytes"))
    c = r.messageBytes;
  else
    throw new Error(
      "input should be either SuiSignPersonalMessageOutput or SuiSignMessageOutput"
    );
  try {
    const u = await me(
      ne(c),
      r.signature
    );
    return Cr.bytesEqual(u.toRawBytes(), i);
  } catch {
    return !1;
  }
}
function An(r) {
  return new TextDecoder().decode(ne(r));
}
function U(r) {
  return Object.freeze(r);
}
var X = /* @__PURE__ */ ((r) => (r.SUI_WALLET = "Sui Wallet", r.SUIET_WALLET = "Suiet", r.ETHOS_WALLET = "Ethos Wallet", r.SURF_WALLET = "Surf Wallet", r.GLASS_WALLET = "GlassWallet", r.MORPHIS_WALLET = "Morphis Wallet", r.MARTIAN_WALLET = "Martian Sui Wallet", r.ONEKEY_WALLET = "OneKey Wallet", r.SPACECY_WALLET = "Spacecy Sui Wallet", r.SENSUI_WALLET = "Sensui Wallet", r.NIGHTLY_WALLET = "Nightly", r.ELLI_WALLET = "Elli", r.TOKENPOCKET_WALLET = "TokenPocket Wallet", r.FRONTIER_WALLET = "Frontier Wallet", r))(X || {});
const mr = U({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
}), zr = U({
  name: "Sui Wallet",
  label: "Sui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////9/f39/f3+/v7x+Pz///95wfGj1PXI5fgEMJeQAAAAB3RSTlMAECNgmNr40ET05wAAAOBJREFUeNplUksOgjAQbYw38LdloQdw5VZJDGuNiWtXdGvUFjlAtT2AVC4AekrLvKKYvoTMm5fpfGGswWCdit2cfTFNZYO49YfSYwW/t2+FS0TCTH6x/Q/wISPZwcYJSVc4uxdg1wI2Yn0QbmCXbAKin7AHtiCbq6wicvI5syK/+azowlZSoxNGc4l7IWswhqKlagtD4Kl9CAWBAmspbGHwhJK+HDMlkiaIcJ9BWWqMu64yhcbGVMU5nKoc/XC2fGs/HMbPra78+MGCwhUGSw7OEB4qOKU7Nrki/p2/8zt8ABpiv63tyiOHAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
}), Or = U({
  name: "Ethos Wallet",
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
}), br = U({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
}), Ur = U({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
}), Br = U({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
}), Rr = U({
  name: "Morphis Wallet",
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
}), Yr = U({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
}), kr = U({
  name: "Spacecy Sui Wallet",
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
}), Fr = U({
  name: "Sensui Wallet",
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
}), Qr = U({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
}), Wr = U({
  name: "Elli",
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
}), Gr = U({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://tokenpocket.pro/"
  }
}), Pr = U({
  name: "Frontier Wallet",
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
}), Nn = [
  mr,
  zr,
  ...[
    Or,
    br,
    Ur,
    Rr,
    Br,
    Yr,
    kr,
    Fr,
    Qr,
    Wr,
    Gr,
    Pr
  ].sort((r, i) => r.name < i.name ? -1 : 1)
];
var J = /* @__PURE__ */ ((r) => (r.STANDARD__CONNECT = "standard:connect", r.STANDARD__DISCONNECT = "standard:disconnect", r.STANDARD__EVENTS = "standard:events", r.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", r.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", r.SUI__SIGN_PERSONAL_MESSAGE = "sui:signPersonalMessage", r.SUI__SIGN_MESSAGE = "sui:signMessage", r))(J || {}), z = /* @__PURE__ */ ((r) => (r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", r.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", r.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", r.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", r.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", r.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", r.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", r.WALLET__SIGN_PERSONAL_MSG_ERROR = "WALLET.SIGN_PERSONAL_MSG_ERROR", r.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", r.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", r))(z || {});
class oe extends Error {
  constructor(c, u = z.UNKNOWN_ERROR, I) {
    super(c);
    m(this, "code");
    m(this, "details");
    this.details = I, this.code = u, this.message = this.formatErrorStr(u, c, I);
  }
  formatErrorStr(c, u, I) {
    let g = `[${this.code}] ${u}`;
    return I && (g += " | details: " + JSON.stringify(I)), g;
  }
}
class hn extends oe {
  constructor(i = "kit unknown error", c = z.KIT__UNKNOWN_ERROR, u) {
    super(i, c, u);
  }
}
class H extends oe {
  constructor(i = "wallet unknown error", c = z.WALLET__UNKNOWN_ERROR, u) {
    super(i, c, u);
  }
}
class Zr extends H {
  constructor(i) {
    super(`wallet does not implement function: ${i}`, z.WALLET__METHOD_NOT_IMPLEMENTED_ERROR);
  }
}
function Vr(r, i) {
  let c = z.WALLET__CONNECT_ERROR, u = r.message;
  switch (i) {
    case X.SUI_WALLET:
    case X.ETHOS_WALLET:
    case X.GLASS_WALLET:
    case X.MORPHIS_WALLET:
      u.includes("Permission rejected") && (c = z.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case X.SUIET_WALLET:
      u.includes("User rejects approval") && (c = z.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case X.SPACECY_WALLET:
      c = z.WALLET__CONNECT_ERROR__USER_REJECTED;
      break;
    case X.SURF_WALLET:
      u.includes("The user rejected the request") && (c = z.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
  }
  return {
    code: c,
    message: u,
    details: {
      wallet: i
    }
  };
}
class Xr {
  constructor(i) {
    m(this, "standardWalletAdapter");
    this.standardWalletAdapter = i;
  }
  get name() {
    return this.standardWalletAdapter.name;
  }
  get icon() {
    return this.standardWalletAdapter.icon;
  }
  get version() {
    return this.standardWalletAdapter.version;
  }
  get accounts() {
    return this.standardWalletAdapter.accounts;
  }
  get chains() {
    return this.standardWalletAdapter.chains;
  }
  get features() {
    return this.standardWalletAdapter.features;
  }
  async connect(i) {
    const c = this.getFeature(
      J.STANDARD__CONNECT
    );
    try {
      return await c.connect(i);
    } catch (u) {
      const { code: I, message: g, details: A } = Vr(u, this.name);
      throw new H(g, I, A);
    }
  }
  async disconnect() {
    const i = this.getFeature(
      J.STANDARD__DISCONNECT
    );
    try {
      return await i.disconnect();
    } catch (c) {
      throw new H(c.message, z.WALLET__DISCONNECT_ERROR);
    }
  }
  on(i, c) {
    const u = this.getFeature(
      J.STANDARD__EVENTS
    );
    try {
      return u.on(i, c);
    } catch (I) {
      throw new H(I.message, z.WALLET__LISTEN_TO_EVENT_ERROR);
    }
  }
  async signAndExecuteTransactionBlock(i) {
    const c = this.getFeature(J.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
    try {
      return await c.signAndExecuteTransactionBlock(i);
    } catch (u) {
      throw new H(u.message, z.WALLET__SIGN_TX_ERROR);
    }
  }
  signTransactionBlock(i) {
    const c = this.getFeature(J.SUI__SIGN_TRANSACTION_BLOCK);
    try {
      return c.signTransactionBlock(i);
    } catch (u) {
      throw new H(u.message, z.WALLET__SIGN_TX_ERROR);
    }
  }
  async signMessage(i) {
    const c = this.getFeature(
      J.SUI__SIGN_MESSAGE
    );
    try {
      return await c.signMessage(i);
    } catch (u) {
      throw new H(u.message, z.WALLET__SIGN_MSG_ERROR);
    }
  }
  signPersonalMessage(i) {
    const c = this.getFeature(J.SUI__SIGN_PERSONAL_MESSAGE);
    try {
      return c.signPersonalMessage(i);
    } catch (u) {
      throw new H(
        u.message,
        z.WALLET__SIGN_PERSONAL_MSG_ERROR
      );
    }
  }
  hasFeature(i) {
    const { features: c } = this.standardWalletAdapter;
    return It(c, i);
  }
  getFeature(i) {
    const { features: c } = this.standardWalletAdapter;
    if (!It(c, i))
      throw new Zr(i);
    return c[i];
  }
}
var Jr = function(r, i, c, u, I) {
  if (u === "m")
    throw new TypeError("Private method is not writable");
  if (u === "a" && !I)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof i == "function" ? r !== i || !I : !i.has(r))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return u === "a" ? I.call(r, c) : I ? I.value = c : i.set(r, c), c;
}, Hr = function(r, i, c, u) {
  if (c === "a" && !u)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof i == "function" ? r !== i || !u : !i.has(r))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return c === "m" ? u : c === "a" ? u.call(r) : u ? u.value : i.get(r);
}, Mt;
let ot;
const lt = /* @__PURE__ */ new Set(), et = {};
function vr() {
  if (ot || (ot = Object.freeze({ register: Jt, get: qr, on: Kr }), typeof window > "u"))
    return ot;
  const r = Object.freeze({ register: Jt });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: i }) => i(r));
  } catch (i) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, i);
  }
  try {
    window.dispatchEvent(new _r(r));
  } catch (i) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, i);
  }
  return ot;
}
function Jt(...r) {
  return r = r.filter((i) => !lt.has(i)), r.length ? (r.forEach((i) => lt.add(i)), et.register?.forEach((i) => Ht(() => i(...r))), function() {
    r.forEach((c) => lt.delete(c)), et.unregister?.forEach((c) => Ht(() => c(...r)));
  }) : () => {
  };
}
function qr() {
  return [...lt];
}
function Kr(r, i) {
  return et[r]?.push(i) || (et[r] = [i]), function() {
    et[r] = et[r]?.filter((u) => i !== u);
  };
}
function Ht(r) {
  try {
    r();
  } catch (i) {
    console.error(i);
  }
}
class _r extends Event {
  constructor(i) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), Mt.set(this, void 0), Jr(this, Mt, i, "f");
  }
  get detail() {
    return Hr(this, Mt, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
Mt = /* @__PURE__ */ new WeakMap();
function $r(r) {
  return "standard:connect" in r.features && "standard:events" in r.features && "sui:signAndExecuteTransactionBlock" in r.features;
}
class yn {
  constructor() {
    m(this, "walletStandardSdk");
    m(this, "walletAdapterMap");
    m(this, "clearOnRegisterListener");
    m(this, "subscriptions", /* @__PURE__ */ new Set());
    this.walletStandardSdk = null, this.clearOnRegisterListener = null, this.walletAdapterMap = /* @__PURE__ */ new Map();
  }
  activate() {
    this.walletStandardSdk = vr(), this.walletStandardSdk.get().forEach((c) => {
      this.setDetectedWalletAdapters(c);
    }), this.clearOnRegisterListener = this.walletStandardSdk.on(
      "register",
      (...c) => {
        c.forEach((u) => {
          this.setDetectedWalletAdapters(u);
        }), this.notifySubscribers();
      }
    );
  }
  deactivate() {
    this.clearOnRegisterListener && this.clearOnRegisterListener(), this.walletAdapterMap.clear();
  }
  getDetectedWalletAdapters() {
    return Array.from(this.walletAdapterMap.values());
  }
  subscribe(i) {
    return this.subscriptions.add(i), () => {
      this.subscriptions.delete(i);
    };
  }
  notifySubscribers() {
    this.subscriptions.forEach((i) => {
      i(this.getDetectedWalletAdapters());
    });
  }
  setDetectedWalletAdapters(i) {
    $r(i) && (this.walletAdapterMap.has(i.name) || this.walletAdapterMap.set(i.name, new Xr(i)));
  }
}
var tn = /* @__PURE__ */ ((r) => (r.DEV_NET = "sui:devnet", r.TEST_NET = "sui:testnet", r.MAIN_NET = "sui:mainnet", r.DEVNET = "sui:devnet", r.TestNET = "sui:testnet", r))(tn || {});
const en = {
  id: "sui:devnet",
  name: "Sui Devnet",
  rpcUrl: "https://fullnode.devnet.sui.io/"
}, rn = {
  id: "sui:testnet",
  name: "Sui Testnet",
  rpcUrl: "https://fullnode.testnet.sui.io/"
}, nn = {
  id: "sui:mainnet",
  name: "Sui Mainnet",
  rpcUrl: "https://rpc.mainnet.sui.io/"
}, fn = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
}, jn = [en, rn, nn];
export {
  an as AccountAssetManager,
  fr as AccountCoinManager,
  yr as AccountObjectManager,
  Nn as AllDefaultWallets,
  oe as BaseError,
  St as CoinObject,
  hr as ConnectionStatus,
  jn as DefaultChains,
  Wr as ElliWallet,
  z as ErrorCode,
  Or as EthosWallet,
  J as FeatureName,
  Pr as FrontierWallet,
  Br as GlassWallet,
  hn as KitError,
  br as MartianWallet,
  Rr as MorphisWallet,
  Qr as NightlyWallet,
  Yr as OneKeyWallet,
  X as PresetWallet,
  Fr as SensuiWallet,
  kr as SpacecyWallet,
  tn as SuiChainId,
  en as SuiDevnetChain,
  nn as SuiMainnetChain,
  rn as SuiTestnetChain,
  zr as SuiWallet,
  mr as SuietWallet,
  Ur as SurfWallet,
  Gr as TokenPocketWallet,
  Cr as Uint8arrayTool,
  fn as UnknownChain,
  Xr as WalletAdapter,
  H as WalletError,
  Zr as WalletNotImplementError,
  yn as WalletRadar,
  ln as addressEllipsis,
  U as defineWallet,
  te as formatCurrency,
  Mn as formatSUI,
  Vr as handleConnectionError,
  It as has,
  An as stringBytesToString,
  ne as stringBytesToUint8Array,
  gn as verifySignedMessage
};
