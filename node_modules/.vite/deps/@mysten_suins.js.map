{
  "version": 3,
  "sources": ["../../axios/lib/helpers/bind.js", "../../axios/lib/utils.js", "../../axios/lib/helpers/buildURL.js", "../../axios/lib/core/InterceptorManager.js", "../../axios/lib/helpers/normalizeHeaderName.js", "../../axios/lib/core/enhanceError.js", "../../axios/lib/core/createError.js", "../../axios/lib/core/settle.js", "../../axios/lib/helpers/cookies.js", "../../axios/lib/helpers/isAbsoluteURL.js", "../../axios/lib/helpers/combineURLs.js", "../../axios/lib/core/buildFullPath.js", "../../axios/lib/helpers/parseHeaders.js", "../../axios/lib/helpers/isURLSameOrigin.js", "../../axios/lib/cancel/Cancel.js", "../../axios/lib/adapters/xhr.js", "../../axios/lib/defaults.js", "../../axios/lib/core/transformData.js", "../../axios/lib/cancel/isCancel.js", "../../axios/lib/core/dispatchRequest.js", "../../axios/lib/core/mergeConfig.js", "../../axios/lib/env/data.js", "../../axios/lib/helpers/validator.js", "../../axios/lib/core/Axios.js", "../../axios/lib/cancel/CancelToken.js", "../../axios/lib/helpers/spread.js", "../../axios/lib/helpers/isAxiosError.js", "../../axios/lib/axios.js", "../../axios/index.js", "../../is-retry-allowed/index.js", "../../@mysten/suins/node_modules/base-x/src/esm/index.js", "../../@mysten/suins/node_modules/bs58/src/esm/index.js", "../../@mysten/suins/node_modules/@mysten/bcs/src/b58.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/b64.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/hex.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/uleb.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/reader.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/utils.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/writer.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/bcs-type.ts", "../../@mysten/suins/node_modules/@mysten/bcs/src/bcs.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/utils/sui-types.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/utils/suins.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/utils/constants.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/bcs/bcs.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/bcs/effects.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/bcs/pure.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/bcs/index.ts", "../../@mysten/suins/src/constants.ts", "../../@mysten/suins/src/helpers.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/serializer.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/Inputs.ts", "../../@mysten/suins/node_modules/valibot/dist/index.js", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/data/internal.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/Commands.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/data/v1.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/data/v2.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/json-rpc-resolver.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/object.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/pure.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/hash.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/TransactionData.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/utils.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/Transaction.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/ObjectCache.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/executor/caching.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/executor/queue.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/executor/serial.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/executor/parallel.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/intents/CoinWithBalance.ts", "../../@mysten/suins/node_modules/@mysten/sui/src/transactions/Arguments.ts", "../../@mysten/suins/src/pyth/PriceServiceConnection.ts", "../../axios-retry/es/index.mjs", "../../@mysten/suins/src/pyth/pyth-helpers.ts", "../../@mysten/suins/src/pyth/pyth.ts", "../../@mysten/suins/src/suins-client.ts", "../../@mysten/suins/src/suins-transaction.ts"],
  "sourcesContent": ["'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n", "'use strict';\n\nvar bind = require('./helpers/bind');\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n", "'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n", "'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n", "'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n", "'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n", "'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n", "'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n", "'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n", "'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n", "'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n", "'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n", "'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n", "'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n", "'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n", "'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar defaults = require('../defaults');\nvar Cancel = require('../cancel/Cancel');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n", "'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\nvar enhanceError = require('./core/enhanceError');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n", "'use strict';\n\nvar utils = require('./../utils');\nvar defaults = require('./../defaults');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n", "'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n", "'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar Cancel = require('../cancel/Cancel');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n", "'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n", "module.exports = {\n  \"version\": \"0.24.0\"\n};", "'use strict';\n\nvar VERSION = require('../env/data').version;\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n", "'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n", "'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n", "'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n", "'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n", "'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\naxios.VERSION = require('./env/data').version;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n", "module.exports = require('./lib/axios');", "'use strict';\n\nconst denyList = new Set([\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED',\n\t'HOSTNAME_MISMATCH'\n]);\n\n// TODO: Use `error?.code` when targeting Node.js 14\nmodule.exports = error => !denyList.has(error && error.code);\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n", "import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n\tconst intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\tif (intArr.length !== padded.length / 2) {\n\t\tthrow new Error(`Invalid hex string ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.vector(bcs.u8()),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = T & {\n\terror: `Invalid Pure type name: ${T}`;\n};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = name.match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tCommand,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\tTransactionEffects,\n\tPasskeyAuthenticator,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Config } from './types.js';\n\nexport const MAX_U64 = BigInt('18446744073709551615');\n\n/**\n * Allowed keys for metadata.\n */\nexport const ALLOWED_METADATA = {\n\tcontentHash: 'content_hash',\n\tavatar: 'avatar',\n\twalrusSiteId: 'walrus_site_id',\n};\n\nexport const mainPackage: Config = {\n\tmainnet: {\n\t\tpackageId: '0x71af035413ed499710980ed8adb010bbf2cc5cacf4ab37c7710a4bb87eb58ba5',\n\t\tpackageIdV1: '0xd22b24490e0bae52676651b4f56660a5ff8022a2576e0089f79b3c88d44e08f0',\n\t\tpackageIdPricing: '0x71af035413ed499710980ed8adb010bbf2cc5cacf4ab37c7710a4bb87eb58ba5',\n\t\tsuins: '0x6e0ddefc0ad98889c04bab9639e512c21766c5e6366f89e696956d9be6952871',\n\t\tdiscountsPackage: {\n\t\t\tpackageId: '0x03f625d805339b1b0235ba8c503fa6ea62c88c02ddf14cd9d246d9e1febc0c76',\n\t\t\tdiscountHouseId: '0x4ce82dee11e6f4858509dcdba1a62985f12e5afb054df680a04f16790bfe1d04',\n\t\t},\n\t\tsubNamesPackageId: '0xe177697e191327901637f8d2c5ffbbde8b1aaac27ec1024c4b62d1ebd1cd7430',\n\t\ttempSubdomainsProxyPackageId:\n\t\t\t'0xf335dfbcb2020fc996250c0d6fd4655c5e2036b0606cac7408aa163f51340886',\n\t\tcoupons: {\n\t\t\tpackageId: '0xb162340524e0697461c307b9dc530c17e837b0f2c6d7f787da40d29d29681e5e',\n\t\t},\n\t\tpayments: {\n\t\t\tpackageId: '0x863d5f9760f302495398c8e4c6e9784bc17c44b079c826a1813715ef08cbe41a',\n\t\t},\n\t\tpyth: {\n\t\t\tpythStateId: '0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8',\n\t\t\twormholeStateId: '0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c',\n\t\t},\n\t\tcoins: {\n\t\t\tSUI: {\n\t\t\t\ttype: '0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI',\n\t\t\t\tfeed: '0x23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744',\n\t\t\t},\n\t\t\tNS: {\n\t\t\t\ttype: '0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178::ns::NS',\n\t\t\t\tfeed: '0xbb5ff26e47a3a6cc7ec2fce1db996c2a145300edc5acaabe43bf9ff7c5dd5d32',\n\t\t\t},\n\t\t\tUSDC: {\n\t\t\t\ttype: '0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC',\n\t\t\t\tfeed: '',\n\t\t\t},\n\t\t},\n\t\tregistryTableId: '0xe64cd9db9f829c6cc405d9790bd71567ae07259855f4fba6f02c84f52298c106',\n\t},\n\ttestnet: {\n\t\tpackageId: '0x40eee27b014a872f5c3330dcd5329aa55c7fe0fcc6e70c6498852e2e3727172e',\n\t\tpackageIdV1: '0x22fa05f21b1ad71442491220bb9338f7b7095fe35000ef88d5400d28523bdd93',\n\t\tpackageIdPricing: '0x8a4df604a449ccb9ef2efb9747046b78f78ba60fc8d88df098d0dd47619df5a4',\n\t\tsuins: '0x300369e8909b9a6464da265b9a5a9ab6fe2158a040e84e808628cde7a07ee5a3',\n\t\tdiscountsPackage: {\n\t\t\tpackageId: '0x7976f9bfe81dcbdbb635efb0ecb02844cd79109d3a698d05c06ca9fd2f97d262',\n\t\t\tdiscountHouseId: '0x9f1ac0f49ddaec4fd2248ae1cc63ed91946f43a236b333439efb9126f31f8e9b',\n\t\t},\n\t\tsubNamesPackageId: '0x3c272bc45f9157b7818ece4f7411bdfa8af46303b071aca4e18c03119c9ff636',\n\t\ttempSubdomainsProxyPackageId:\n\t\t\t'0x295a0749dae0e76126757c305f218f929df0656df66a6361f8b6c6480a943f12',\n\t\tcoupons: {\n\t\t\tpackageId: '0x63029aae8abbefae4f4ac6c5e3e0021159ea93a94ba648681fd64caf5b40677a',\n\t\t},\n\t\tpayments: {\n\t\t\tpackageId: '0x9e8b85270cf5e7ec0ae44c745abe000b6dd7d8b54ca2d367e044d8baccefc10c',\n\t\t},\n\t\tpyth: {\n\t\t\tpythStateId: '0x243759059f4c3111179da5878c12f68d612c21a8d54d85edc86164bb18be1c7c',\n\t\t\twormholeStateId: '0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790',\n\t\t},\n\t\t/// Testnet coins will be different here for testing purposes, we can publish our own\n\t\tcoins: {\n\t\t\tSUI: {\n\t\t\t\ttype: '0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI',\n\t\t\t\tfeed: '0x50c67b3fd225db8912a424dd4baed60ffdde625ed2feaaf283724f9608fea266',\n\t\t\t},\n\t\t\t/// this is a test token published as 0xb48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTNS::TESTNS\n\t\t\t/// NS token is using the HFT feed since NS feed on testnet is not available\n\t\t\tNS: {\n\t\t\t\ttype: '0xb48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTNS::TESTNS',\n\t\t\t\tfeed: '0x99137a18354efa7fb6840889d059fdb04c46a6ce21be97ab60d9ad93e91ac758',\n\t\t\t},\n\t\t\t/// this is a test token published as 0xb48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTUSDC::TESTUSDC\n\t\t\tUSDC: {\n\t\t\t\ttype: '0xb48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTUSDC::TESTUSDC',\n\t\t\t\tfeed: '',\n\t\t\t},\n\t\t},\n\t\tregistryTableId: '0xb120c0d55432630fce61f7854795a3463deb6e3b443cc4ae72e1282073ff56e4',\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { normalizeSuiNSName } from '@mysten/sui/utils';\n\nexport function isSubName(name: string): boolean {\n\treturn normalizeSuiNSName(name, 'dot').split('.').length > 2;\n}\n\n/**\n * Checks if a name is a nested subname.\n * A nested subdomain is a subdomain that is a subdomain of another subdomain.\n * @param name The name to check (e.g test.example.sub.sui)\n */\nexport function isNestedSubName(name: string): boolean {\n\treturn normalizeSuiNSName(name, 'dot').split('.').length > 3;\n}\n\n/**\n * The years must be between 1 and 5.\n */\nexport function validateYears(years: number) {\n\tif (!(years > 0 && years < 6)) throw new Error('Years must be between 1 and 5');\n}\n\nexport function zeroCoin(tx: Transaction, type: string) {\n\treturn tx.moveCall({\n\t\ttarget: '0x2::coin::zero',\n\t\ttypeArguments: [type],\n\t});\n}\n\nexport function getConfigType(suinsPackageV1: string, innerType: string): string {\n\treturn `${suinsPackageV1}::suins::ConfigKey<${innerType}>`;\n}\n\nexport function getDomainType(suinsPackageV1: string): string {\n\treturn `${suinsPackageV1}::domain::Domain`;\n}\n\nexport function getPricelistConfigType(suinsPackageId: string): string {\n\treturn `${suinsPackageId}::pricing_config::PricingConfig`;\n}\n\nexport function getRenewalPricelistConfigType(suinsPackageId: string): string {\n\treturn `${suinsPackageId}::pricing_config::RenewalConfig`;\n}\n\nexport function getCoinDiscountConfigType(paymentPackageId: string): string {\n\treturn `${paymentPackageId}::payments::PaymentsConfig`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.vector(bcs.U8).transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = await pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumInputShape<\n\t\tMerge<{\n\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t}>\n\t>,\n\tEnumOutputShape<\n\t\tMerge<{\n\t\t\t[K in keyof T]: InferOutput<T[K]>;\n\t\t}>\n\t>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform((value) => ({\n\t\t\t...value,\n\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t})),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof Argument>\n\t| ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof Argument>[],\n\t\taddress: InferInput<typeof Argument>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(Argument, o)),\n\t\t\t\taddress: parse(Argument, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof Argument>,\n\t\tamounts: InferInput<typeof Argument>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(Argument, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof Argument>,\n\t\tsources: InferInput<typeof Argument>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(Argument, destination),\n\t\t\t\tsources: sources.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof Argument>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(Argument, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof Argument>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value) ? value.map((o) => parse(Argument, o)) : parse(Argument, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionData, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, SuiAddress } from './internal.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tMerge<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { SuiClient } from '../client/client.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tawait normalizeInputs(transactionData, options);\n\tawait resolveObjectReferences(transactionData, options);\n\n\tif (!options.onlyTransactionKind) {\n\t\tawait setGasPrice(transactionData, options);\n\t\tawait setGasBudget(transactionData, options);\n\t\tawait setGasPayment(transactionData, options);\n\t}\n\tawait validate(transactionData);\n\treturn await next();\n}\n\nasync function setGasPrice(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await getClient(options).dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await getClient(options).getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tgetClient(options).multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) => input?.UnresolvedPure || input?.UnresolvedObject,\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\n\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t// This should only happen when transaction data was hydrated from an old version of the SDK\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tconst client = getClient(options);\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n\nexport function getClient(options: BuildTransactionOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = () => object('0x5');\n\tobject.clock = () => object('0x6');\n\tobject.random = () => object('0x8');\n\tobject.denyList = () => object('0x403');\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<T extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<T> : T,\n\t\tvalue: ShapeFromPureTypeName<T>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command) => Argument) {\n\t\tfor (const command of this.commands) {\n\t\t\tswitch (command.$kind) {\n\t\t\t\tcase 'MoveCall':\n\t\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TransferObjects':\n\t\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tfn(arg, command),\n\t\t\t\t\t);\n\t\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SplitCoins':\n\t\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n\t\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'MergeCoins':\n\t\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n\t\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tfn(arg, command),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Upgrade':\n\t\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$Intent':\n\t\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t\t? value.map((arg) => fn(arg, command))\n\t\t\t\t\t\t\t: fn(value, command);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Publish':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t\t}\n\t\t}\n\t}\n\n\treplaceCommand(index: number, replacement: Command | Command[]) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\t\tthis.commands.splice(index, 1, ...replacement);\n\n\t\tif (sizeDiff !== 0) {\n\t\t\tthis.mapArguments((arg) => {\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionData, this);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(Argument, value);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number, length = Infinity): TransactionResult {\n\tconst baseResult = { $kind: 'Result' as const, Result: index };\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tNestedResult: [index, resultIndex],\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch (e) {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#data.addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#data.addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(value(this));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#data.addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction */\n\tadd<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n\t\tif (typeof command === 'function') {\n\t\t\treturn command(this);\n\t\t}\n\n\t\tconst index = this.#data.commands.push(command);\n\n\t\treturn createTransactionResult(index - 1) as T;\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\treturn parse(Argument, arg(this));\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tconst index = this.#data.commands.push(command);\n\t\treturn createTransactionResult(index - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\treturn JSON.stringify(\n\t\t\tparse(SerializedTransactionDataV2, this.#data.snapshot()),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature } from './data/internal.js';\nimport type { TransactionPlugin } from './json-rpc-resolver.js';\n\nexport interface ObjectCacheEntry {\n\tobjectId: string;\n\tversion: string;\n\tdigest: string;\n\towner: string | null;\n\tinitialSharedVersion: string | null;\n}\n\nexport interface MoveFunctionCacheEntry {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\tparameters: OpenMoveTypeSignature[];\n}\n\nexport interface CacheEntryTypes {\n\tOwnedObject: ObjectCacheEntry;\n\tSharedOrImmutableObject: ObjectCacheEntry;\n\tMoveFunction: MoveFunctionCacheEntry;\n\tCustom: unknown;\n}\nexport abstract class AsyncCache {\n\tprotected abstract get<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t): Promise<CacheEntryTypes[T] | null>;\n\tprotected abstract set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t): Promise<void>;\n\tprotected abstract delete<T extends keyof CacheEntryTypes>(type: T, key: string): Promise<void>;\n\tabstract clear<T extends keyof CacheEntryTypes>(type?: T): Promise<void>;\n\n\tasync getObject(id: string) {\n\t\tconst [owned, shared] = await Promise.all([\n\t\t\tthis.get('OwnedObject', id),\n\t\t\tthis.get('SharedOrImmutableObject', id),\n\t\t]);\n\n\t\treturn owned ?? shared ?? null;\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn Promise.all([...ids.map((id) => this.getObject(id))]);\n\t}\n\n\tasync addObject(object: ObjectCacheEntry) {\n\t\tif (object.owner) {\n\t\t\tawait this.set('OwnedObject', object.objectId, object);\n\t\t} else {\n\t\t\tawait this.set('SharedOrImmutableObject', object.objectId, object);\n\t\t}\n\n\t\treturn object;\n\t}\n\n\tasync addObjects(objects: ObjectCacheEntry[]) {\n\t\tawait Promise.all(objects.map(async (object) => this.addObject(object)));\n\t}\n\n\tasync deleteObject(id: string) {\n\t\tawait Promise.all([this.delete('OwnedObject', id), this.delete('SharedOrImmutableObject', id)]);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\tawait Promise.all(ids.map((id) => this.deleteObject(id)));\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\treturn this.get('MoveFunction', functionName);\n\t}\n\n\tasync addMoveFunctionDefinition(functionEntry: MoveFunctionCacheEntry) {\n\t\tconst pkg = normalizeSuiAddress(functionEntry.package);\n\t\tconst functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n\t\tconst entry = {\n\t\t\t...functionEntry,\n\t\t\tpackage: pkg,\n\t\t};\n\n\t\tawait this.set('MoveFunction', functionName, entry);\n\n\t\treturn entry;\n\t}\n\n\tasync deleteMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\tawait this.delete('MoveFunction', functionName);\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.get('Custom', key) as Promise<T | null>;\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.set('Custom', key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.delete('Custom', key);\n\t}\n}\n\nexport class InMemoryCache extends AsyncCache {\n\t#caches = {\n\t\tOwnedObject: new Map<string, ObjectCacheEntry>(),\n\t\tSharedOrImmutableObject: new Map<string, ObjectCacheEntry>(),\n\t\tMoveFunction: new Map<string, MoveFunctionCacheEntry>(),\n\t\tCustom: new Map<string, unknown>(),\n\t};\n\n\tprotected async get<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\treturn (this.#caches[type].get(key) as CacheEntryTypes[T]) ?? null;\n\t}\n\n\tprotected async set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t) {\n\t\t(this.#caches[type] as Map<string, typeof value>).set(key, value as never);\n\t}\n\n\tprotected async delete<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\tthis.#caches[type].delete(key);\n\t}\n\n\tasync clear<T extends keyof CacheEntryTypes>(type?: T) {\n\t\tif (type) {\n\t\t\tthis.#caches[type].clear();\n\t\t} else {\n\t\t\tfor (const cache of Object.values(this.#caches)) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface ObjectCacheOptions {\n\tcache?: AsyncCache;\n\tonEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n}\n\nexport class ObjectCache {\n\t#cache: AsyncCache;\n\t#onEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n\n\tconstructor({ cache = new InMemoryCache(), onEffects }: ObjectCacheOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#onEffects = onEffects;\n\t}\n\n\tasPlugin(): TransactionPlugin {\n\t\treturn async (transactionData, _options, next) => {\n\t\t\tconst unresolvedObjects = transactionData.inputs\n\t\t\t\t.filter((input) => input.UnresolvedObject)\n\t\t\t\t.map((input) => input.UnresolvedObject!.objectId);\n\n\t\t\tconst cached = (await this.#cache.getObjects(unresolvedObjects)).filter(\n\t\t\t\t(obj) => obj !== null,\n\t\t\t);\n\n\t\t\tconst byId = new Map(cached.map((obj) => [obj!.objectId, obj]));\n\n\t\t\tfor (const input of transactionData.inputs) {\n\t\t\t\tif (!input.UnresolvedObject) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst cached = byId.get(input.UnresolvedObject.objectId);\n\n\t\t\t\tif (!cached) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cached.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion = cached.initialSharedVersion;\n\t\t\t\t} else {\n\t\t\t\t\tif (cached.version && !input.UnresolvedObject.version) {\n\t\t\t\t\t\tinput.UnresolvedObject.version = cached.version;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cached.digest && !input.UnresolvedObject.digest) {\n\t\t\t\t\t\tinput.UnresolvedObject.digest = cached.digest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall) {\n\t\t\t\t\t\tconst def = await this.getMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (def) {\n\t\t\t\t\t\t\tcommands.MoveCall._argumentTypes = def.parameters;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tawait next();\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall?._argumentTypes) {\n\t\t\t\t\t\tawait this.#cache.addMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t\tparameters: commands.MoveCall._argumentTypes,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync clear() {\n\t\tawait this.#cache.clear();\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\treturn this.#cache.getMoveFunctionDefinition(ref);\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn this.#cache.getObjects(ids);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\treturn this.#cache.deleteObjects(ids);\n\t}\n\n\tasync clearOwnedObjects() {\n\t\tawait this.#cache.clear('OwnedObject');\n\t}\n\n\tasync clearCustom() {\n\t\tawait this.#cache.clear('Custom');\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.#cache.getCustom<T>(key);\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.#cache.setCustom(key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.#cache.deleteCustom(key);\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tif (!effects.V2) {\n\t\t\tthrow new Error(`Unsupported transaction effects version ${effects.$kind}`);\n\t\t}\n\n\t\tconst { lamportVersion, changedObjects } = effects.V2;\n\n\t\tconst deletedIds: string[] = [];\n\t\tconst addedObjects: ObjectCacheEntry[] = [];\n\n\t\tchangedObjects.forEach(([id, change]) => {\n\t\t\tif (change.outputState.NotExist) {\n\t\t\t\tdeletedIds.push(id);\n\t\t\t} else if (change.outputState.ObjectWrite) {\n\t\t\t\tconst [digest, owner] = change.outputState.ObjectWrite;\n\n\t\t\t\taddedObjects.push({\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion: lamportVersion,\n\t\t\t\t\towner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n\t\t\t\t\tinitialSharedVersion: owner.Shared?.initialSharedVersion ?? null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([\n\t\t\tthis.#cache.addObjects(addedObjects),\n\t\t\tthis.#cache.deleteObjects(deletedIds),\n\t\t\tthis.#onEffects?.(effects),\n\t\t]);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport type { ExecuteTransactionBlockParams, SuiClient } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { ObjectCache } from '../ObjectCache.js';\nimport type { Transaction } from '../Transaction.js';\nimport { isTransaction } from '../Transaction.js';\n\nexport class CachingTransactionExecutor {\n\t#client: SuiClient;\n\t#lastDigest: string | null = null;\n\tcache: ObjectCache;\n\n\tconstructor({\n\t\tclient,\n\t\t...options\n\t}: ObjectCacheOptions & {\n\t\tclient: SuiClient;\n\t}) {\n\t\tthis.#client = client;\n\t\tthis.cache = new ObjectCache(options);\n\t}\n\n\t/**\n\t * Clears all Owned objects\n\t * Immutable objects, Shared objects, and Move function definitions will be preserved\n\t */\n\tasync reset() {\n\t\tawait Promise.all([\n\t\t\tthis.cache.clearOwnedObjects(),\n\t\t\tthis.cache.clearCustom(),\n\t\t\tthis.waitForLastTransaction(),\n\t\t]);\n\t}\n\n\tasync buildTransaction({\n\t\ttransaction,\n\t\t...options\n\t}: { transaction: Transaction } & BuildTransactionOptions) {\n\t\ttransaction.addBuildPlugin(this.cache.asPlugin());\n\t\treturn transaction.build({\n\t\t\tclient: this.#client,\n\t\t\t...options,\n\t\t});\n\t}\n\n\tasync executeTransaction({\n\t\ttransaction,\n\t\toptions,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction | Uint8Array;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock'>) {\n\t\tconst bytes = isTransaction(transaction)\n\t\t\t? await this.buildTransaction({ transaction })\n\t\t\t: transaction;\n\n\t\tconst results = await this.#client.executeTransactionBlock({\n\t\t\t...input,\n\t\t\ttransactionBlock: bytes,\n\t\t\toptions: {\n\t\t\t\t...options,\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tif (results.rawEffects) {\n\t\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n\t\t\tawait this.applyEffects(effects);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\toptions,\n\t\ttransaction,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction;\n\n\t\tsigner: Signer;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock' | 'signature'>) {\n\t\ttransaction.setSenderIfNotSet(input.signer.toSuiAddress());\n\t\tconst bytes = await this.buildTransaction({ transaction });\n\t\tconst { signature } = await input.signer.signTransaction(bytes);\n\t\tconst results = await this.executeTransaction({\n\t\t\ttransaction: bytes,\n\t\t\tsignature,\n\t\t\toptions,\n\t\t});\n\n\t\treturn results;\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tthis.#lastDigest = effects.V2?.transactionDigest ?? null;\n\t\tawait this.cache.applyEffects(effects);\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tif (this.#lastDigest) {\n\t\t\tawait this.#client.waitForTransaction({ digest: this.#lastDigest });\n\t\t\tthis.#lastDigest = null;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SerialQueue {\n\t#queue: Array<() => void> = [];\n\n\tasync runTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.#queue.push(() => {\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tthis.#queue.shift();\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue[0]();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t});\n\n\t\t\tif (this.#queue.length === 1) {\n\t\t\t\tthis.#queue[0]();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class ParallelQueue {\n\t#queue: Array<() => void> = [];\n\tactiveTasks = 0;\n\tmaxTasks: number;\n\n\tconstructor(maxTasks: number) {\n\t\tthis.maxTasks = maxTasks;\n\t}\n\n\trunTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\tif (this.activeTasks < this.maxTasks) {\n\t\t\t\tthis.activeTasks++;\n\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tthis.#queue.push(() => {\n\t\t\t\t\ttask()\n\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(resolve, reject);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { bcs } from '../../bcs/index.js';\nimport type { SuiClient, SuiTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nexport class SerialTransactionExecutor {\n\t#queue = new SerialQueue();\n\t#signer: Signer;\n\t#cache: CachingTransactionExecutor;\n\t#defaultGasBudget: bigint;\n\n\tconstructor({\n\t\tsigner,\n\t\tdefaultGasBudget = 50_000_000n,\n\t\t...options\n\t}: Omit<ObjectCacheOptions, 'address'> & {\n\t\tclient: SuiClient;\n\t\tsigner: Signer;\n\t\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `50_000_000n` */\n\t\tdefaultGasBudget?: bigint;\n\t}) {\n\t\tthis.#signer = signer;\n\t\tthis.#defaultGasBudget = defaultGasBudget;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t\tonEffects: (effects) => this.#cacheGasCoin(effects),\n\t\t});\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\treturn this.#cache.applyEffects(effects);\n\t}\n\n\t#cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n\t\tif (!effects.V2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasCoin = getGasCoinFromEffects(effects).ref;\n\t\tif (gasCoin) {\n\t\t\tthis.#cache.cache.setCustom('gasCoin', gasCoin);\n\t\t} else {\n\t\t\tthis.#cache.cache.deleteCustom('gasCoin');\n\t\t}\n\t};\n\n\tasync buildTransaction(transaction: Transaction) {\n\t\treturn this.#queue.runTask(() => this.#buildTransaction(transaction));\n\t}\n\n\t#buildTransaction = async (transaction: Transaction) => {\n\t\tconst gasCoin = await this.#cache.cache.getCustom<{\n\t\t\tobjectId: string;\n\t\t\tversion: string;\n\t\t\tdigest: string;\n\t\t}>('gasCoin');\n\n\t\tconst copy = Transaction.from(transaction);\n\t\tif (gasCoin) {\n\t\t\tcopy.setGasPayment([gasCoin]);\n\t\t}\n\n\t\tcopy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\t\tcopy.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\treturn this.#cache.buildTransaction({ transaction: copy });\n\t};\n\n\tresetCache() {\n\t\treturn this.#cache.reset();\n\t}\n\n\twaitForLastTransaction() {\n\t\treturn this.#cache.waitForLastTransaction();\n\t}\n\n\texecuteTransaction(\n\t\ttransaction: Transaction | Uint8Array,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t) {\n\t\treturn this.#queue.runTask(async () => {\n\t\t\tconst bytes = isTransaction(transaction)\n\t\t\t\t? await this.#buildTransaction(transaction)\n\t\t\t\t: transaction;\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\t\t\tconst results = await this.#cache\n\t\t\t\t.executeTransaction({\n\t\t\t\t\tsignature,\n\t\t\t\t\ttransaction: bytes,\n\t\t\t\t\toptions,\n\t\t\t\t})\n\t\t\t\t.catch(async (error) => {\n\t\t\t\t\tawait this.resetCache();\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t});\n\t}\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\tif (!effects.V2) {\n\t\tthrow new Error('Unexpected effects version');\n\t}\n\n\tconst gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex!];\n\n\tif (!gasObjectChange) {\n\t\tthrow new Error('Gas object not found in effects');\n\t}\n\n\tconst [objectId, { outputState }] = gasObjectChange;\n\n\tif (!outputState.ObjectWrite) {\n\t\tthrow new Error('Unexpected gas object state');\n\t}\n\n\tconst [digest, owner] = outputState.ObjectWrite;\n\n\treturn {\n\t\tref: {\n\t\t\tobjectId,\n\t\t\tdigest,\n\t\t\tversion: effects.V2.lamportVersion,\n\t\t},\n\t\towner: owner.AddressOwner || owner.ObjectOwner!,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { SuiObjectRef } from '../../bcs/types.js';\nimport type {\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n\tcoinBatchSize: 20,\n\tinitialCoinBalance: 200_000_000n,\n\tminimumCoinBalance: 50_000_000n,\n\tmaxPoolSize: 50,\n\tepochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: SuiClient;\n\tsigner: Signer;\n\t/** The number of coins to create in a batch when refilling the gas pool */\n\tcoinBatchSize?: number;\n\t/** The initial balance of each coin created for the gas pool */\n\tinitialCoinBalance?: bigint;\n\t/** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n\tminimumCoinBalance?: bigint;\n\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n\tdefaultGasBudget?: bigint;\n\t/**\n\t * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n\t * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n\t * gas price is up-to-date for the next epoch.\n\t * */\n\tepochBoundaryWindow?: number;\n\t/** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n\tmaxPoolSize?: number;\n\t/** An initial list of coins used to fund the gas pool, uses all owned SUI coins by default */\n\tsourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n\tid: string;\n\tversion: string;\n\tdigest: string;\n\tbalance: bigint;\n}\nexport class ParallelTransactionExecutor {\n\t#signer: Signer;\n\t#client: SuiClient;\n\t#coinBatchSize: number;\n\t#initialCoinBalance: bigint;\n\t#minimumCoinBalance: bigint;\n\t#epochBoundaryWindow: number;\n\t#defaultGasBudget: bigint;\n\t#maxPoolSize: number;\n\t#sourceCoins: Map<string, SuiObjectRef | null> | null;\n\t#coinPool: CoinWithBalance[] = [];\n\t#cache: CachingTransactionExecutor;\n\t#objectIdQueues = new Map<string, (() => void)[]>();\n\t#buildQueue = new SerialQueue();\n\t#executeQueue: ParallelQueue;\n\t#lastDigest: string | null = null;\n\t#cacheLock: Promise<void> | null = null;\n\t#pendingTransactions = 0;\n\t#gasPrice: null | {\n\t\tprice: bigint;\n\t\texpiration: number;\n\t} = null;\n\n\tconstructor(options: ParallelTransactionExecutorOptions) {\n\t\tthis.#signer = options.signer;\n\t\tthis.#client = options.client;\n\t\tthis.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n\t\tthis.#initialCoinBalance =\n\t\t\toptions.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n\t\tthis.#minimumCoinBalance =\n\t\t\toptions.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n\t\tthis.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n\t\tthis.#epochBoundaryWindow =\n\t\t\toptions.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n\t\tthis.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t});\n\t\tthis.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n\t\tthis.#sourceCoins = options.sourceCoins\n\t\t\t? new Map(options.sourceCoins.map((id) => [id, null]))\n\t\t\t: null;\n\t}\n\n\tresetCache() {\n\t\tthis.#gasPrice = null;\n\t\treturn this.#updateCache(() => this.#cache.reset());\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tawait this.#updateCache(() => this.#waitForLastDigest());\n\t}\n\n\tasync executeTransaction(transaction: Transaction, options?: SuiTransactionBlockResponseOptions) {\n\t\tconst { promise, resolve, reject } = promiseWithResolvers<{\n\t\t\tdigest: string;\n\t\t\teffects: string;\n\t\t\tdata: SuiTransactionBlockResponse;\n\t\t}>();\n\t\tconst usedObjects = await this.#getUsedObjects(transaction);\n\n\t\tconst execute = () => {\n\t\t\tthis.#executeQueue.runTask(() => {\n\t\t\t\tconst promise = this.#execute(transaction, usedObjects, options);\n\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t});\n\t\t};\n\n\t\tconst conflicts = new Set<string>();\n\n\t\tusedObjects.forEach((objectId) => {\n\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\tif (queue) {\n\t\t\t\tconflicts.add(objectId);\n\t\t\t\tthis.#objectIdQueues.get(objectId)!.push(() => {\n\t\t\t\t\tconflicts.delete(objectId);\n\t\t\t\t\tif (conflicts.size === 0) {\n\t\t\t\t\t\texecute();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#objectIdQueues.set(objectId, []);\n\t\t\t}\n\t\t});\n\n\t\tif (conflicts.size === 0) {\n\t\t\texecute();\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tasync #getUsedObjects(transaction: Transaction) {\n\t\tconst usedObjects = new Set<string>();\n\t\tlet serialized = false;\n\n\t\ttransaction.addSerializationPlugin(async (blockData, _options, next) => {\n\t\t\tawait next();\n\n\t\t\tif (serialized) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tserialized = true;\n\n\t\t\tblockData.inputs.forEach((input) => {\n\t\t\t\tif (input.Object?.ImmOrOwnedObject?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t\t\t} else if (input.Object?.Receiving?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.Receiving.objectId);\n\t\t\t\t} else if (\n\t\t\t\t\tinput.UnresolvedObject?.objectId &&\n\t\t\t\t\t!input.UnresolvedObject.initialSharedVersion\n\t\t\t\t) {\n\t\t\t\t\tusedObjects.add(input.UnresolvedObject.objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tawait transaction.prepareForSerialization({ client: this.#client });\n\n\t\treturn usedObjects;\n\t}\n\n\tasync #execute(\n\t\ttransaction: Transaction,\n\t\tusedObjects: Set<string>,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t) {\n\t\tlet gasCoin!: CoinWithBalance;\n\t\ttry {\n\t\t\ttransaction.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\t\tawait this.#buildQueue.runTask(async () => {\n\t\t\t\tconst data = transaction.getData();\n\n\t\t\t\tif (!data.gasData.price) {\n\t\t\t\t\ttransaction.setGasPrice(await this.#getGasPrice());\n\t\t\t\t}\n\n\t\t\t\ttransaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n\t\t\t\tawait this.#updateCache();\n\t\t\t\tgasCoin = await this.#getGasCoin();\n\t\t\t\tthis.#pendingTransactions++;\n\t\t\t\ttransaction.setGasPayment([\n\t\t\t\t\t{\n\t\t\t\t\t\tobjectId: gasCoin.id,\n\t\t\t\t\t\tversion: gasCoin.version,\n\t\t\t\t\t\tdigest: gasCoin.digest,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Resolve cached references\n\t\t\t\tawait this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n\t\t\t});\n\n\t\t\tconst bytes = await transaction.build({ client: this.#client });\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\n\t\t\tconst results = await this.#cache.executeTransaction({\n\t\t\t\ttransaction: bytes,\n\t\t\t\tsignature,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\tconst effects = bcs.TransactionEffects.parse(effectsBytes);\n\n\t\t\tconst gasResult = getGasCoinFromEffects(effects);\n\t\t\tconst gasUsed = effects.V2?.gasUsed;\n\n\t\t\tif (gasCoin && gasUsed && gasResult.owner === this.#signer.toSuiAddress()) {\n\t\t\t\tconst totalUsed =\n\t\t\t\t\tBigInt(gasUsed.computationCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) -\n\t\t\t\t\tBigInt(gasUsed.storageRebate);\n\n\t\t\t\tlet usesGasCoin = false;\n\t\t\t\tnew TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n\t\t\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\t\t\tusesGasCoin = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arg;\n\t\t\t\t});\n\n\t\t\t\tif (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n\t\t\t\t\tthis.#coinPool.push({\n\t\t\t\t\t\tid: gasResult.ref.objectId,\n\t\t\t\t\t\tversion: gasResult.ref.version,\n\t\t\t\t\t\tdigest: gasResult.ref.digest,\n\t\t\t\t\t\tbalance: gasCoin.balance - totalUsed,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tthis.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#lastDigest = results.digest;\n\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (gasCoin) {\n\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t}\n\n\t\t\t\tthis.#sourceCoins.set(gasCoin.id, null);\n\t\t\t}\n\n\t\t\tawait this.#updateCache(async () => {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis.#cache.cache.deleteObjects([...usedObjects]),\n\t\t\t\t\tthis.#waitForLastDigest(),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tusedObjects.forEach((objectId) => {\n\t\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\t\tif (queue && queue.length > 0) {\n\t\t\t\t\tqueue.shift()!();\n\t\t\t\t} else if (queue) {\n\t\t\t\t\tthis.#objectIdQueues.delete(objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.#pendingTransactions--;\n\t\t}\n\t}\n\n\t/** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n\tasync #updateCache(fn?: () => Promise<void>) {\n\t\tif (this.#cacheLock) {\n\t\t\tawait this.#cacheLock;\n\t\t}\n\n\t\tthis.#cacheLock =\n\t\t\tfn?.().then(\n\t\t\t\t() => {\n\t\t\t\t\tthis.#cacheLock = null;\n\t\t\t\t},\n\t\t\t\t() => {},\n\t\t\t) ?? null;\n\t}\n\n\tasync #waitForLastDigest() {\n\t\tconst digest = this.#lastDigest;\n\t\tif (digest) {\n\t\t\tthis.#lastDigest = null;\n\t\t\tawait this.#client.waitForTransaction({ digest });\n\t\t}\n\t}\n\n\tasync #getGasCoin() {\n\t\tif (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n\t\t\tawait this.#refillCoinPool();\n\t\t}\n\n\t\tif (this.#coinPool.length === 0) {\n\t\t\tthrow new Error('No coins available');\n\t\t}\n\n\t\tconst coin = this.#coinPool.shift()!;\n\t\treturn coin;\n\t}\n\n\tasync #getGasPrice(): Promise<bigint> {\n\t\tconst remaining = this.#gasPrice\n\t\t\t? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n\t\t\t: 0;\n\n\t\tif (remaining > 0) {\n\t\t\treturn this.#gasPrice!.price;\n\t\t}\n\n\t\tif (this.#gasPrice) {\n\t\t\tconst timeToNextEpoch = Math.max(\n\t\t\t\tthis.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n\t\t\t\t1_000,\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n\t\t}\n\n\t\tconst state = await this.#client.getLatestSuiSystemState();\n\n\t\tthis.#gasPrice = {\n\t\t\tprice: BigInt(state.referenceGasPrice),\n\t\t\texpiration:\n\t\t\t\tNumber.parseInt(state.epochStartTimestampMs, 10) +\n\t\t\t\tNumber.parseInt(state.epochDurationMs, 10),\n\t\t};\n\n\t\treturn this.#getGasPrice();\n\t}\n\n\tasync #refillCoinPool() {\n\t\tconst batchSize = Math.min(\n\t\t\tthis.#coinBatchSize,\n\t\t\tthis.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n\t\t);\n\n\t\tif (batchSize === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst txb = new Transaction();\n\t\tconst address = this.#signer.toSuiAddress();\n\t\ttxb.setSender(address);\n\n\t\tif (this.#sourceCoins) {\n\t\t\tconst refs = [];\n\t\t\tconst ids = [];\n\t\t\tfor (const [id, ref] of this.#sourceCoins) {\n\t\t\t\tif (ref) {\n\t\t\t\t\trefs.push(ref);\n\t\t\t\t} else {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ids.length > 0) {\n\t\t\t\tconst coins = await this.#client.multiGetObjects({\n\t\t\t\t\tids,\n\t\t\t\t});\n\t\t\t\trefs.push(\n\t\t\t\t\t...coins\n\t\t\t\t\t\t.filter((coin): coin is typeof coin & { data: object } => coin.data !== null)\n\t\t\t\t\t\t.map(({ data }) => ({\n\t\t\t\t\t\t\tobjectId: data.objectId,\n\t\t\t\t\t\t\tversion: data.version,\n\t\t\t\t\t\t\tdigest: data.digest,\n\t\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttxb.setGasPayment(refs);\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n\t\tconst results = txb.splitCoins(txb.gas, amounts);\n\t\tconst coinResults = [];\n\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\tcoinResults.push(results[i]);\n\t\t}\n\t\ttxb.transferObjects(coinResults, address);\n\n\t\tawait this.waitForLastTransaction();\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: txb,\n\t\t\tsigner: this.#signer,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n\t\teffects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n\t\t\tif (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.#coinPool.push({\n\t\t\t\tid,\n\t\t\t\tversion: effects.V2!.lamportVersion,\n\t\t\t\tdigest: outputState.ObjectWrite[0],\n\t\t\t\tbalance: BigInt(this.#initialCoinBalance),\n\t\t\t});\n\t\t});\n\n\t\tif (!this.#sourceCoins) {\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst gasObject = getGasCoinFromEffects(effects).ref;\n\t\tthis.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t}\n}\n\nfunction promiseWithResolvers<T>() {\n\tlet resolve: (value: T) => void;\n\tlet reject: (reason: any) => void;\n\n\tconst promise = new Promise<T>((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, SuiClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/sui-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport { getClient } from '../json-rpc-resolver.js';\nimport type { Transaction } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst SUI_TYPE = normalizeStructTag('0x2::sui::SUI');\n\nexport function coinWithBalance({\n\ttype = SUI_TYPE,\n\tbalance,\n\tuseGasCoin = true,\n}: {\n\tbalance: bigint | number;\n\ttype?: string;\n\tuseGasCoin?: boolean;\n}) {\n\treturn (tx: Transaction) => {\n\t\ttx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\tconst coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n\t\treturn tx.add(\n\t\t\tCommands.Intent({\n\t\t\t\tname: COIN_WITH_BALANCE,\n\t\t\t\tinputs: {},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: coinType === SUI_TYPE && useGasCoin ? 'gas' : coinType,\n\t\t\t\t\tbalance: BigInt(balance),\n\t\t\t\t} satisfies InferInput<typeof CoinWithBalanceData>,\n\t\t\t}),\n\t\t);\n\t};\n}\n\nconst CoinWithBalanceData = object({\n\ttype: string(),\n\tbalance: bigint(),\n});\n\nasync function resolveCoinBalance(\n\ttransactionData: TransactionDataBuilder,\n\tbuildOptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst coinTypes = new Set<string>();\n\tconst totalByType = new Map<string, bigint>();\n\n\tif (!transactionData.sender) {\n\t\tthrow new Error('Sender must be set to resolve CoinWithBalance');\n\t}\n\n\tfor (const command of transactionData.commands) {\n\t\tif (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n\t\t\tconst { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n\t\t\tif (type !== 'gas' && balance > 0n) {\n\t\t\t\tcoinTypes.add(type);\n\t\t\t}\n\n\t\t\ttotalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n\t\t}\n\t}\n\tconst usedIds = new Set<string>();\n\n\tfor (const input of transactionData.inputs) {\n\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\tusedIds.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\t\tif (input.UnresolvedObject?.objectId) {\n\t\t\tusedIds.add(input.UnresolvedObject.objectId);\n\t\t}\n\t}\n\n\tconst coinsByType = new Map<string, CoinStruct[]>();\n\tconst client = getClient(buildOptions);\n\tawait Promise.all(\n\t\t[...coinTypes].map(async (coinType) => {\n\t\t\tcoinsByType.set(\n\t\t\t\tcoinType,\n\t\t\t\tawait getCoinsOfType({\n\t\t\t\t\tcoinType,\n\t\t\t\t\tbalance: totalByType.get(coinType)!,\n\t\t\t\t\tclient,\n\t\t\t\t\towner: transactionData.sender!,\n\t\t\t\t\tusedIds,\n\t\t\t\t}),\n\t\t\t);\n\t\t}),\n\t);\n\n\tconst mergedCoins = new Map<string, Argument>();\n\n\tmergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n\tfor (const [index, transaction] of transactionData.commands.entries()) {\n\t\tif (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { type, balance } = transaction.$Intent.data as {\n\t\t\ttype: string;\n\t\t\tbalance: bigint;\n\t\t};\n\n\t\tif (balance === 0n) {\n\t\t\ttransactionData.replaceCommand(\n\t\t\t\tindex,\n\t\t\t\tCommands.MoveCall({ target: '0x2::coin::zero', typeArguments: [type] }),\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst commands = [];\n\n\t\tif (!mergedCoins.has(type)) {\n\t\t\tconst [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n\t\t\t\ttransactionData.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\tInputs.ObjectRef({\n\t\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\t\tversion: coin.version,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tif (rest.length > 0) {\n\t\t\t\tcommands.push(Commands.MergeCoins(first, rest));\n\t\t\t}\n\n\t\t\tmergedCoins.set(type, first);\n\t\t}\n\n\t\tcommands.push(\n\t\t\tCommands.SplitCoins(mergedCoins.get(type)!, [\n\t\t\t\ttransactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n\t\t\t]),\n\t\t);\n\n\t\ttransactionData.replaceCommand(index, commands);\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Result' && arg.Result === index) {\n\t\t\t\treturn {\n\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\tNestedResult: [index + commands.length - 1, 0],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treturn next();\n}\n\nasync function getCoinsOfType({\n\tcoinType,\n\tbalance,\n\tclient,\n\towner,\n\tusedIds,\n}: {\n\tcoinType: string;\n\tbalance: bigint;\n\tclient: SuiClient;\n\towner: string;\n\tusedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n\tlet remainingBalance = balance;\n\tconst coins: CoinStruct[] = [];\n\n\treturn loadMoreCoins();\n\n\tasync function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n\t\tconst { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n\n\t\tconst sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n\t\tfor (const coin of sortedCoins) {\n\t\t\tif (usedIds.has(coin.coinObjectId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst coinBalance = BigInt(coin.balance);\n\n\t\t\tcoins.push(coin);\n\t\t\tremainingBalance -= coinBalance;\n\n\t\t\tif (remainingBalance <= 0) {\n\t\t\t\treturn coins;\n\t\t\t}\n\t\t}\n\n\t\tif (hasNextPage) {\n\t\t\treturn loadMoreCoins(nextCursor);\n\t\t}\n\n\t\tthrow new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\nimport type { Inputs } from './Inputs.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport type { Transaction, TransactionObjectArgument } from './Transaction.js';\n\nexport const Arguments = {\n\tpure: createPure<(tx: Transaction) => Argument>((value) => (tx) => tx.pure(value)) as ReturnType<\n\t\ttypeof createPure<(tx: Transaction) => Argument>\n\t>,\n\tobject: createObjectMethods<TransactionObjectArgument>((value) => (tx) => tx.object(value)),\n\tsharedObjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.sharedObjectRef(...args),\n\tobjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['ObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.objectRef(...args),\n\treceivingRef:\n\t\t(...args: Parameters<(typeof Inputs)['ReceivingRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.receivingRef(...args),\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport axios from 'axios';\nimport type { AxiosInstance } from 'axios';\nimport axiosRetry from 'axios-retry';\n\nexport type HexString = string;\nexport type PriceFeedRequestConfig = {\n\tverbose?: boolean;\n\tbinary?: boolean;\n};\nexport type PriceServiceConnectionConfig = {\n\ttimeout?: number;\n\thttpRetries?: number;\n};\nexport class PriceServiceConnection {\n\tprivate httpClient: AxiosInstance;\n\t/**\n\t * Constructs a new Connection.\n\t *\n\t * @param endpoint endpoint URL to the price service.\n\t * @param config Optional configuration for custom setups.\n\t */\n\tconstructor(endpoint: string, config?: PriceServiceConnectionConfig) {\n\t\tthis.httpClient = axios.create({\n\t\t\tbaseURL: endpoint,\n\t\t\ttimeout: config?.timeout || 5000,\n\t\t});\n\t\taxiosRetry(this.httpClient, {\n\t\t\tretries: config?.httpRetries || 3,\n\t\t\tretryDelay: axiosRetry.exponentialDelay,\n\t\t});\n\t}\n\t/**\n\t * Fetch latest VAAs of given price IDs.\n\t *\n\t * @param priceIds Array of hex-encoded price IDs.\n\t * @returns Array of base64 encoded VAAs.\n\t */\n\tasync getLatestVaas(priceIds: HexString[]): Promise<string[]> {\n\t\tconst response = await this.httpClient.get('/api/latest_vaas', {\n\t\t\tparams: {\n\t\t\t\tids: priceIds,\n\t\t\t},\n\t\t});\n\t\treturn response.data;\n\t}\n}\n", "import isRetryAllowed from 'is-retry-allowed';\n\nexport const namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n\n  return (\n    !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    !CODE_EXCLUDE_LIST.includes(error.code) && // Prevents retrying timed out & cancelled requests\n    isRetryAllowed(error) // Prevents retrying unsafe errors\n  );\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return (\n    error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n  );\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * Set delayFactor 1000 for an exponential delay to occur on the order\n * of seconds\n * @param  {number} [retryNumber=0]\n * @param  {Error}  error - unused; for existing API of retryDelay callback\n * @param  {number} [delayFactor=100] milliseconds\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0, error, delayFactor = 100) {\n  const delay = Math.pow(2, retryNumber) * delayFactor;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/** @type {IAxiosRetryConfig} */\nexport const DEFAULT_OPTIONS = {\n  retries: 3,\n  retryCondition: isNetworkOrIdempotentRequestError,\n  retryDelay: noDelay,\n  shouldResetTimeout: false,\n  onRetry: () => {}\n};\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return { ...DEFAULT_OPTIONS, ...defaultOptions, ...config[namespace] };\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getCurrentState(config, defaultOptions) {\n  const currentState = getRequestOptions(config, defaultOptions);\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Checks retryCondition if request can be retried. Handles it's returning value or Promise.\n * @param  {IAxiosRetryConfigExtended} currentState\n * @param  {Error} error\n * @return {Promise<boolean>}\n */\nasync function shouldRetry(currentState, error) {\n  const { retries, retryCondition } = currentState;\n  const shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);\n\n  // This could be a promise\n  if (typeof shouldRetryOrPromise === 'object') {\n    try {\n      const shouldRetryPromiseResult = await shouldRetryOrPromise;\n      // keep return true unless shouldRetryPromiseResult return false for compatibility\n      return shouldRetryPromiseResult !== false;\n    } catch (_err) {\n      return false;\n    }\n  }\n  return shouldRetryOrPromise;\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n * @param {Function} [defaultOptions.onRetry=()=>{}]\n *        A function to get notified when a retry occurs\n * @return {{ requestInterceptorId: number, responseInterceptorId: number }}\n *        The ids of the interceptors added to the request and to the response (so they can be ejected at a later time)\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  const requestInterceptorId = axios.interceptors.request.use((config) => {\n    const currentState = getCurrentState(config, defaultOptions);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  const responseInterceptorId = axios.interceptors.response.use(null, async (error) => {\n    const { config } = error;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const currentState = getCurrentState(config, defaultOptions);\n\n    if (await shouldRetry(currentState, error)) {\n      currentState.retryCount += 1;\n      const { retryDelay, shouldResetTimeout, onRetry } = currentState;\n      const delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n          return Promise.reject(error);\n        }\n        config.timeout = timeout;\n      }\n\n      config.transformRequest = [(data) => data];\n\n      await onRetry(currentState.retryCount, error, config);\n\n      return new Promise((resolve) => setTimeout(() => resolve(axios(config)), delay));\n    }\n\n    return Promise.reject(error);\n  });\n\n  return { requestInterceptorId, responseInterceptorId };\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Extracts the VAA bytes embedded in an accumulator message.\n *\n * @param accumulatorMessage The accumulator price update message as a Uint8Array.\n * @returns VAA bytes as a Uint8Array.\n */\nexport function extractVaaBytesFromAccumulatorMessage(accumulatorMessage: Uint8Array): Uint8Array {\n\tconst dataView = new DataView(\n\t\taccumulatorMessage.buffer,\n\t\taccumulatorMessage.byteOffset,\n\t\taccumulatorMessage.byteLength,\n\t);\n\n\tconst trailingPayloadSize = dataView.getUint8(6);\n\tconst vaaSizeOffset = 7 + trailingPayloadSize + 1; // Header (7 bytes), trailing payload size, proof type\n\tconst vaaSize = dataView.getUint16(vaaSizeOffset, false); // Read 2 bytes for VAA size (big-endian)\n\tconst vaaOffset = vaaSizeOffset + 2; // VAA size is 2 bytes\n\n\treturn accumulatorMessage.subarray(vaaOffset, vaaOffset + vaaSize);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/sui/bcs';\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { coinWithBalance } from '@mysten/sui/transactions';\nimport { fromBase64, fromHex, parseStructTag } from '@mysten/sui/utils';\n\nimport type { HexString } from './PriceServiceConnection.js';\nimport { PriceServiceConnection } from './PriceServiceConnection.js';\nimport { extractVaaBytesFromAccumulatorMessage } from './pyth-helpers.js';\n\nconst MAX_ARGUMENT_SIZE = 16 * 1024;\nexport type ObjectId = string;\nexport class SuiPriceServiceConnection extends PriceServiceConnection {\n\t/**\n\t * Fetch price feed update data.\n\t *\n\t * @param priceIds Array of hex-encoded price IDs.\n\t * @returns Array of buffers containing the price update data.\n\t */\n\tasync getPriceFeedsUpdateData(priceIds: HexString[]): Promise<Uint8Array[]> {\n\t\tconst latestVaas = await this.getLatestVaas(priceIds);\n\t\treturn latestVaas.map((vaa) => fromBase64(vaa));\n\t}\n}\nexport class SuiPythClient {\n\t#pythPackageId?: Promise<ObjectId>;\n\t#wormholePackageId?: Promise<ObjectId>;\n\t#priceFeedObjectIdCache: Map<HexString, Promise<ObjectId>> = new Map();\n\t#priceTableInfo?: Promise<{ id: ObjectId; fieldType: ObjectId }>;\n\t#baseUpdateFee?: Promise<number>;\n\tprovider: SuiClient;\n\tpythStateId: ObjectId;\n\twormholeStateId: ObjectId;\n\n\tconstructor(provider: SuiClient, pythStateId: ObjectId, wormholeStateId: ObjectId) {\n\t\tthis.provider = provider;\n\t\tthis.pythStateId = pythStateId;\n\t\tthis.wormholeStateId = wormholeStateId;\n\t}\n\t/**\n\t * Verifies the VAAs using the Wormhole contract.\n\t *\n\t * @param vaas Array of VAA buffers to verify.\n\t * @param tx Transaction block to add commands to.\n\t * @returns Array of verified VAAs.\n\t */\n\tasync verifyVaas(vaas: Uint8Array[], tx: Transaction) {\n\t\tconst wormholePackageId = await this.getWormholePackageId();\n\t\tconst verifiedVaas = [];\n\t\tfor (const vaa of vaas) {\n\t\t\tconst [verifiedVaa] = tx.moveCall({\n\t\t\t\ttarget: `${wormholePackageId}::vaa::parse_and_verify`,\n\t\t\t\targuments: [tx.object(this.wormholeStateId), tx.pure.vector('u8', vaa), tx.object.clock()],\n\t\t\t});\n\t\t\tverifiedVaas.push(verifiedVaa);\n\t\t}\n\t\treturn verifiedVaas;\n\t}\n\t/**\n\t * Adds the necessary commands for updating the Pyth price feeds to the transaction block.\n\t *\n\t * @param tx Transaction block to add commands to.\n\t * @param updates Array of price feed updates received from the price service.\n\t * @param feedIds Array of feed IDs to update (in hex format).\n\t */\n\tasync updatePriceFeeds(\n\t\ttx: Transaction,\n\t\tupdates: Uint8Array[],\n\t\tfeedIds: HexString[],\n\t): Promise<ObjectId[]> {\n\t\tconst packageId = await this.getPythPackageId();\n\t\tlet priceUpdatesHotPotato;\n\t\tif (updates.length > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t'SDK does not support sending multiple accumulator messages in a single transaction',\n\t\t\t);\n\t\t}\n\t\tconst vaa = extractVaaBytesFromAccumulatorMessage(updates[0]);\n\t\tconst verifiedVaas = await this.verifyVaas([vaa], tx);\n\t\t[priceUpdatesHotPotato] = tx.moveCall({\n\t\t\ttarget: `${packageId}::pyth::create_authenticated_price_infos_using_accumulator`,\n\t\t\targuments: [\n\t\t\t\ttx.object(this.pythStateId),\n\t\t\t\ttx.pure(\n\t\t\t\t\tbcs\n\t\t\t\t\t\t.vector(bcs.U8)\n\t\t\t\t\t\t.serialize(Array.from(updates[0]), {\n\t\t\t\t\t\t\tmaxSize: MAX_ARGUMENT_SIZE,\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.toBytes(),\n\t\t\t\t),\n\t\t\t\tverifiedVaas[0],\n\t\t\t\ttx.object.clock(),\n\t\t\t],\n\t\t});\n\t\tconst priceInfoObjects: ObjectId[] = [];\n\t\tconst baseUpdateFee = await this.getBaseUpdateFee();\n\t\tfor (const feedId of feedIds) {\n\t\t\tconst priceInfoObjectId = await this.getPriceFeedObjectId(feedId);\n\t\t\tif (!priceInfoObjectId) {\n\t\t\t\tthrow new Error(`Price feed ${feedId} not found, please create it first`);\n\t\t\t}\n\t\t\tpriceInfoObjects.push(priceInfoObjectId);\n\t\t\t[priceUpdatesHotPotato] = tx.moveCall({\n\t\t\t\ttarget: `${packageId}::pyth::update_single_price_feed`,\n\t\t\t\targuments: [\n\t\t\t\t\ttx.object(this.pythStateId),\n\t\t\t\t\tpriceUpdatesHotPotato,\n\t\t\t\t\ttx.object(priceInfoObjectId),\n\t\t\t\t\tcoinWithBalance({ balance: baseUpdateFee }),\n\t\t\t\t\ttx.object.clock(),\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\t\ttx.moveCall({\n\t\t\ttarget: `${packageId}::hot_potato_vector::destroy`,\n\t\t\targuments: [priceUpdatesHotPotato],\n\t\t\ttypeArguments: [`${packageId}::price_info::PriceInfo`],\n\t\t});\n\t\treturn priceInfoObjects;\n\t}\n\t/**\n\t * Get the price feed object ID for a given feed ID, caching the promise.\n\t * @param feedId\n\t */\n\tgetPriceFeedObjectId(feedId: HexString): Promise<ObjectId | undefined> {\n\t\tif (!this.#priceFeedObjectIdCache.has(feedId)) {\n\t\t\tthis.#priceFeedObjectIdCache.set(\n\t\t\t\tfeedId,\n\t\t\t\tthis.#fetchPriceFeedObjectId(feedId).catch((err) => {\n\t\t\t\t\t// Remove failed promises from the cache to allow retries\n\t\t\t\t\tthis.#priceFeedObjectIdCache.delete(feedId);\n\t\t\t\t\tthrow err;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn this.#priceFeedObjectIdCache.get(feedId)!;\n\t}\n\n\t/**\n\t * Fetches the price feed object ID for a given feed ID (no caching).\n\t * Throws an error if the object is not found.\n\t */\n\tasync #fetchPriceFeedObjectId(feedId: HexString): Promise<ObjectId> {\n\t\tconst { id: tableId, fieldType } = await this.getPriceTableInfo();\n\t\tconst result = await this.provider.getDynamicFieldObject({\n\t\t\tparentId: tableId,\n\t\t\tname: {\n\t\t\t\ttype: `${fieldType}::price_identifier::PriceIdentifier`,\n\t\t\t\tvalue: {\n\t\t\t\t\tbytes: Array.from(fromHex(feedId)),\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (!result.data || !result.data.content) {\n\t\t\tthrow new Error(`Price feed object ID for feed ID ${feedId} not found.`);\n\t\t}\n\t\tif (result.data.content.dataType !== 'moveObject') {\n\t\t\tthrow new Error('Price feed type mismatch');\n\t\t}\n\n\t\t// @ts-ignore\n\t\treturn result.data.content.fields.value;\n\t}\n\n\t/**\n\t * Fetches the price table object ID for the current state ID, caching the promise.\n\t * @returns Price table object ID and field type\n\t */\n\tgetPriceTableInfo(): Promise<{ id: ObjectId; fieldType: ObjectId }> {\n\t\tif (!this.#priceTableInfo) {\n\t\t\tconst promise = this.#fetchPriceTableInfo().catch((err) => {\n\t\t\t\t// Clear the cached promise on error\n\t\t\t\tthis.#priceTableInfo = undefined;\n\t\t\t\tthrow err;\n\t\t\t});\n\n\t\t\tthis.#priceTableInfo = promise;\n\t\t}\n\n\t\treturn this.#priceTableInfo;\n\t}\n\n\t/**\n\t * Fetches the price table object ID and field type (no caching).\n\t * @returns Price table object ID and field type\n\t */\n\tasync #fetchPriceTableInfo(): Promise<{ id: ObjectId; fieldType: ObjectId }> {\n\t\tconst result = await this.provider.getDynamicFieldObject({\n\t\t\tparentId: this.pythStateId,\n\t\t\tname: {\n\t\t\t\ttype: 'vector<u8>',\n\t\t\t\tvalue: 'price_info',\n\t\t\t},\n\t\t});\n\n\t\tif (!result.data || !result.data.type) {\n\t\t\tthrow new Error('Price Table not found, contract may not be initialized');\n\t\t}\n\n\t\tconst priceIdentifier = parseStructTag(result.data.type).typeParams[0];\n\t\tif (\n\t\t\ttypeof priceIdentifier === 'object' &&\n\t\t\tpriceIdentifier !== null &&\n\t\t\tpriceIdentifier.name === 'PriceIdentifier' &&\n\t\t\t'address' in priceIdentifier\n\t\t) {\n\t\t\treturn { id: result.data.objectId, fieldType: priceIdentifier.address };\n\t\t} else {\n\t\t\tthrow new Error('fieldType not found');\n\t\t}\n\t}\n\t/**\n\t * Fetches the package ID for the Wormhole contract, with caching.\n\t */\n\tgetWormholePackageId(): Promise<ObjectId> {\n\t\tif (!this.#wormholePackageId) {\n\t\t\tthis.#wormholePackageId = this.#fetchWormholePackageId();\n\t\t}\n\t\treturn this.#wormholePackageId;\n\t}\n\n\t/**\n\t * Fetches the package ID for the Wormhole contract (no caching).\n\t */\n\tasync #fetchWormholePackageId(): Promise<ObjectId> {\n\t\treturn await this.#getPackageId(this.wormholeStateId);\n\t}\n\n\t/**\n\t * Fetches the package ID for the Pyth contract, with caching.\n\t */\n\tgetPythPackageId(): Promise<ObjectId> {\n\t\tif (!this.#pythPackageId) {\n\t\t\tthis.#pythPackageId = this.#fetchPythPackageId();\n\t\t}\n\t\treturn this.#pythPackageId;\n\t}\n\n\t/**\n\t * Fetches the package ID for the Pyth contract (no caching).\n\t */\n\tasync #fetchPythPackageId(): Promise<ObjectId> {\n\t\treturn await this.#getPackageId(this.pythStateId);\n\t}\n\n\t/**\n\t * Fetches the package ID for a given object.\n\t *\n\t * @param objectId Object ID to fetch the package ID for.\n\t */\n\tasync #getPackageId(objectId: ObjectId): Promise<ObjectId> {\n\t\tconst result = await this.provider.getObject({\n\t\t\tid: objectId,\n\t\t\toptions: { showContent: true },\n\t\t});\n\n\t\tif (\n\t\t\tresult.data?.content?.dataType === 'moveObject' &&\n\t\t\t'upgrade_cap' in result.data.content.fields\n\t\t) {\n\t\t\tconst fields = result.data.content.fields as {\n\t\t\t\tupgrade_cap: {\n\t\t\t\t\tfields: {\n\t\t\t\t\t\tpackage: ObjectId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn fields.upgrade_cap.fields.package;\n\t\t}\n\n\t\tthrow new Error(`Cannot fetch package ID for object ${objectId}`);\n\t}\n\t/**\n\t * Gets the base update fee from the Pyth state object.\n\t */\n\tasync #fetchBaseUpdateFee(): Promise<number> {\n\t\tconst result = await this.provider.getObject({\n\t\t\tid: this.pythStateId,\n\t\t\toptions: { showContent: true },\n\t\t});\n\n\t\tif (!result.data || result.data.content?.dataType !== 'moveObject') {\n\t\t\tthrow new Error('Unable to fetch Pyth state object');\n\t\t}\n\n\t\tconst fields = result.data.content.fields as { base_update_fee: number };\n\t\treturn fields.base_update_fee;\n\t}\n\n\t/**\n\t * Returns the cached base update fee, fetching it if necessary.\n\t */\n\tgetBaseUpdateFee(): Promise<number> {\n\t\tif (!this.#baseUpdateFee) {\n\t\t\tthis.#baseUpdateFee = this.#fetchBaseUpdateFee();\n\t\t}\n\t\treturn this.#baseUpdateFee;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { isValidSuiNSName, normalizeSuiNSName } from '@mysten/sui/utils';\n\nimport { mainPackage } from './constants.js';\nimport {\n\tgetCoinDiscountConfigType,\n\tgetConfigType,\n\tgetDomainType,\n\tgetPricelistConfigType,\n\tgetRenewalPricelistConfigType,\n\tisSubName,\n\tvalidateYears,\n} from './helpers.js';\nimport { SuiPriceServiceConnection, SuiPythClient } from './pyth/pyth.js';\nimport type {\n\tCoinTypeDiscount,\n\tNameRecord,\n\tNetwork,\n\tPackageInfo,\n\tSuinsClientConfig,\n\tSuinsPriceList,\n} from './types.js';\n\n/// The SuinsClient is the main entry point for the Suins SDK.\n/// It allows you to interact with SuiNS.\nexport class SuinsClient {\n\tclient: SuiClient;\n\tnetwork: Network;\n\tconfig: PackageInfo;\n\n\tconstructor(config: SuinsClientConfig) {\n\t\tthis.client = config.client;\n\t\tthis.network = config.network || 'mainnet';\n\n\t\tif (this.network === 'mainnet') {\n\t\t\tthis.config = mainPackage.mainnet;\n\t\t} else if (this.network === 'testnet') {\n\t\t\tthis.config = mainPackage.testnet;\n\t\t} else {\n\t\t\tthrow new Error('Invalid network');\n\t\t}\n\t}\n\n\t/**\n\t * Returns the price list for SuiNS names in the base asset.\n\t */\n\n\t// Format:\n\t// {\n\t// \t[ 3, 3 ] => 500000000,\n\t// \t[ 4, 4 ] => 100000000,\n\t// \t[ 5, 63 ] => 20000000\n\t// }\n\tasync getPriceList(): Promise<SuinsPriceList> {\n\t\tif (!this.config.suins) throw new Error('Suins object ID is not set');\n\t\tif (!this.config.packageId) throw new Error('Price list config not found');\n\n\t\tconst priceList = await this.client.getDynamicFieldObject({\n\t\t\tparentId: this.config.suins,\n\t\t\tname: {\n\t\t\t\ttype: getConfigType(\n\t\t\t\t\tthis.config.packageIdV1,\n\t\t\t\t\tgetPricelistConfigType(this.config.packageIdPricing),\n\t\t\t\t),\n\t\t\t\tvalue: { dummy_field: false },\n\t\t\t},\n\t\t});\n\n\t\t// Ensure the content exists and is a MoveStruct with expected fields\n\t\tif (\n\t\t\t!priceList?.data?.content ||\n\t\t\tpriceList.data.content.dataType !== 'moveObject' ||\n\t\t\t!('fields' in priceList.data.content)\n\t\t) {\n\t\t\tthrow new Error('Price list not found or content is invalid');\n\t\t}\n\n\t\t// Safely extract fields\n\t\tconst fields = priceList.data.content.fields as Record<string, any>;\n\t\tif (!fields.value || !fields.value.fields || !fields.value.fields.pricing) {\n\t\t\tthrow new Error('Pricing fields not found in the price list');\n\t\t}\n\n\t\tconst contentArray = fields.value.fields.pricing.fields.contents;\n\t\tconst priceMap = new Map();\n\n\t\tfor (const entry of contentArray) {\n\t\t\tconst keyFields = entry.fields.key.fields;\n\t\t\tconst key = [Number(keyFields.pos0), Number(keyFields.pos1)]; // Convert keys to numbers\n\t\t\tconst value = Number(entry.fields.value); // Convert value to a number\n\n\t\t\tpriceMap.set(key, value);\n\t\t}\n\n\t\treturn priceMap;\n\t}\n\n\t/**\n\t * Returns the renewal price list for SuiNS names in the base asset.\n\t */\n\n\t// Format:\n\t// {\n\t// \t[ 3, 3 ] => 500000000,\n\t// \t[ 4, 4 ] => 100000000,\n\t// \t[ 5, 63 ] => 20000000\n\t// }\n\tasync getRenewalPriceList(): Promise<SuinsPriceList> {\n\t\tif (!this.config.suins) throw new Error('Suins object ID is not set');\n\t\tif (!this.config.packageId) throw new Error('Price list config not found');\n\n\t\tconst priceList = await this.client.getDynamicFieldObject({\n\t\t\tparentId: this.config.suins,\n\t\t\tname: {\n\t\t\t\ttype: getConfigType(\n\t\t\t\t\tthis.config.packageIdV1,\n\t\t\t\t\tgetRenewalPricelistConfigType(this.config.packageIdPricing),\n\t\t\t\t),\n\t\t\t\tvalue: { dummy_field: false },\n\t\t\t},\n\t\t});\n\n\t\tif (\n\t\t\t!priceList ||\n\t\t\t!priceList.data ||\n\t\t\t!priceList.data.content ||\n\t\t\tpriceList.data.content.dataType !== 'moveObject' ||\n\t\t\t!('fields' in priceList.data.content)\n\t\t) {\n\t\t\tthrow new Error('Price list not found or content structure is invalid');\n\t\t}\n\n\t\t// Safely extract fields\n\t\tconst fields = priceList.data.content.fields as Record<string, any>;\n\t\tif (\n\t\t\t!fields.value ||\n\t\t\t!fields.value.fields ||\n\t\t\t!fields.value.fields.config ||\n\t\t\t!fields.value.fields.config.fields.pricing ||\n\t\t\t!fields.value.fields.config.fields.pricing.fields.contents\n\t\t) {\n\t\t\tthrow new Error('Pricing fields not found in the price list');\n\t\t}\n\n\t\tconst contentArray = fields.value.fields.config.fields.pricing.fields.contents;\n\t\tconst priceMap = new Map();\n\n\t\tfor (const entry of contentArray) {\n\t\t\tconst keyFields = entry.fields.key.fields;\n\t\t\tconst key = [Number(keyFields.pos0), Number(keyFields.pos1)]; // Convert keys to numbers\n\t\t\tconst value = Number(entry.fields.value); // Convert value to a number\n\n\t\t\tpriceMap.set(key, value);\n\t\t}\n\n\t\treturn priceMap;\n\t}\n\n\t/**\n\t * Returns the coin discount list for SuiNS names.\n\t */\n\n\t// Format:\n\t// {\n\t// \t'b48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTUSDC::TESTUSDC' => 0,\n\t// \t'0000000000000000000000000000000000000000000000000000000000000002::sui::SUI' => 0,\n\t// \t'b48aac3f53bab328e1eb4c5b3c34f55e760f2fb3f2305ee1a474878d80f650f0::TESTNS::TESTNS' => 25\n\t// }\n\tasync getCoinTypeDiscount(): Promise<CoinTypeDiscount> {\n\t\tif (!this.config.suins) throw new Error('Suins object ID is not set');\n\t\tif (!this.config.packageId) throw new Error('Price list config not found');\n\n\t\tconst dfValue = await this.client.getDynamicFieldObject({\n\t\t\tparentId: this.config.suins,\n\t\t\tname: {\n\t\t\t\ttype: getConfigType(\n\t\t\t\t\tthis.config.packageIdV1,\n\t\t\t\t\tgetCoinDiscountConfigType(this.config.payments.packageId),\n\t\t\t\t),\n\t\t\t\tvalue: { dummy_field: false },\n\t\t\t},\n\t\t});\n\n\t\tif (\n\t\t\t!dfValue ||\n\t\t\t!dfValue.data ||\n\t\t\t!dfValue.data.content ||\n\t\t\tdfValue.data.content.dataType !== 'moveObject' ||\n\t\t\t!('fields' in dfValue.data.content)\n\t\t) {\n\t\t\tthrow new Error('dfValue not found or content structure is invalid');\n\t\t}\n\n\t\t// Safely extract fields\n\t\tconst fields = dfValue.data.content.fields as Record<string, any>;\n\t\tif (\n\t\t\t!fields.value ||\n\t\t\t!fields.value.fields ||\n\t\t\t!fields.value.fields.base_currency ||\n\t\t\t!fields.value.fields.base_currency.fields ||\n\t\t\t!fields.value.fields.base_currency.fields.name ||\n\t\t\t!fields.value.fields.currencies ||\n\t\t\t!fields.value.fields.currencies.fields ||\n\t\t\t!fields.value.fields.currencies.fields.contents\n\t\t) {\n\t\t\tthrow new Error('Required fields are missing in dfValue');\n\t\t}\n\n\t\t// Safely extract content\n\t\tconst content = fields.value.fields;\n\t\tconst currencyDiscounts = content.currencies.fields.contents;\n\t\tconst discountMap = new Map();\n\n\t\tfor (const entry of currencyDiscounts) {\n\t\t\tconst key = entry.fields.key.fields.name;\n\t\t\tconst value = Number(entry.fields.value.fields.discount_percentage);\n\n\t\t\tdiscountMap.set(key, value);\n\t\t}\n\n\t\treturn discountMap;\n\t}\n\n\tasync getNameRecord(name: string): Promise<NameRecord | null> {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tif (!this.config.registryTableId) throw new Error('Suins package ID is not set');\n\n\t\tconst nameRecord = await this.client.getDynamicFieldObject({\n\t\t\tparentId: this.config.registryTableId,\n\t\t\tname: {\n\t\t\t\ttype: getDomainType(this.config.packageIdV1),\n\t\t\t\tvalue: normalizeSuiNSName(name, 'dot').split('.').reverse(),\n\t\t\t},\n\t\t});\n\n\t\tconst fields = nameRecord.data?.content;\n\n\t\t// in case the name record is not found, return null\n\t\tif (nameRecord.error?.code === 'dynamicFieldNotFound') return null;\n\n\t\tif (nameRecord.error || !fields || fields.dataType !== 'moveObject')\n\t\t\tthrow new Error('Name record not found. This domain is not registered.');\n\t\tconst content = fields.fields as Record<string, any>;\n\n\t\tconst data: Record<string, string> = {};\n\t\tcontent.value.fields.data.fields.contents.forEach((item: any) => {\n\t\t\t// @ts-ignore-next-line\n\t\t\tdata[item.fields.key as string] = item.fields.value;\n\t\t});\n\n\t\treturn {\n\t\t\tname,\n\t\t\tnftId: content.value.fields?.nft_id,\n\t\t\ttargetAddress: content.value.fields?.target_address!,\n\t\t\texpirationTimestampMs: content.value.fields?.expiration_timestamp_ms,\n\t\t\tdata,\n\t\t\tavatar: data.avatar,\n\t\t\tcontentHash: data.content_hash,\n\t\t\twalrusSiteId: data.walrus_site_id,\n\t\t};\n\t}\n\n\t/**\n\t * Calculates the registration or renewal price for an SLD (Second Level Domain).\n\t * It expects a domain name, the number of years and a `SuinsPriceList` object,\n\t * as returned from `suinsClient.getPriceList()` function, or `suins.getRenewalPriceList()` function.\n\t *\n\t * It throws an error:\n\t * 1. if the name is a subdomain\n\t * 2. if the name is not a valid SuiNS name\n\t * 3. if the years are not between 1 and 5\n\t */\n\tasync calculatePrice({\n\t\tname,\n\t\tyears,\n\t\tisRegistration = true,\n\t}: {\n\t\tname: string;\n\t\tyears: number;\n\t\tisRegistration?: boolean;\n\t}) {\n\t\tif (!isValidSuiNSName(name)) {\n\t\t\tthrow new Error('Invalid SuiNS name');\n\t\t}\n\t\tvalidateYears(years);\n\n\t\tif (isSubName(name)) {\n\t\t\tthrow new Error('Subdomains do not have a registration fee');\n\t\t}\n\n\t\tconst length = normalizeSuiNSName(name, 'dot').split('.')[0].length;\n\t\tconst priceList = await this.getPriceList();\n\t\tconst renewalPriceList = await this.getRenewalPriceList();\n\t\tlet yearsRemain = years;\n\t\tlet price = 0;\n\n\t\tif (isRegistration) {\n\t\t\tfor (const [[minLength, maxLength], pricePerYear] of priceList.entries()) {\n\t\t\t\tif (length >= minLength && length <= maxLength) {\n\t\t\t\t\tprice += pricePerYear; // Registration is always 1 year\n\t\t\t\t\tyearsRemain -= 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const [[minLength, maxLength], pricePerYear] of renewalPriceList.entries()) {\n\t\t\tif (length >= minLength && length <= maxLength) {\n\t\t\t\tprice += yearsRemain * pricePerYear;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn price;\n\t}\n\n\tasync getPriceInfoObject(tx: Transaction, feed: string) {\n\t\t// Initialize connection to the Sui Price Service\n\t\tconst endpoint =\n\t\t\tthis.network === 'testnet'\n\t\t\t\t? 'https://hermes-beta.pyth.network'\n\t\t\t\t: 'https://hermes.pyth.network';\n\t\tconst connection = new SuiPriceServiceConnection(endpoint);\n\n\t\t// List of price feed IDs\n\t\tconst priceIDs = [\n\t\t\tfeed, // ASSET/USD price ID\n\t\t];\n\n\t\t// Fetch price feed update data\n\t\tconst priceUpdateData = await connection.getPriceFeedsUpdateData(priceIDs);\n\n\t\t// Initialize Sui Client and Pyth Client\n\t\tconst wormholeStateId = this.config.pyth.wormholeStateId;\n\t\tconst pythStateId = this.config.pyth.pythStateId;\n\n\t\tconst client = new SuiPythClient(this.client, pythStateId, wormholeStateId);\n\n\t\treturn await client.updatePriceFeeds(tx, priceUpdateData, priceIDs); // returns priceInfoObjectIds\n\t}\n\n\tasync getObjectType(objectId: string) {\n\t\t// Fetch the object details from the Sui client\n\t\tconst objectResponse = await this.client.getObject({\n\t\t\tid: objectId,\n\t\t\toptions: { showType: true },\n\t\t});\n\n\t\t// Extract and return the type if available\n\t\tif (objectResponse && objectResponse.data && objectResponse.data.type) {\n\t\t\treturn objectResponse.data.type;\n\t\t}\n\n\t\t// Throw an error if the type is not found\n\t\tthrow new Error(`Type information not found for object ID: ${objectId}`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/sui/bcs';\nimport type {\n\tTransaction,\n\tTransactionObjectArgument,\n\tTransactionObjectInput,\n} from '@mysten/sui/transactions';\nimport { isValidSuiNSName, normalizeSuiNSName, SUI_CLOCK_OBJECT_ID } from '@mysten/sui/utils';\n\nimport { ALLOWED_METADATA, MAX_U64 } from './constants.js';\nimport { isNestedSubName, isSubName, zeroCoin } from './helpers.js';\nimport type { SuinsClient } from './suins-client.js';\nimport type { DiscountInfo, ReceiptParams, RegistrationParams, RenewalParams } from './types.js';\n\nexport class SuinsTransaction {\n\tsuinsClient: SuinsClient;\n\ttransaction: Transaction;\n\n\tconstructor(client: SuinsClient, transaction: Transaction) {\n\t\tthis.suinsClient = client;\n\t\tthis.transaction = transaction;\n\t}\n\n\t/**\n\t * Registers a domain for a number of years.\n\t */\n\tregister(params: RegistrationParams): TransactionObjectArgument {\n\t\tif (params.couponCode && params.discountInfo) {\n\t\t\tthrow new Error('Cannot apply both coupon and discount NFT');\n\t\t}\n\n\t\tconst paymentIntent = this.initRegistration(params.domain);\n\t\tif (params.couponCode) {\n\t\t\tthis.applyCoupon(paymentIntent, params.couponCode);\n\t\t}\n\t\tif (params.discountInfo) {\n\t\t\tthis.applyDiscount(paymentIntent, params.discountInfo);\n\t\t}\n\t\tconst priceAfterDiscount = this.calculatePriceAfterDiscount(\n\t\t\tpaymentIntent,\n\t\t\tparams.coinConfig.type,\n\t\t);\n\t\tconst receipt = this.generateReceipt({\n\t\t\tpaymentIntent,\n\t\t\tpriceAfterDiscount,\n\t\t\tcoinConfig: params.coinConfig,\n\t\t\tcoin: params.coin,\n\t\t\tmaxAmount: params.maxAmount,\n\t\t\tpriceInfoObjectId: params.priceInfoObjectId,\n\t\t});\n\t\tconst nft = this.finalizeRegister(receipt);\n\n\t\tif (params.years > 1) {\n\t\t\tthis.renew({\n\t\t\t\tnft,\n\t\t\t\tyears: params.years - 1,\n\t\t\t\tcoinConfig: params.coinConfig,\n\t\t\t\tcoin: params.coin,\n\t\t\t\tcouponCode: params.couponCode,\n\t\t\t\tdiscountInfo: params.discountInfo,\n\t\t\t\tmaxAmount: params.maxAmount,\n\t\t\t\tpriceInfoObjectId: params.priceInfoObjectId,\n\t\t\t});\n\t\t}\n\n\t\treturn nft as TransactionObjectArgument;\n\t}\n\n\t/**\n\t * Renews an NFT for a number of years.\n\t */\n\trenew(params: RenewalParams): void {\n\t\tif (params.couponCode && params.discountInfo) {\n\t\t\tthrow new Error('Cannot apply both coupon and discount NFT');\n\t\t}\n\n\t\tconst paymentIntent = this.initRenewal(params.nft, params.years);\n\t\tif (params.couponCode) {\n\t\t\tthis.applyCoupon(paymentIntent, params.couponCode);\n\t\t}\n\t\tif (params.discountInfo) {\n\t\t\tthis.applyDiscount(paymentIntent, params.discountInfo);\n\t\t}\n\t\tconst priceAfterDiscount = this.calculatePriceAfterDiscount(\n\t\t\tpaymentIntent,\n\t\t\tparams.coinConfig.type,\n\t\t);\n\t\tconst receipt = this.generateReceipt({\n\t\t\tpaymentIntent,\n\t\t\tpriceAfterDiscount,\n\t\t\tcoinConfig: params.coinConfig,\n\t\t\tcoin: params.coin,\n\t\t\tmaxAmount: params.maxAmount,\n\t\t\tpriceInfoObjectId: params.priceInfoObjectId,\n\t\t});\n\t\tthis.finalizeRenew(receipt, params.nft);\n\t}\n\n\tinitRegistration(domain: string): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.packageId}::payment::init_registration`,\n\t\t\targuments: [this.transaction.object(config.suins), this.transaction.pure.string(domain)],\n\t\t});\n\t}\n\n\tinitRenewal(nft: TransactionObjectInput, years: number): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.packageId}::payment::init_renewal`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.pure.u8(years),\n\t\t\t],\n\t\t});\n\t}\n\n\tcalculatePrice(\n\t\tbaseAmount: TransactionObjectArgument,\n\t\tpaymentType: string,\n\t\tpriceInfoObjectId: string,\n\t): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.payments.packageId}::payments::calculate_price`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\tbaseAmount,\n\t\t\t\tthis.transaction.object.clock(),\n\t\t\t\tthis.transaction.object(priceInfoObjectId),\n\t\t\t],\n\t\t\ttypeArguments: [paymentType],\n\t\t});\n\t}\n\n\thandleBasePayment(\n\t\tpaymentIntent: TransactionObjectArgument,\n\t\tpayment: TransactionObjectArgument,\n\t\tpaymentType: string,\n\t): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.payments.packageId}::payments::handle_base_payment`,\n\t\t\targuments: [this.transaction.object(config.suins), paymentIntent, payment],\n\t\t\ttypeArguments: [paymentType],\n\t\t});\n\t}\n\n\thandlePayment(\n\t\tpaymentIntent: TransactionObjectArgument,\n\t\tpayment: TransactionObjectArgument,\n\t\tpaymentType: string,\n\t\tpriceInfoObjectId: string,\n\t\tmaxAmount: bigint = MAX_U64,\n\t): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.payments.packageId}::payments::handle_payment`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\tpaymentIntent,\n\t\t\t\tpayment,\n\t\t\t\tthis.transaction.object.clock(),\n\t\t\t\tthis.transaction.object(priceInfoObjectId),\n\t\t\t\tthis.transaction.pure.u64(maxAmount),\n\t\t\t],\n\t\t\ttypeArguments: [paymentType],\n\t\t});\n\t}\n\n\tfinalizeRegister(receipt: TransactionObjectArgument): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.packageId}::payment::register`,\n\t\t\targuments: [receipt, this.transaction.object(config.suins), this.transaction.object.clock()],\n\t\t});\n\t}\n\n\tfinalizeRenew(\n\t\treceipt: TransactionObjectArgument,\n\t\tnft: TransactionObjectInput,\n\t): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.packageId}::payment::renew`,\n\t\t\targuments: [\n\t\t\t\treceipt,\n\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.object.clock(),\n\t\t\t],\n\t\t});\n\t}\n\n\tcalculatePriceAfterDiscount(\n\t\tpaymentIntent: TransactionObjectArgument,\n\t\tpaymentType: string,\n\t): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.payments.packageId}::payments::calculate_price_after_discount`,\n\t\t\targuments: [this.transaction.object(config.suins), paymentIntent],\n\t\t\ttypeArguments: [paymentType],\n\t\t});\n\t}\n\n\tgenerateReceipt(params: ReceiptParams): TransactionObjectArgument {\n\t\tconst baseAssetPurchase = params.coinConfig.feed === '';\n\t\tif (baseAssetPurchase) {\n\t\t\tconst payment = params.coin\n\t\t\t\t? this.transaction.splitCoins(this.transaction.object(params.coin), [\n\t\t\t\t\t\tparams.priceAfterDiscount,\n\t\t\t\t\t])\n\t\t\t\t: zeroCoin(this.transaction, params.coinConfig.type);\n\t\t\tconst receipt = this.handleBasePayment(params.paymentIntent, payment, params.coinConfig.type);\n\t\t\treturn receipt;\n\t\t} else {\n\t\t\tconst priceInfoObjectId = params.priceInfoObjectId;\n\t\t\tif (!priceInfoObjectId)\n\t\t\t\tthrow new Error('Price info object ID is required for non-base asset purchases');\n\t\t\tconst price = this.calculatePrice(\n\t\t\t\tparams.priceAfterDiscount,\n\t\t\t\tparams.coinConfig.type,\n\t\t\t\tpriceInfoObjectId,\n\t\t\t);\n\t\t\tif (!params.coin) throw new Error('coin input is required');\n\t\t\tconst payment = this.transaction.splitCoins(this.transaction.object(params.coin!), [price]);\n\t\t\tconst receipt = this.handlePayment(\n\t\t\t\tparams.paymentIntent,\n\t\t\t\tpayment,\n\t\t\t\tparams.coinConfig.type,\n\t\t\t\tpriceInfoObjectId,\n\t\t\t\tparams.maxAmount,\n\t\t\t);\n\t\t\treturn receipt;\n\t\t}\n\t}\n\n\t/**\n\t * Applies a coupon to the payment intent.\n\t */\n\tapplyCoupon(intent: TransactionObjectArgument, couponCode: string): TransactionObjectArgument {\n\t\tconst config = this.suinsClient.config;\n\t\treturn this.transaction.moveCall({\n\t\t\ttarget: `${config.coupons.packageId}::coupon_house::apply_coupon`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\tintent,\n\t\t\t\tthis.transaction.pure.string(couponCode),\n\t\t\t\tthis.transaction.object.clock(),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Applies a discount to the payment intent.\n\t */\n\tapplyDiscount(intent: TransactionObjectArgument, discountInfo: DiscountInfo): void {\n\t\tconst config = this.suinsClient.config;\n\n\t\tif (discountInfo.isFreeClaim) {\n\t\t\tthis.transaction.moveCall({\n\t\t\t\ttarget: `${config.discountsPackage.packageId}::free_claims::free_claim`,\n\t\t\t\targuments: [\n\t\t\t\t\tthis.transaction.object(config.discountsPackage.discountHouseId),\n\t\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\t\tintent,\n\t\t\t\t\tthis.transaction.object(discountInfo.discountNft),\n\t\t\t\t],\n\t\t\t\ttypeArguments: [discountInfo.type],\n\t\t\t});\n\t\t} else {\n\t\t\tthis.transaction.moveCall({\n\t\t\t\ttarget: `${config.discountsPackage.packageId}::discounts::apply_percentage_discount`,\n\t\t\t\targuments: [\n\t\t\t\t\tthis.transaction.object(config.discountsPackage.discountHouseId),\n\t\t\t\t\tintent,\n\t\t\t\t\tthis.transaction.object(config.suins),\n\t\t\t\t\tthis.transaction.object(discountInfo.discountNft),\n\t\t\t\t],\n\t\t\t\ttypeArguments: [discountInfo.type],\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Creates a subdomain.\n\t */\n\tcreateSubName({\n\t\tparentNft,\n\t\tname,\n\t\texpirationTimestampMs,\n\t\tallowChildCreation,\n\t\tallowTimeExtension,\n\t}: {\n\t\tparentNft: TransactionObjectInput;\n\t\tname: string;\n\t\texpirationTimestampMs: number;\n\t\tallowChildCreation: boolean;\n\t\tallowTimeExtension: boolean;\n\t}) {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tconst isParentSubdomain = isNestedSubName(name);\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (!this.suinsClient.config.subNamesPackageId)\n\t\t\tthrow new Error('Subnames package ID not found');\n\t\tif (isParentSubdomain && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tconst subNft = this.transaction.moveCall({\n\t\t\ttarget: isParentSubdomain\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::new`\n\t\t\t\t: `${this.suinsClient.config.subNamesPackageId}::subdomains::new`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(parentNft),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t\tthis.transaction.pure.string(normalizeSuiNSName(name, 'dot')),\n\t\t\t\tthis.transaction.pure.u64(expirationTimestampMs),\n\t\t\t\tthis.transaction.pure.bool(!!allowChildCreation),\n\t\t\t\tthis.transaction.pure.bool(!!allowTimeExtension),\n\t\t\t],\n\t\t});\n\n\t\treturn subNft;\n\t}\n\n\t/**\n\t * Builds the PTB to create a leaf subdomain.\n\t * Parent can be a `SuinsRegistration` or a `SubDomainRegistration` object.\n\t * Can be passed in as an ID or a TransactionArgument.\n\t */\n\tcreateLeafSubName({\n\t\tparentNft,\n\t\tname,\n\t\ttargetAddress,\n\t}: {\n\t\tparentNft: TransactionObjectInput;\n\t\tname: string;\n\t\ttargetAddress: string;\n\t}) {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tconst isParentSubdomain = isNestedSubName(name);\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (!this.suinsClient.config.subNamesPackageId)\n\t\t\tthrow new Error('Subnames package ID not found');\n\t\tif (isParentSubdomain && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: isParentSubdomain\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::new_leaf`\n\t\t\t\t: `${this.suinsClient.config.subNamesPackageId}::subdomains::new_leaf`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(parentNft),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t\tthis.transaction.pure.string(normalizeSuiNSName(name, 'dot')),\n\t\t\t\tthis.transaction.pure.address(targetAddress),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Removes a leaf subname.\n\t */\n\tremoveLeafSubName({ parentNft, name }: { parentNft: TransactionObjectInput; name: string }) {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tconst isParentSubdomain = isNestedSubName(name);\n\t\tif (!isSubName(name)) throw new Error('This can only be invoked for subnames');\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (!this.suinsClient.config.subNamesPackageId)\n\t\t\tthrow new Error('Subnames package ID not found');\n\t\tif (isParentSubdomain && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: isParentSubdomain\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::remove_leaf`\n\t\t\t\t: `${this.suinsClient.config.subNamesPackageId}::subdomains::remove_leaf`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(parentNft),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t\tthis.transaction.pure.string(normalizeSuiNSName(name, 'dot')),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Sets the target address of an NFT.\n\t */\n\tsetTargetAddress({\n\t\tnft, // Can be string or argument\n\t\taddress,\n\t\tisSubname,\n\t}: {\n\t\tnft: TransactionObjectInput;\n\t\taddress?: string;\n\t\tisSubname?: boolean;\n\t}) {\n\t\tif (isSubname && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: isSubname\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::set_target_address`\n\t\t\t\t: `${this.suinsClient.config.packageId}::controller::set_target_address`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.pure(bcs.option(bcs.Address).serialize(address).toBytes()),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Sets a default name for the user.\n\t */\n\tsetDefault(name: string) {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: `${this.suinsClient.config.packageId}::controller::set_reverse_lookup`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.pure.string(normalizeSuiNSName(name, 'dot')),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Edits the setup of a subname.\n\t */\n\teditSetup({\n\t\tparentNft,\n\t\tname,\n\t\tallowChildCreation,\n\t\tallowTimeExtension,\n\t}: {\n\t\tparentNft: TransactionObjectInput;\n\t\tname: string;\n\t\tallowChildCreation: boolean;\n\t\tallowTimeExtension: boolean;\n\t}) {\n\t\tif (!isValidSuiNSName(name)) throw new Error('Invalid SuiNS name');\n\t\tconst isParentSubdomain = isNestedSubName(name);\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (!isParentSubdomain && !this.suinsClient.config.subNamesPackageId)\n\t\t\tthrow new Error('Subnames package ID not found');\n\t\tif (isParentSubdomain && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: isParentSubdomain\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::edit_setup`\n\t\t\t\t: `${this.suinsClient.config.subNamesPackageId}::subdomains::edit_setup`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(parentNft),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t\tthis.transaction.pure.string(normalizeSuiNSName(name, 'dot')),\n\t\t\t\tthis.transaction.pure.bool(!!allowChildCreation),\n\t\t\t\tthis.transaction.pure.bool(!!allowTimeExtension),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Extends the expiration of a subname.\n\t */\n\textendExpiration({\n\t\tnft,\n\t\texpirationTimestampMs,\n\t}: {\n\t\tnft: TransactionObjectInput;\n\t\texpirationTimestampMs: number;\n\t}) {\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (!this.suinsClient.config.subNamesPackageId)\n\t\t\tthrow new Error('Subnames package ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: `${this.suinsClient.config.subNamesPackageId}::subdomains::extend_expiration`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.pure.u64(expirationTimestampMs),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Sets the user data of an NFT.\n\t */\n\tsetUserData({\n\t\tnft,\n\t\tvalue,\n\t\tkey,\n\t\tisSubname,\n\t}: {\n\t\tnft: TransactionObjectInput;\n\t\tvalue: string;\n\t\tkey: string;\n\t\tisSubname?: boolean;\n\t}) {\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\t\tif (isSubname && !this.suinsClient.config.tempSubdomainsProxyPackageId)\n\t\t\tthrow new Error('Subnames proxy package ID not found');\n\n\t\tif (!Object.values(ALLOWED_METADATA).some((x) => x === key)) throw new Error('Invalid key');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: isSubname\n\t\t\t\t? `${this.suinsClient.config.tempSubdomainsProxyPackageId}::subdomain_proxy::set_user_data`\n\t\t\t\t: `${this.suinsClient.config.packageId}::controller::set_user_data`,\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.pure.string(key),\n\t\t\t\tthis.transaction.pure.string(value),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Burns an expired NFT to collect storage rebates.\n\t */\n\tburnExpired({ nft, isSubname }: { nft: TransactionObjectInput; isSubname?: boolean }) {\n\t\tif (!this.suinsClient.config.suins) throw new Error('SuiNS Object ID not found');\n\n\t\tthis.transaction.moveCall({\n\t\t\ttarget: `${this.suinsClient.config.packageId}::controller::${\n\t\t\t\tisSubname ? 'burn_expired_subname' : 'burn_expired'\n\t\t\t}`, // Update this\n\t\t\targuments: [\n\t\t\t\tthis.transaction.object(this.suinsClient.config.suins),\n\t\t\t\tthis.transaction.object(nft),\n\t\t\t\tthis.transaction.object(SUI_CLOCK_OBJECT_ID),\n\t\t\t],\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": ["transform", "axios", "require_axios", "ALPHABET", "string", "esm_default", "esm_default", "base64String", "chunk", "bigint", "_BcsType", "options", "validate", "array", "name", "Argument", "GasData", "StructTag", "ProgrammableMoveCall", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "TransactionData", "UpgradePolicy", "Argument", "ObjectRef", "ObjectArg", "NormalizedCallArg", "TransactionExpiration", "TypeTag", "StructTag", "TransactionData", "Argument", "GasData", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "chunk", "object", "inputs", "object", "TransactionData", "_Transaction", "__privateAdd", "Argument", "__privateGet", "__privateSet", "TransactionExpiration", "_queue", "_queue", "_queue", "_cache", "_queue", "_cache", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "__privateGet", "__privateMethod", "__privateSet", "_a", "namespace", "isNetworkError", "error", "CODE_EXCLUDE_LIST", "response", "Boolean", "code", "includes", "isRetryAllowed", "SAFE_HTTP_METHODS", "IDEMPOTENT_HTTP_METHODS", "concat", "isRetryableError", "status", "isSafeRequestError", "config", "indexOf", "method", "isIdempotentRequestError", "isNetworkOrIdempotentRequestError", "noDelay", "exponentialDelay", "retryNumber", "delayFactor", "delay", "Math", "pow", "randomSum", "random", "DEFAULT_OPTIONS", "retries", "retryCondition", "retryDelay", "shouldResetTimeout", "onRetry", "getRequestOptions", "defaultOptions", "getCurrentState", "currentState", "retryCount", "fixConfig", "axios", "defaults", "agent", "httpAgent", "httpsAgent", "shouldRetry", "shouldRetryOrPromise", "shouldRetryPromiseResult", "_err", "requestInterceptorId", "interceptors", "request", "use", "lastRequestTime", "Date", "now", "responseInterceptorId", "Promise", "reject", "timeout", "lastRequestDuration", "transformRequest", "data", "resolve", "setTimeout", "axiosRetry", "axios", "__privateAdd", "__privateGet", "__privateMethod", "__privateSet"]
}
