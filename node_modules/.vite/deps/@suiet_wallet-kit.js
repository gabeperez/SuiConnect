import {
  any,
  array,
  assert,
  bigint,
  boolean,
  create,
  define,
  integer,
  is,
  literal,
  mask,
  nullable,
  number,
  object,
  optional,
  record,
  require_bs58,
  string,
  union,
  unknown
} from "./chunk-AN4T265O.js";
import {
  Hash,
  abytes,
  aexists,
  ahash,
  aoutput,
  blake2b,
  bytesToHex,
  concatBytes,
  createView,
  hexToBytes,
  randomBytes,
  rotr,
  toBytes,
  u64_default,
  wrapConstructor
} from "./chunk-XZ6UPZBL.js";
import {
  require_react_dom
} from "./chunk-YZVM2MHU.js";
import {
  require_jsx_runtime
} from "./chunk-YG5AX2YU.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z2 = 0; z2 < ALPHABET.length; z2++) {
      const x = ALPHABET.charAt(z2);
      ALPHABET_MAP[x] = z2;
    }
    function polymodStep(pre) {
      const b2 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const c = prefix.charCodeAt(i2);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const v = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value2 = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i2 = 0; i2 < data.length; ++i2) {
        value2 = value2 << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value2 >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value2 << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value2 << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i2 = 0; i2 < words.length; ++i2) {
          const x = words[i2];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET.charAt(x);
        }
        for (let i2 = 0; i2 < 6; ++i2) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i2 = 0; i2 < 6; ++i2) {
          const v = chk >> (5 - i2) * 5 & 31;
          result += ALPHABET.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i2 = 0; i2 < wordChars.length; ++i2) {
          const c = wordChars.charAt(i2);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i2 + 6 >= wordChars.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl2) {
      "use strict";
      var gf = function(init) {
        var i2, r = new Float64Array(16);
        if (init) for (i2 = 0; i2 < init.length; i2++) r[i2] = init[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i2, h, l) {
        x[i2] = h >> 24 & 255;
        x[i2 + 1] = h >> 16 & 255;
        x[i2 + 2] = h >> 8 & 255;
        x[i2 + 3] = h & 255;
        x[i2 + 4] = l >> 24 & 255;
        x[i2 + 5] = l >> 16 & 255;
        x[i2 + 6] = l >> 8 & 255;
        x[i2 + 7] = l & 255;
      }
      function vn2(x, xi2, y, yi2, n2) {
        var i2, d = 0;
        for (i2 = 0; i2 < n2; i2++) d |= x[xi2 + i2] ^ y[yi2 + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi2, y, yi2) {
        return vn2(x, xi2, y, yi2, 16);
      }
      function crypto_verify_32(x, xi2, y, yi2) {
        return vn2(x, xi2, y, yi2, 32);
      }
      function core_salsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x2 >>> 0 & 255;
        o2[9] = x2 >>> 8 & 255;
        o2[10] = x2 >>> 16 & 255;
        o2[11] = x2 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b2, n2, k) {
        var z2 = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z2[i2] & 255) | 0;
            z2[i2] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i2 = 0; i2 < b2; i2++) c[cpos + i2] = m[mpos + i2] ^ x[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b2, n2, k) {
        var z2 = new Uint8Array(16), x = new Uint8Array(64);
        var u, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x[i2];
          u = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u = u + (z2[i2] & 255) | 0;
            z2[i2] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i2 = 0; i2 < b2; i2++) c[cpos + i2] = x[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n2, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n2, k, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn2, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n2, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n2, k, sigma);
        var sn2 = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn2[i2] = n2[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn2, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t22, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t22 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t22 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t22, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t22 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t22 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t22 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask2, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g[i2] = this.h[i2] + c;
          c = g[i2] >>> 13;
          g[i2] &= 8191;
        }
        g[9] -= 1 << 13;
        mask2 = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g[i2] &= mask2;
        mask2 = ~mask2;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask2 | g[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n2, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n2);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n2, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n2, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n2, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n2, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n2, k) {
        var i2;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n2, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n2, k);
        for (i2 = 0; i2 < 32; i2++) m[i2] = 0;
        return 0;
      }
      function set25519(r, a3) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a3[i2] | 0;
      }
      function car25519(o2) {
        var i2, v, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v = o2[i2] + c + 65535;
          c = Math.floor(v / 65536);
          o2[i2] = v - c * 65536;
        }
        o2[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q2, b2) {
        var t3, c = ~(b2 - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t3 = c & (p[i2] ^ q2[i2]);
          p[i2] ^= t3;
          q2[i2] ^= t3;
        }
      }
      function pack25519(o2, n2) {
        var i2, j, b2;
        var m = gf(), t3 = gf();
        for (i2 = 0; i2 < 16; i2++) t3[i2] = n2[i2];
        car25519(t3);
        car25519(t3);
        car25519(t3);
        for (j = 0; j < 2; j++) {
          m[0] = t3[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m[i2] = t3[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
            m[i2 - 1] &= 65535;
          }
          m[15] = t3[15] - 32767 - (m[14] >> 16 & 1);
          b2 = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t3, m, 1 - b2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t3[i2] & 255;
          o2[2 * i2 + 1] = t3[i2] >> 8;
        }
      }
      function neq25519(a3, b2) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a3);
        pack25519(d, b2);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a3) {
        var d = new Uint8Array(32);
        pack25519(d, a3);
        return d[0] & 1;
      }
      function unpack25519(o2, n2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A(o2, a3, b2) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a3[i2] + b2[i2];
      }
      function Z(o2, a3, b2) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a3[i2] - b2[i2];
      }
      function M(o2, a3, b2) {
        var v, c, t0 = 0, t1 = 0, t22 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v = a3[0];
        t0 += v * b0;
        t1 += v * b1;
        t22 += v * b22;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a3[1];
        t1 += v * b0;
        t22 += v * b1;
        t3 += v * b22;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a3[2];
        t22 += v * b0;
        t3 += v * b1;
        t4 += v * b22;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a3[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b22;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a3[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b22;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a3[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b22;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a3[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b22;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a3[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b22;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t222 += v * b15;
        v = a3[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b22;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t222 += v * b14;
        t23 += v * b15;
        v = a3[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b22;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t222 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a3[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b22;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t222 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a3[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b22;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t222 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a3[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b22;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t222 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a3[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b22;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t222 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a3[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b22;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t222 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a3[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b22;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t222 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t222;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t22 + c + 65535;
        c = Math.floor(v / 65536);
        t22 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t22 + c + 65535;
        c = Math.floor(v / 65536);
        t22 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t22;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S(o2, a3) {
        M(o2, a3, a3);
      }
      function inv25519(o2, i2) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i2[a3];
        for (a3 = 253; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 2 && a3 !== 4) M(c, c, i2);
        }
        for (a3 = 0; a3 < 16; a3++) o2[a3] = c[a3];
      }
      function pow2523(o2, i2) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i2[a3];
        for (a3 = 250; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 1) M(c, c, i2);
        }
        for (a3 = 0; a3 < 16; a3++) o2[a3] = c[a3];
      }
      function crypto_scalarmult(q2, n2, p) {
        var z2 = new Uint8Array(32);
        var x = new Float64Array(80), r, i2;
        var a3 = gf(), b2 = gf(), c = gf(), d = gf(), e3 = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z2[i2] = n2[i2];
        z2[31] = n2[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x, p);
        for (i2 = 0; i2 < 16; i2++) {
          b2[i2] = x[i2];
          d[i2] = a3[i2] = c[i2] = 0;
        }
        a3[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z2[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a3, b2, r);
          sel25519(c, d, r);
          A(e3, a3, c);
          Z(a3, a3, c);
          A(c, b2, d);
          Z(b2, b2, d);
          S(d, e3);
          S(f, a3);
          M(a3, c, a3);
          M(c, b2, e3);
          A(e3, a3, c);
          Z(a3, a3, c);
          S(b2, a3);
          Z(c, d, f);
          M(a3, c, _121665);
          A(a3, a3, d);
          M(c, c, a3);
          M(a3, d, f);
          M(d, b2, x);
          S(b2, e3);
          sel25519(a3, b2, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x[i2 + 16] = a3[i2];
          x[i2 + 32] = c[i2];
          x[i2 + 48] = b2[i2];
          x[i2 + 64] = d[i2];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n2) {
        return crypto_scalarmult(q2, n2, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n2, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n2, k);
      }
      function crypto_box_open(m, c, d, n2, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n2, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n2) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h, l, a3, b2, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n2 >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i2] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a3 = l & 65535;
            b2 = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i2 * 2];
            l = K[i2 * 2 + 1];
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i2 % 16];
            l = wl[i2 % 16];
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b2 += a3 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a3 & 65535 | b2 << 16;
            h = th;
            l = tl;
            a3 = l & 65535;
            b2 = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b2 += a3 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a3 & 65535 | b2 << 16;
            h = bh3;
            l = bl3;
            a3 = l & 65535;
            b2 = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a3 += l & 65535;
            b2 += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b2 += a3 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a3 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a3 = l & 65535;
                b2 = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a3 += l & 65535;
                b2 += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a3 += l & 65535;
                b2 += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a3 += l & 65535;
                b2 += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b2 += a3 >>> 16;
                c += b2 >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a3 & 65535 | b2 << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a3 & 65535 | b2 << 16;
          h = ah1;
          l = al1;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a3 & 65535 | b2 << 16;
          h = ah2;
          l = al2;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a3 & 65535 | b2 << 16;
          h = ah3;
          l = al3;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a3 & 65535 | b2 << 16;
          h = ah4;
          l = al4;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a3 & 65535 | b2 << 16;
          h = ah5;
          l = al5;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a3 & 65535 | b2 << 16;
          h = ah6;
          l = al6;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a3 & 65535 | b2 << 16;
          h = ah7;
          l = al7;
          a3 = l & 65535;
          b2 = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a3 += l & 65535;
          b2 += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b2 += a3 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a3 & 65535 | b2 << 16;
          pos += 128;
          n2 -= 128;
        }
        return n2;
      }
      function crypto_hash(out, m, n2) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i2, b2 = n2;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n2);
        n2 %= 128;
        for (i2 = 0; i2 < n2; i2++) x[i2] = m[b2 - n2 + i2];
        x[n2] = 128;
        n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
        x[n2 - 9] = 0;
        ts64(x, n2 - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x, n2);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q2) {
        var a3 = gf(), b2 = gf(), c = gf(), d = gf(), e3 = gf(), f = gf(), g = gf(), h = gf(), t3 = gf();
        Z(a3, p[1], p[0]);
        Z(t3, q2[1], q2[0]);
        M(a3, a3, t3);
        A(b2, p[0], p[1]);
        A(t3, q2[0], q2[1]);
        M(b2, b2, t3);
        M(c, p[3], q2[3]);
        M(c, c, D2);
        M(d, p[2], q2[2]);
        A(d, d, d);
        Z(e3, b2, a3);
        Z(f, d, c);
        A(g, d, c);
        A(h, b2, a3);
        M(p[0], e3, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e3, h);
      }
      function cswap(p, q2, b2) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q2[i2], b2);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi2 = gf();
        inv25519(zi2, p[2]);
        M(tx, p[0], zi2);
        M(ty, p[1], zi2);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q2, s) {
        var b2, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b2 = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q2, b2);
          add(q2, p);
          add(p, p);
          cswap(p, q2, b2);
        }
      }
      function scalarbase(p, s) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X);
        set25519(q2[1], Y);
        set25519(q2[2], gf1);
        M(q2[3], X, Y);
        scalarmult(p, q2, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i2] * L2[j - (i2 - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L2[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L2[j];
        for (i2 = 0; i2 < 32; i2++) {
          x[i2 + 1] += x[i2] >> 8;
          r[i2] = x[i2] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n2, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n2 + 64;
        for (i2 = 0; i2 < n2; i2++) sm[64 + i2] = m[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n2 + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h, sm, n2 + 64);
        reduce(h);
        for (i2 = 0; i2 < 64; i2++) x[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x[i2 + j] += h[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t3 = gf(), chk = gf(), num2 = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num2, r[1]);
        M(den, num2, D);
        Z(num2, num2, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t3, den6, num2);
        M(t3, t3, den);
        pow2523(t3, t3);
        M(t3, t3, num2);
        M(t3, t3, den);
        M(t3, t3, den);
        M(r[0], t3, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num2)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num2)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n2, pk) {
        var i2;
        var t3 = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        if (n2 < 64) return -1;
        if (unpackneg(q2, pk)) return -1;
        for (i2 = 0; i2 < n2; i2++) m[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m[i2 + 32] = pk[i2];
        crypto_hash(h, m, n2);
        reduce(h);
        scalarmult(p, q2, h);
        scalarbase(q2, sm.subarray(32));
        add(p, q2);
        pack(t3, p);
        n2 -= 64;
        if (crypto_verify_32(sm, 0, t3, 0)) {
          for (i2 = 0; i2 < n2; i2++) m[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n2; i2++) m[i2] = sm[i2 + 64];
        return n2;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L: L2,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n2) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n2.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl2.randomBytes = function(n2) {
        var b2 = new Uint8Array(n2);
        randombytes(b2, n2);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i2 = 0; i2 < msg.length; i2++) m[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n2, p) {
        checkArrayTypes(n2, p);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n2, p);
        return q2;
      };
      nacl2.scalarMult.base = function(n2) {
        checkArrayTypes(n2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n2);
        return q2;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m.length; i2++) m[i2] = tmp[i2];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn2(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn2) {
        randombytes = fn2;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n2) {
            var i2, v = new Uint8Array(n2);
            for (i2 = 0; i2 < n2; i2 += QUOTA) {
              crypto.getRandomValues(v.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n2; i2++) x[i2] = v[i2];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto = require_crypto();
          if (crypto && crypto.randomBytes) {
            nacl2.setPRNG(function(x, n2) {
              var i2, v = crypto.randomBytes(n2);
              for (i2 = 0; i2 < n2; i2++) x[i2] = v[i2];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/@suiet/wallet-kit/dist/index.js
var W = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/version.js
var PACKAGE_VERSION = "0.54.1";
var TARGETED_RPC_VERSION = "1.25.0";

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/rpc-websocket-client.js
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _setupWebSocket;
var setupWebSocket_fn;
var _reconnect;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd(this, _setupWebSocket);
    __privateAdd(this, _reconnect);
    __privateAdd(this, _requestId, 0);
    __privateAdd(this, _disconnects, 0);
    __privateAdd(this, _webSocket, null);
    __privateAdd(this, _connectionPromise, null);
    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params) {
    const webSocket = await __privateMethod(this, _setupWebSocket, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet(this, _requestId, __privateGet(this, _requestId) + 1);
      __privateGet(this, _pendingRequests).set(__privateGet(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet(this, _pendingRequests).delete(__privateGet(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet(this, _requestId), method, params }));
    }).then(({ error: error2, result }) => {
      if (error2) {
        throw new JsonRpcError(error2.message, error2.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_setupWebSocket = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet(this, _connectionPromise)) {
    return __privateGet(this, _connectionPromise);
  }
  __privateSet(this, _connectionPromise, new Promise((resolve) => {
    var _a2;
    (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
    __privateSet(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet(this, _webSocket).addEventListener("open", () => {
      __privateSet(this, _disconnects, 0);
      resolve(__privateGet(this, _webSocket));
    });
    __privateGet(this, _webSocket).addEventListener("close", () => {
      __privateWrapper(this, _disconnects)._++;
      if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod(this, _reconnect, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error2) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error2 }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet(this, _connectionPromise);
};
_reconnect = /* @__PURE__ */ new WeakSet();
reconnect_fn = async function() {
  var _a2;
  (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
  __privateSet(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null)
      return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/http-transport.js
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet2 = (obj, member, value2, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var _requestId2;
var _options;
var _websocketClient;
var _getWebsocketClient;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd2(this, _getWebsocketClient);
    __privateAdd2(this, _requestId2, 0);
    __privateAdd2(this, _options, void 0);
    __privateAdd2(this, _websocketClient, void 0);
    __privateSet2(this, _options, options);
  }
  fetch(input, init) {
    const fetch2 = __privateGet2(this, _options).fetch ?? globalThis.fetch;
    if (!fetch2) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetch2(input, init);
  }
  async request(input) {
    var _a2, _b;
    __privateSet2(this, _requestId2, __privateGet2(this, _requestId2) + 1);
    const res = await this.fetch(((_a2 = __privateGet2(this, _options).rpc) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        ...(_b = __privateGet2(this, _options).rpc) == null ? void 0 : _b.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet2(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod2(this, _getWebsocketClient, getWebsocketClient_fn).call(this).subscribe(input);
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_getWebsocketClient = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a2;
  if (!__privateGet2(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet2(this, _options).WebSocketConstructor ?? globalThis.WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet2(this, _websocketClient, new WebsocketClient(
      ((_a2 = __privateGet2(this, _options).websocket) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url,
      {
        WebSocketConstructor,
        ...__privateGet2(this, _options).websocket
      }
    ));
  }
  return __privateGet2(this, _websocketClient);
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/b58.js
var import_bs58 = __toESM(require_bs58(), 1);
var toB58 = (buffer) => import_bs58.default.encode(buffer);
var fromB58 = (str) => import_bs58.default.decode(str);

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/b64.js
function fromB64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toB64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i2 = 0; i2 < bytes.length; i2 += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i2, i2 + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/hex.js
function fromHEX(hexStr) {
  var _a2;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
  const intArr = ((_a2 = padded.match(/.{2}/g)) == null ? void 0 : _a2.map((byte) => parseInt(byte, 16))) ?? [];
  return Uint8Array.from(intArr);
}
function toHEX(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num2) {
  let arr = [];
  let len = 0;
  if (num2 === 0) {
    return [0];
  }
  while (num2 > 0) {
    arr[len] = num2 & 127;
    if (num2 >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value2 = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value2;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value2 = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value2;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value2 = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value2;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num2) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value2 = new Uint8Array(this.dataView.buffer, start, num2);
    this.shift(num2);
    return value2;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value: value2, length } = ulebDecode(buffer);
    this.shift(length);
    return value2;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i2 = 0; i2 < length; i2++) {
      result.push(cb(this, i2, length));
    }
    return result;
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toB58(data);
    case "base64":
      return toB64(data);
    case "hex":
      return toHEX(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function decodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return fromB58(data);
    case "base64":
      return fromB64(data);
    case "hex":
      return fromHEX(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str[i2];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({ size = 1024, maxSize, allocateSize = 1024 } = {}) {
    this.bytePosition = 0;
    this.size = size;
    this.maxSize = maxSize || size;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(size));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value2) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value2));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value2) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value2), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value2) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value2), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value2) {
    toLittleEndian(BigInt(value2), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value2) {
    toLittleEndian(BigInt(value2), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value2) {
    toLittleEndian(BigInt(value2), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value2) {
    ulebEncode(value2).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el, i2) => cb(this, el, i2, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i2 = 0; i2 < this.bytePosition; i2++) {
      yield this.dataView.getUint8(i2);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  let result = new Uint8Array(size);
  let i2 = 0;
  while (bigint2 > 0) {
    result[i2] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i2 += 1;
  }
  return result;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet3 = (obj, member, value2, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class {
  constructor(options) {
    __privateAdd3(this, _write, void 0);
    __privateAdd3(this, _serialize, void 0);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet3(this, _write, options.write);
    __privateSet3(this, _serialize, options.serialize ?? ((value2, options2) => {
      const writer = new BcsWriter({ size: this.serializedSize(value2) ?? void 0, ...options2 });
      __privateGet3(this, _write).call(this, value2, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value2, writer) {
    this.validate(value2);
    __privateGet3(this, _write).call(this, value2, writer);
  }
  serialize(value2, options) {
    this.validate(value2);
    return new SerializedBcs(this, __privateGet3(this, _serialize).call(this, value2, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  transform({
    name: name2,
    input,
    output
  }) {
    return new _BcsType({
      name: name2 ?? this.name,
      read: (reader) => output(this.read(reader)),
      write: (value2, writer) => __privateGet3(this, _write).call(this, input(value2), writer),
      serializedSize: (value2) => this.serializedSize(input(value2)),
      serialize: (value2, options) => __privateGet3(this, _serialize).call(this, input(value2), options),
      validate: (value2) => this.validate(input(value2))
    });
  }
};
var BcsType = _BcsType;
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(type2, schema) {
    __privateAdd3(this, _schema, void 0);
    __privateAdd3(this, _bytes, void 0);
    __privateSet3(this, _schema, type2);
    __privateSet3(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet3(this, _bytes);
  }
  toHex() {
    return toHEX(__privateGet3(this, _bytes));
  }
  toBase64() {
    return toB64(__privateGet3(this, _bytes));
  }
  toBase58() {
    return toB58(__privateGet3(this, _bytes));
  }
  parse() {
    return __privateGet3(this, _schema).parse(__privateGet3(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](value2),
    validate: (value2) => {
      var _a2;
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](BigInt(value2)),
    validate: (val) => {
      var _a2;
      const value2 = BigInt(val);
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type2 = new BcsType({
    ...options,
    serialize,
    write: (value2, writer) => {
      for (const byte of type2.serialize(value2).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type2;
}
function stringLikeBcsType({
  toBytes: toBytes2,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex2, writer) => {
      const bytes = toBytes2(hex2);
      writer.writeULEB(bytes.length);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        writer.write8(bytes[i2]);
      }
    },
    serialize: (value2) => {
      const bytes = toBytes2(value2);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value2) => {
      var _a2;
      if (typeof value2 !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value2}. Expected string`);
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value2);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value2) => getType().serializedSize(value2),
    write: (value2, writer) => getType().write(value2, writer),
    serialize: (value2, options) => getType().serialize(value2, options).toBytes()
  });
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value2, writer) => writer.write8(value2 ? 1 : 0),
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value2) => {
        return Uint8Array.from(ulebEncode(value2));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value2, writer) => {
        for (let i2 = 0; i2 < size; i2++) {
          writer.write8(value2[i2] ?? 0);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      name: "string",
      toBytes: (value2) => new TextEncoder().encode(value2),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type2, options) {
    return new BcsType({
      name: `${type2.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i2 = 0; i2 < size; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type2) {
    return bcs.enum(`Option<${type2.name}>`, {
      None: null,
      Some: type2
    }).transform({
      input: (value2) => {
        if (value2 == null) {
          return { None: true };
        }
        return { Some: value2 };
      },
      output: (value2) => {
        if ("Some" in value2) {
          return value2.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type2, options) {
    return new BcsType({
      name: `vector<${type2.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i2 = 0; i2 < length; i2++) {
          result[i2] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        writer.writeULEB(value2.length);
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType({
      name: `(${types.map((t3) => t3.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i2 = 0; i2 < types.length; i2++) {
          const size = types[i2].serializedSize(values[i2]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type2 of types) {
          result.push(type2.read(reader));
        }
        return result;
      },
      write: (value2, writer) => {
        for (let i2 = 0; i2 < types.length; i2++) {
          types[i2].write(value2[i2], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (!Array.isArray(value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name2, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType({
      name: name2,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type2] of canonicalOrder) {
          const size = type2.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type2] of canonicalOrder) {
          result[field] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const [field, type2] of canonicalOrder) {
          type2.write(value2[field], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name2, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType({
      name: name2,
      read: (reader) => {
        const index = reader.readULEB();
        const [name22, type2] = canonicalOrder[index];
        return {
          [name22]: (type2 == null ? void 0 : type2.read(reader)) ?? true
        };
      },
      write: (value2, writer) => {
        const [name22, val] = Object.entries(value2)[0];
        for (let i2 = 0; i2 < canonicalOrder.length; i2++) {
          const [optionName, optionType] = canonicalOrder[i2];
          if (optionName === name22) {
            writer.writeULEB(i2);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value2) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
        const keys = Object.keys(value2);
        if (keys.length !== 1) {
          throw new TypeError(`Expected object with one key, found ${keys.length}`);
        }
        const [name22] = keys;
        if (!Object.hasOwn(values, name22)) {
          throw new TypeError(`Invalid enum variant ${name22}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value2) => {
        return [...value2.entries()];
      },
      output: (value2) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value2) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * @deprecated
   *
   * Generics should be implemented as generic typescript functions instead:
   *
   * ```ts
   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {
   *   return bcs.struct('VecMap<K, V>', {
   *     keys: bcs.vector(K),
   *     values: bcs.vector(V),
   *   })
   * }
   * ```
   */
  generic(_names, cb) {
    return (...types) => {
      return cb(...types).transform({
        name: `${cb.name}<${types.map((t3) => t3.name).join(", ")}>`,
        input: (value2) => value2,
        output: (value2) => value2
      });
    };
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/legacy-registry.js
var SUI_ADDRESS_LENGTH = 32;
var _BCS = class {
  /**
   * Construct a BCS instance with a prepared schema.
   *
   * @param schema A prepared schema with type definitions
   * @param withPrimitives Whether to register primitive types by default
   */
  constructor(schema) {
    this.types = /* @__PURE__ */ new Map();
    this.counter = 0;
    if (schema instanceof _BCS) {
      this.schema = schema.schema;
      this.types = new Map(schema.types);
      return;
    }
    this.schema = schema;
    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);
    this.registerVectorType(schema.vectorType);
    if (schema.types && schema.types.structs) {
      for (let name2 of Object.keys(schema.types.structs)) {
        this.registerStructType(name2, schema.types.structs[name2]);
      }
    }
    if (schema.types && schema.types.enums) {
      for (let name2 of Object.keys(schema.types.enums)) {
        this.registerEnumType(name2, schema.types.enums[name2]);
      }
    }
    if (schema.types && schema.types.aliases) {
      for (let name2 of Object.keys(schema.types.aliases)) {
        this.registerAlias(name2, schema.types.aliases[name2]);
      }
    }
    if (schema.withPrimitives !== false) {
      registerPrimitives(this);
    }
  }
  /**
   * Name of the key to use for temporary struct definitions.
   * Returns a temp key + index (for a case when multiple temp
   * structs are processed).
   */
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  /**
   * Serialize data into bcs.
   *
   * @example
   * bcs.registerVectorType('vector<u8>', 'u8');
   *
   * let serialized = BCS
   *   .set('vector<u8>', [1,2,3,4,5,6])
   *   .toBytes();
   *
   * console.assert(toHex(serialized) === '06010203040506');
   *
   * @param type Name of the type to serialize (must be registered) or a struct type.
   * @param data Data to serialize.
   * @param size Serialization buffer size. Default 1024 = 1KB.
   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
   */
  ser(type2, data, options) {
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name: name2, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name2).encode(this, data, options, params);
    }
    if (typeof type2 === "object") {
      const key = this.tempKey();
      const temp = new _BCS(this);
      return temp.registerStructType(key, type2).ser(key, data, options);
    }
    throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(type2)}`);
  }
  /**
   * Deserialize BCS into a JS type.
   *
   * @example
   * let num = bcs.ser('u64', '4294967295').toString('hex');
   * let deNum = bcs.de('u64', num, 'hex');
   * console.assert(deNum.toString(10) === '4294967295');
   *
   * @param type Name of the type to deserialize (must be registered) or a struct type definition.
   * @param data Data to deserialize.
   * @param encoding Optional - encoding to use if data is of type String
   * @return Deserialized data.
   */
  de(type2, data, encoding) {
    if (typeof data === "string") {
      if (encoding) {
        data = decodeStr(data, encoding);
      } else {
        throw new Error("To pass a string to `bcs.de`, specify encoding");
      }
    }
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name: name2, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name2).decode(this, data, params);
    }
    if (typeof type2 === "object") {
      const temp = new _BCS(this);
      const key = this.tempKey();
      return temp.registerStructType(key, type2).de(key, data, encoding);
    }
    throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(type2)}`);
  }
  /**
   * Check whether a `TypeInterface` has been loaded for a `type`.
   * @param type Name of the type to check.
   * @returns
   */
  hasType(type2) {
    return this.types.has(type2);
  }
  /**
   * Create an alias for a type.
   * WARNING: this can potentially lead to recursion
   * @param name Alias to use
   * @param forType Type to reference
   * @returns
   *
   * @example
   * ```
   * let bcs = new BCS(getSuiMoveConfig());
   * bcs.registerAlias('ObjectDigest', BCS.BASE58);
   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
   * ```
   */
  registerAlias(name2, forType) {
    this.types.set(name2, forType);
    return this;
  }
  /**
   * Method to register new types for BCS internal representation.
   * For each registered type 2 callbacks must be specified and one is optional:
   *
   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
   * - decodeCb(reader) - write a way to deserialize data with BcsReader;
   * - validateCb(data) - validate data - either return bool or throw an error
   *
   * @example
   * // our type would be a string that consists only of numbers
   * bcs.registerType('number_string',
   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
   * );
   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
   *
   * @param name
   * @param encodeCb Callback to encode a value.
   * @param decodeCb Callback to decode a value.
   * @param validateCb Optional validator Callback to check type before serialization.
   */
  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
    const { name: name2, params: generics } = this.parseTypeName(typeName);
    this.types.set(name2, {
      encode(self2, data, options, typeParams) {
        const typeMap = generics.reduce((acc, value2, index) => {
          return Object.assign(acc, { [value2]: typeParams[index] });
        }, {});
        return this._encodeRaw.call(self2, new BcsWriter(options), data, typeParams, typeMap);
      },
      decode(self2, data, typeParams) {
        const typeMap = generics.reduce((acc, value2, index) => {
          return Object.assign(acc, { [value2]: typeParams[index] });
        }, {});
        return this._decodeRaw.call(self2, new BcsReader(data), typeParams, typeMap);
      },
      // these methods should always be used with caution as they require pre-defined
      // reader and writer and mainly exist to allow multi-field (de)serialization;
      _encodeRaw(writer, data, typeParams, typeMap) {
        if (validateCb(data)) {
          return encodeCb.call(this, writer, data, typeParams, typeMap);
        } else {
          throw new Error(`Validation failed for type ${name2}, data: ${data}`);
        }
      },
      _decodeRaw(reader, typeParams, typeMap) {
        return decodeCb.call(this, reader, typeParams, typeMap);
      }
    });
    return this;
  }
  /**
  	 * Method to register BcsType instances to the registry
  	 * Types are registered with a callback that provides BcsType instances for each generic
  	 * passed to the type.
  	 *
  	 * - createType(...generics) - Return a BcsType instance
  	 *
  	 * @example
  	 * // our type would be a string that consists only of numbers
  	 * bcs.registerType('Box<T>', (T) => {
  	 * 		return bcs.struct({
  	 * 			value: T
  	 * 		});
  	 * });
  
  	 * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);
  	 *
  	 * @param name
  	 * @param createType a Callback to create the BcsType with any passed in generics
  	 */
  registerBcsType(typeName, createType) {
    this.registerType(
      typeName,
      (writer, data, typeParams) => {
        const generics = typeParams.map(
          (param) => new BcsType({
            name: String(param),
            write: (data2, writer2) => {
              const { name: name2, params } = this.parseTypeName(param);
              const typeInterface = this.getTypeInterface(name2);
              const typeMap = params.reduce((acc, value2, index) => {
                return Object.assign(acc, { [value2]: typeParams[index] });
              }, {});
              return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);
            },
            read: () => {
              throw new Error("Not implemented");
            }
          })
        );
        createType(...generics).write(data, writer);
        return writer;
      },
      (reader, typeParams) => {
        const generics = typeParams.map(
          (param) => new BcsType({
            name: String(param),
            write: (_data2, _writer) => {
              throw new Error("Not implemented");
            },
            read: (reader2) => {
              const { name: name2, params } = this.parseTypeName(param);
              const typeInterface = this.getTypeInterface(name2);
              const typeMap = params.reduce((acc, value2, index) => {
                return Object.assign(acc, { [value2]: typeParams[index] });
              }, {});
              return typeInterface._decodeRaw.call(this, reader2, params, typeMap);
            }
          })
        );
        return createType(...generics).read(reader);
      }
    );
    return this;
  }
  /**
   * Register an address type which is a sequence of U8s of specified length.
   * @example
   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
   *
   * @param name Name of the address type.
   * @param length Byte length of the address.
   * @param encoding Encoding to use for the address type
   * @returns
   */
  registerAddressType(name2, length, encoding = "hex") {
    switch (encoding) {
      case "base64":
        return this.registerType(
          name2,
          function encodeAddress(writer, data) {
            return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);
          },
          function decodeAddress(reader) {
            return toB64(reader.readBytes(length));
          }
        );
      case "hex":
        return this.registerType(
          name2,
          function encodeAddress(writer, data) {
            return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);
          },
          function decodeAddress(reader) {
            return toHEX(reader.readBytes(length));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  /**
   * Register custom vector type inside the bcs.
   *
   * @example
   * bcs.registerVectorType('vector<T>'); // generic registration
   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
   *
   * @param name Name of the type to register
   * @param elementType Optional name of the inner type of the vector
   * @return Returns self for chaining.
   */
  registerVectorType(typeName) {
    let { name: name2, params } = this.parseTypeName(typeName);
    if (params.length > 1) {
      throw new Error("Vector can have only one type parameter; got " + name2);
    }
    return this.registerType(
      typeName,
      function encodeVector(writer, data, typeParams, typeMap) {
        return writer.writeVec(data, (writer2, el) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);
          }
          let { name: name22, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name22)) {
            return this.getTypeInterface(name22)._encodeRaw.call(this, writer2, el, params2, typeMap);
          }
          if (!(name22 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name22} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name22]);
          return this.getTypeInterface(innerName)._encodeRaw.call(
            this,
            writer2,
            el,
            innerParams,
            typeMap
          );
        });
      },
      function decodeVector(reader, typeParams, typeMap) {
        return reader.readVec((reader2) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);
          }
          let { name: name22, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name22)) {
            return this.getTypeInterface(name22)._decodeRaw.call(this, reader2, params2, typeMap);
          }
          if (!(name22 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name22} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name22]);
          return this.getTypeInterface(innerName)._decodeRaw.call(
            this,
            reader2,
            innerParams,
            typeMap
          );
        });
      }
    );
  }
  /**
   * Safe method to register a custom Move struct. The first argument is a name of the
   * struct which is only used on the FrontEnd and has no affect on serialization results,
   * and the second is a struct description passed as an Object.
   *
   * The description object MUST have the same order on all of the platforms (ie in Move
   * or in Rust).
   *
   * @example
   * // Move / Rust struct
   * // struct Coin {
   * //   value: u64,
   * //   owner: vector<u8>, // name // Vec<u8> in Rust
   * //   is_locked: bool,
   * // }
   *
   * bcs.registerStructType('Coin', {
   *   value: bcs.U64,
   *   owner: bcs.STRING,
   *   is_locked: bcs.BOOL
   * });
   *
   * // Created in Rust with diem/bcs
   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
   *  128, 209, 177,   5,  96,  0,  0,
   *    0,  14,  66, 105, 103, 32, 87,
   *   97, 108, 108, 101, 116, 32, 71,
   *  117, 121,   0
   * ];
   *
   * // Let's encode the value as well
   * let test_set = bcs.ser('Coin', {
   *   owner: 'Big Wallet Guy',
   *   value: '412412400000',
   *   is_locked: false,
   * });
   *
   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
   *
   * @param name Name of the type to register.
   * @param fields Fields of the struct. Must be in the correct order.
   * @return Returns BCS for chaining.
   */
  registerStructType(typeName, fields) {
    for (let key in fields) {
      let internalName = this.tempKey();
      let value2 = fields[key];
      if (!Array.isArray(value2) && typeof value2 !== "string") {
        fields[key] = internalName;
        this.registerStructType(internalName, value2);
      }
    }
    let struct = Object.freeze(fields);
    let canonicalOrder = Object.keys(struct);
    let { name: structName, params: generics } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeStruct(writer, data, typeParams, typeMap) {
        if (!data || data.constructor !== Object) {
          throw new Error(`Expected ${structName} to be an Object, got: ${data}`);
        }
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        for (let key of canonicalOrder) {
          if (!(key in data)) {
            throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);
          }
          const { name: fieldType, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldType)) {
            this.getTypeInterface(fieldType)._encodeRaw.call(
              this,
              writer,
              data[key],
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldType);
            let { name: name2, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name2)) {
              this.getTypeInterface(name2)._encodeRaw.call(
                this,
                writer,
                data[key],
                params,
                typeMap
              );
              continue;
            }
            if (!(name2 in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name2} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);
            this.getTypeInterface(innerName)._encodeRaw.call(
              this,
              writer,
              data[key],
              innerParams,
              typeMap
            );
          }
        }
        return writer;
      },
      function decodeStruct(reader, typeParams, typeMap) {
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        let result = {};
        for (let key of canonicalOrder) {
          const { name: fieldName, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldName)) {
            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(
              this,
              reader,
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldName);
            let { name: name2, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name2)) {
              result[key] = this.getTypeInterface(name2)._decodeRaw.call(
                this,
                reader,
                params,
                typeMap
              );
              continue;
            }
            if (!(name2 in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name2} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);
            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(
              this,
              reader,
              innerParams,
              typeMap
            );
          }
        }
        return result;
      }
    );
  }
  /**
   * Safe method to register custom enum type where each invariant holds the value of another type.
   * @example
   * bcs.registerStructType('Coin', { value: 'u64' });
   * bcs.registerEnumType('MyEnum', {
   *  single: 'Coin',
   *  multi: 'vector<Coin>',
   *  empty: null
   * });
   *
   * console.log(
   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
   * )
   *
   * // and serialization
   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
   *
   * @param name
   * @param variants
   */
  registerEnumType(typeName, variants) {
    for (let key in variants) {
      let internalName = this.tempKey();
      let value2 = variants[key];
      if (value2 !== null && !Array.isArray(value2) && typeof value2 !== "string") {
        variants[key] = internalName;
        this.registerStructType(internalName, value2);
      }
    }
    let struct = Object.freeze(variants);
    let canonicalOrder = Object.keys(struct);
    let { name: name2, params: canonicalTypeParams } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeEnum(writer, data, typeParams, typeMap) {
        if (!data) {
          throw new Error(`Unable to write enum "${name2}", missing data.
Received: "${data}"`);
        }
        if (typeof data !== "object") {
          throw new Error(
            `Incorrect data passed into enum "${name2}", expected object with properties: "${canonicalOrder.join(
              " | "
            )}".
Received: "${JSON.stringify(data)}"`
          );
        }
        let key = Object.keys(data)[0];
        if (key === void 0) {
          throw new Error(`Empty object passed as invariant of the enum "${name2}"`);
        }
        let orderByte = canonicalOrder.indexOf(key);
        if (orderByte === -1) {
          throw new Error(
            `Unknown invariant of the enum "${name2}", allowed values: "${canonicalOrder.join(
              " | "
            )}"; received "${key}"`
          );
        }
        let invariant2 = canonicalOrder[orderByte];
        let invariantType = struct[invariant2];
        writer.write8(orderByte);
        if (invariantType === null) {
          return writer;
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name22, params } = this.parseTypeName(typeOrParam);
          return this.getTypeInterface(name22)._encodeRaw.call(
            this,
            writer,
            data[key],
            params,
            typeMap
          );
        }
      },
      function decodeEnum(reader, typeParams, typeMap) {
        let orderByte = reader.readULEB();
        let invariant2 = canonicalOrder[orderByte];
        let invariantType = struct[invariant2];
        if (orderByte === -1) {
          throw new Error(
            `Decoding type mismatch, expected enum "${name2}" invariant index, received "${orderByte}"`
          );
        }
        if (invariantType === null) {
          return { [invariant2]: true };
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name22, params } = this.parseTypeName(typeOrParam);
          return {
            [invariant2]: this.getTypeInterface(name22)._decodeRaw.call(this, reader, params, typeMap)
          };
        }
      }
    );
  }
  /**
   * Get a set of encoders/decoders for specific type.
   * Mainly used to define custom type de/serialization logic.
   *
   * @param type
   * @returns {TypeInterface}
   */
  getTypeInterface(type2) {
    let typeInterface = this.types.get(type2);
    if (typeof typeInterface === "string") {
      let chain2 = [];
      while (typeof typeInterface === "string") {
        if (chain2.includes(typeInterface)) {
          throw new Error(`Recursive definition found: ${chain2.join(" -> ")} -> ${typeInterface}`);
        }
        chain2.push(typeInterface);
        typeInterface = this.types.get(typeInterface);
      }
    }
    if (typeInterface === void 0) {
      throw new Error(`Type ${type2} is not registered`);
    }
    return typeInterface;
  }
  /**
   * Parse a type name and get the type's generics.
   * @example
   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
   * // typeName: Option
   * // typeParams: [ 'Coin<SUI>' ]
   *
   * @param name Name of the type to process
   * @returns Object with typeName and typeParams listed as Array
   */
  parseTypeName(name2) {
    if (Array.isArray(name2)) {
      let [typeName2, ...params2] = name2;
      return { name: typeName2, params: params2 };
    }
    if (typeof name2 !== "string") {
      throw new Error(`Illegal type passed as a name of the type: ${name2}`);
    }
    let [left, right] = this.schema.genericSeparators || ["<", ">"];
    let l_bound = name2.indexOf(left);
    let r_bound = Array.from(name2).reverse().indexOf(right);
    if (l_bound === -1 && r_bound === -1) {
      return { name: name2, params: [] };
    }
    if (l_bound === -1 || r_bound === -1) {
      throw new Error(`Unclosed generic in name '${name2}'`);
    }
    let typeName = name2.slice(0, l_bound);
    let params = splitGenericParameters(
      name2.slice(l_bound + 1, name2.length - r_bound - 1),
      this.schema.genericSeparators
    );
    return { name: typeName, params };
  }
};
var BCS = _BCS;
BCS.U8 = "u8";
BCS.U16 = "u16";
BCS.U32 = "u32";
BCS.U64 = "u64";
BCS.U128 = "u128";
BCS.U256 = "u256";
BCS.BOOL = "bool";
BCS.VECTOR = "vector";
BCS.ADDRESS = "address";
BCS.STRING = "string";
BCS.HEX = "hex-string";
BCS.BASE58 = "base58-string";
BCS.BASE64 = "base64-string";
function registerPrimitives(bcs2) {
  bcs2.registerType(
    BCS.U8,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8();
    },
    (u8) => u8 < 256
  );
  bcs2.registerType(
    BCS.U16,
    function(writer, data) {
      return writer.write16(data);
    },
    function(reader) {
      return reader.read16();
    },
    (u16) => u16 < 65536
  );
  bcs2.registerType(
    BCS.U32,
    function(writer, data) {
      return writer.write32(data);
    },
    function(reader) {
      return reader.read32();
    },
    (u32) => u32 <= 4294967296n
  );
  bcs2.registerType(
    BCS.U64,
    function(writer, data) {
      return writer.write64(data);
    },
    function(reader) {
      return reader.read64();
    }
  );
  bcs2.registerType(
    BCS.U128,
    function(writer, data) {
      return writer.write128(data);
    },
    function(reader) {
      return reader.read128();
    }
  );
  bcs2.registerType(
    BCS.U256,
    function(writer, data) {
      return writer.write256(data);
    },
    function(reader) {
      return reader.read256();
    }
  );
  bcs2.registerType(
    BCS.BOOL,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8().toString(10) === "1";
    }
  );
  bcs2.registerType(
    BCS.STRING,
    function(writer, data) {
      return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));
    },
    function(reader) {
      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join("");
    },
    (_str) => true
  );
  bcs2.registerType(
    BCS.HEX,
    function(writer, data) {
      return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toHEX(new Uint8Array(bytes));
    }
  );
  bcs2.registerType(
    BCS.BASE58,
    function(writer, data) {
      return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toB58(new Uint8Array(bytes));
    }
  );
  bcs2.registerType(
    BCS.BASE64,
    function(writer, data) {
      return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));
    },
    function(reader) {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return toB64(new Uint8Array(bytes));
    }
  );
}
function getSuiMoveConfig() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: SUI_ADDRESS_LENGTH,
    addressEncoding: "hex"
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value2) {
  try {
    const buffer = fromB58(value2);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e3) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH2 = 32;
function isValidSuiAddress(value2) {
  return isHex(value2) && getHexByteLength(value2) === SUI_ADDRESS_LENGTH2;
}
function isValidSuiObjectId(value2) {
  return isValidSuiAddress(value2);
}
function normalizeSuiAddress(value2, forceAdd0x = false) {
  let address = value2.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH2 * 2, "0")}`;
}
function normalizeSuiObjectId(value2, forceAdd0x = false) {
  return normalizeSuiAddress(value2, forceAdd0x);
}
function isHex(value2) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value2) && value2.length % 2 === 0;
}
function getHexByteLength(value2) {
  return /^(0x|0X)/.test(value2) ? (value2.length - 2) / 2 : value2.length / 2;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/bcs/index.js
var bcsRegistry = new BCS({
  ...getSuiMoveConfig(),
  types: {
    enums: {
      "Option<T>": {
        None: null,
        Some: "T"
      }
    }
  }
});
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type2) {
  return bcs.enum("Option", {
    None: null,
    Some: type2
  });
}
function enumKind(type2) {
  return type2.transform({
    input: (val) => ({
      [val.kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH2).transform({
  input: (val) => typeof val === "string" ? fromHEX(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHEX(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value2) => fromB58(value2),
  output: (value2) => toB58(new Uint8Array(value2))
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwned: SuiObjectRef,
  Shared: SharedObjectRef,
  Receiving: SuiObjectRef
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.vector(bcs.u8()),
  Object: ObjectArg,
  ObjVec: bcs.vector(ObjectArg)
});
var TypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => TypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var Argument = enumKind(
  bcs.enum("Argument", {
    GasCoin: null,
    Input: bcs.struct("Input", { index: bcs.u16() }),
    Result: bcs.struct("Result", { index: bcs.u16() }),
    NestedResult: bcs.struct("NestedResult", { index: bcs.u16(), resultIndex: bcs.u16() })
  })
);
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  type_arguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
}).transform({
  input: (data) => {
    const [pkg, module, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => TypeTagSerializer.parseFromStr(tag, true)
    );
    return {
      package: normalizeSuiAddress(pkg),
      module,
      function: fun,
      type_arguments,
      arguments: data.arguments
    };
  },
  output: (data) => {
    return {
      target: [data.package, data.module, data.function].join(
        "::"
      ),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)
    };
  }
});
var Transaction = enumKind(
  bcs.enum("Transaction", {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: ProgrammableMoveCall,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: bcs.struct("TransferObjects", {
      objects: bcs.vector(Argument),
      address: Argument
    }),
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: bcs.struct("SplitCoins", { coin: Argument, amounts: bcs.vector(Argument) }),
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: bcs.struct("MergeCoins", { destination: Argument, sources: bcs.vector(Argument) }),
    /**
     * Publish a Move module.
     */
    Publish: bcs.struct("Publish", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address)
    }),
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: bcs.struct("MakeMoveVec", {
      type: optionEnum(TypeTag),
      objects: bcs.vector(Argument)
    }),
    /**  */
    Upgrade: bcs.struct("Upgrade", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address),
      packageId: Address,
      ticket: Argument
    })
  })
);
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  transactions: bcs.vector(Transaction)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(TypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
var IntentMessage = bcs.generic(
  ["T"],
  (T) => bcs.struct("IntentMessage<T>", {
    intent: Intent,
    value: T
  })
);
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.vector(bcs.u8()).transform({
  input: (val) => typeof val === "string" ? fromB64(val) : val,
  output: (val) => toB64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  // preserve backwards compatibility with old bcs export
  ser: bcsRegistry.ser.bind(bcsRegistry),
  de: bcsRegistry.de.bind(bcsRegistry),
  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),
  hasType: bcsRegistry.hasType.bind(bcsRegistry),
  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),
  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),
  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),
  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),
  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),
  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),
  registerType: bcsRegistry.registerType.bind(bcsRegistry),
  types: bcsRegistry.types
};
bcsRegistry.registerBcsType("utf8string", () => bcs.string({ name: "utf8string" }));
bcsRegistry.registerBcsType("unsafe_u64", () => unsafe_u64());
bcsRegistry.registerBcsType("enumKind", (T) => enumKind(T));
[
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag
].forEach((type2) => {
  bcsRegistry.registerBcsType(type2.name, () => type2);
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?:[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*)?@[a-z0-9][a-z0-9-]{0,62}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?:[a-z0-9][a-z0-9-]{0,62}\.)+sui$/i;
function normalizeSuiNSName(name2, format = "at") {
  const lowerCase = name2.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name2}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/utils/index.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/Inputs.js
var SuiObjectRef2 = object({
  /** Base64 string representing the object digest */
  digest: string(),
  /** Hex code as string representing the object id */
  objectId: string(),
  /** Object version */
  version: union([number(), string(), bigint()])
});
var ObjectArg2 = union([
  object({ ImmOrOwned: SuiObjectRef2 }),
  object({
    Shared: object({
      objectId: string(),
      initialSharedVersion: union([integer(), string()]),
      mutable: boolean()
    })
  }),
  object({ Receiving: SuiObjectRef2 })
]);
var PureCallArg = object({ Pure: array(integer()) });
var ObjectCallArg = object({ Object: ObjectArg2 });
var BuilderCallArg = union([PureCallArg, ObjectCallArg]);
function Pure(data, type2) {
  return {
    Pure: Array.from(
      data instanceof Uint8Array ? data : isSerializedBcs(data) ? data.toBytes() : (
        // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:
        suiBcs.ser(type2, data, { maxSize: Infinity }).toBytes()
      )
    )
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version: version2 }) {
    return {
      Object: {
        ImmOrOwned: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({ objectId, mutable, initialSharedVersion }) {
    return {
      Object: {
        Shared: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version: version2 }) {
    return {
      Object: {
        Receiving: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if ("ImmOrOwned" in arg.Object) {
    return normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);
  }
  if ("Receiving" in arg.Object) {
    return normalizeSuiAddress(arg.Object.Receiving.objectId);
  }
  return normalizeSuiAddress(arg.Object.Shared.objectId);
}
function getSharedObjectInput(arg) {
  return typeof arg === "object" && "Object" in arg && "Shared" in arg.Object ? arg.Object.Shared : void 0;
}
function isMutableSharedObjectInput(arg) {
  var _a2;
  return ((_a2 = getSharedObjectInput(arg)) == null ? void 0 : _a2.mutable) ?? false;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(value2, type2) {
    return makePure(value2, type2);
  }
  pure.u8 = (value2) => makePure(suiBcs.U8.serialize(value2));
  pure.u16 = (value2) => makePure(suiBcs.U16.serialize(value2));
  pure.u32 = (value2) => makePure(suiBcs.U32.serialize(value2));
  pure.u64 = (value2) => makePure(suiBcs.U64.serialize(value2));
  pure.u128 = (value2) => makePure(suiBcs.U128.serialize(value2));
  pure.u256 = (value2) => makePure(suiBcs.U256.serialize(value2));
  pure.bool = (value2) => makePure(suiBcs.Bool.serialize(value2));
  pure.string = (value2) => makePure(suiBcs.String.serialize(value2));
  pure.address = (value2) => makePure(suiBcs.Address.serialize(value2));
  pure.id = pure.address;
  return pure;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/utils.js
function create2(value2, struct) {
  return create(value2, struct);
}
function extractMutableReference(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference(normalizedType);
  const mutRef = extractMutableReference(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
var RESOLVED_SUI_ID = {
  address: SUI_FRAMEWORK_ADDRESS,
  module: OBJECT_MODULE_NAME,
  name: ID_STRUCT_NAME
};
var RESOLVED_ASCII_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_ASCII_MODULE_NAME,
  name: STD_ASCII_STRUCT_NAME
};
var RESOLVED_UTF8_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_UTF8_MODULE_NAME,
  name: STD_UTF8_STRUCT_NAME
};
var RESOLVED_STD_OPTION = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_OPTION_MODULE_NAME,
  name: STD_OPTION_STRUCT_NAME
};
var isSameStruct = (a3, b2) => a3.address === b2.address && a3.module === b2.module && a3.name === b2.name;
function isTxContext(param) {
  var _a2;
  const struct = (_a2 = extractStructTag(param)) == null ? void 0 : _a2.Struct;
  return (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
}
function expectType(typeName, argVal) {
  if (typeof argVal === "undefined") {
    return;
  }
  if (typeof argVal !== typeName) {
    throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);
  }
}
var allowedTypes = ["Address", "Bool", "U8", "U16", "U32", "U64", "U128", "U256"];
function getPureSerializationType(normalizedType, argVal) {
  if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
    if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
      expectType("number", argVal);
    } else if (normalizedType === "Bool") {
      expectType("boolean", argVal);
    } else if (normalizedType === "Address") {
      expectType("string", argVal);
      if (argVal && !isValidSuiAddress(argVal)) {
        throw new Error("Invalid Sui Address");
      }
    }
    return normalizedType.toLowerCase();
  } else if (typeof normalizedType === "string") {
    throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);
  }
  if ("Vector" in normalizedType) {
    if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
      return "string";
    }
    if (argVal !== void 0 && !Array.isArray(argVal)) {
      throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);
    }
    const innerType = getPureSerializationType(
      normalizedType.Vector,
      // undefined when argVal is empty
      argVal ? argVal[0] : void 0
    );
    if (innerType === void 0) {
      return;
    }
    return `vector<${innerType}>`;
  }
  if ("Struct" in normalizedType) {
    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
      return "string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
      return "utf8string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
      return "address";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
      const optionToVec = {
        Vector: normalizedType.Struct.typeArguments[0]
      };
      return getPureSerializationType(optionToVec, argVal);
    }
  }
  return void 0;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e3) => e3.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/Transactions.js
var option = (some) => union([object({ None: union([literal(true), literal(null)]) }), object({ Some: some })]);
var TransactionBlockInput = union([
  object({
    kind: literal("Input"),
    index: integer(),
    value: optional(any()),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: integer(),
    value: optional(any()),
    type: literal("pure")
  })
]);
var TransactionArgumentTypes = [
  TransactionBlockInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: integer() }),
  object({
    kind: literal("NestedResult"),
    index: integer(),
    resultIndex: integer()
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: define("target", string().validator),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  // TODO: ideally we should use `TypeTag` instead of `record()` here,
  // but TypeTag is recursively defined and it's tricky to define a
  // recursive struct in superstruct
  type: optional(option(record(string(), unknown()))),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(integer())),
  dependencies: array(string())
});
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(integer())),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var Transactions = {
  MoveCall(input) {
    return create2(
      {
        kind: "MoveCall",
        target: input.target,
        arguments: input.arguments ?? [],
        typeArguments: input.typeArguments ?? []
      },
      MoveCallTransaction
    );
  },
  TransferObjects(objects, address) {
    if (address.kind === "Input" && address.type === "pure" && typeof address.value !== "object") {
      address.value = Inputs.Pure(suiBcs.Address.serialize(address.value));
    }
    return create2({ kind: "TransferObjects", objects, address }, TransferObjectsTransaction);
  },
  SplitCoins(coin, amounts) {
    amounts.forEach((input) => {
      if (input.kind === "Input" && input.type === "pure" && typeof input.value !== "object") {
        input.value = Inputs.Pure(suiBcs.U64.serialize(input.value));
      }
    });
    return create2(
      {
        kind: "SplitCoins",
        coin,
        amounts
      },
      SplitCoinsTransaction
    );
  },
  MergeCoins(destination, sources) {
    return create2({ kind: "MergeCoins", destination, sources }, MergeCoinsTransaction);
  },
  Publish({
    modules,
    dependencies
  }) {
    return create2(
      {
        kind: "Publish",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      },
      PublishTransaction
    );
  },
  Upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return create2(
      {
        kind: "Upgrade",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        packageId,
        ticket
      },
      UpgradeTransaction
    );
  },
  MakeMoveVec({
    type: type2,
    objects
  }) {
    return create2(
      {
        kind: "MakeMoveVec",
        type: type2 ? { Some: TypeTagSerializer.parseFromStr(type2) } : { None: null },
        objects
      },
      MakeMoveVecTransaction
    );
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/TransactionBlockData.js
var TransactionExpiration2 = optional(
  nullable(
    union([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })])
  )
);
var StringEncodedBigint = define("StringEncodedBigint", (val) => {
  if (!["string", "number", "bigint"].includes(typeof val))
    return false;
  try {
    BigInt(val);
    return true;
  } catch {
    return false;
  }
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(SuiObjectRef2)),
  owner: optional(string())
});
var SerializedTransactionDataBuilder = object({
  version: literal(1),
  sender: optional(string()),
  expiration: TransactionExpiration2,
  gasConfig: GasConfig,
  inputs: array(TransactionBlockInput),
  transactions: array(TransactionType)
});
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionBlockDataBuilder = class _TransactionBlockDataBuilder {
  constructor(clone) {
    this.version = 1;
    this.sender = clone == null ? void 0 : clone.sender;
    this.expiration = clone == null ? void 0 : clone.expiration;
    this.gasConfig = (clone == null ? void 0 : clone.gasConfig) ?? {};
    this.inputs = (clone == null ? void 0 : clone.inputs) ?? [];
    this.transactions = (clone == null ? void 0 : clone.transactions) ?? [];
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = "ProgrammableTransaction" in kind ? kind.ProgrammableTransaction : null;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        gasConfig: {},
        inputs: programmableTx.inputs.map(
          (value2, index) => create2(
            {
              kind: "Input",
              value: value2,
              index,
              type: is(value2, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return _TransactionBlockDataBuilder.restore(serialized);
  }
  static fromBytes(bytes) {
    var _a2;
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = "ProgrammableTransaction" in data.kind ? (_a2 = data == null ? void 0 : data.kind) == null ? void 0 : _a2.ProgrammableTransaction : null;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        sender: data.sender,
        expiration: data.expiration,
        gasConfig: data.gasData,
        inputs: programmableTx.inputs.map(
          (value2, index) => create2(
            {
              kind: "Input",
              value: value2,
              index,
              type: is(value2, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return _TransactionBlockDataBuilder.restore(serialized);
  }
  static restore(data) {
    assert(data, SerializedTransactionDataBuilder);
    const transactionData = new _TransactionBlockDataBuilder();
    Object.assign(transactionData, data);
    return transactionData;
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toB58(hash);
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs.map((input) => {
      assert(input.value, BuilderCallArg);
      return input.value;
    });
    const kind = {
      ProgrammableTransaction: {
        inputs,
        transactions: this.transactions
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasConfig = { ...this.gasConfig, ...overrides == null ? void 0 : overrides.gasConfig };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasConfig.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasConfig.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasConfig.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasConfig.payment,
        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),
        price: BigInt(gasConfig.price),
        budget: BigInt(gasConfig.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          transactions: this.transactions
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionBlockDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return create2(this, SerializedTransactionDataBuilder);
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/transactions/TransactionBlock.js
var __accessCheck4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet4 = (obj, member, getter) => {
  __accessCheck4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd4 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet4 = (obj, member, value2, setter) => {
  __accessCheck4(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateMethod3 = (obj, member, method) => {
  __accessCheck4(obj, member, "access private method");
  return method;
};
var _blockData;
var _input;
var input_fn;
var _normalizeTransactionArgument;
var normalizeTransactionArgument_fn;
var _getConfig;
var getConfig_fn;
var _validate;
var validate_fn;
var _prepareGasPayment;
var prepareGasPayment_fn;
var _prepareGasPrice;
var prepareGasPrice_fn;
var _prepareTransactions;
var prepareTransactions_fn;
var _prepare;
var prepare_fn;
var DefaultOfflineLimits = {
  maxPureArgumentSize: 16 * 1024,
  maxTxGas: 5e10,
  maxGasObjects: 256,
  maxTxSizeBytes: 128 * 1024
};
function createTransactionResult(index) {
  const baseResult = { kind: "Result", index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    kind: "NestedResult",
    index,
    resultIndex
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i2 = 0;
          while (true) {
            yield nestedResultFor(i2);
            i2++;
          }
        };
      }
      if (typeof property === "symbol")
        return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0)
        return;
      return nestedResultFor(resultIndex);
    }
  });
}
function isReceivingType(normalizedType) {
  const tag = extractStructTag(normalizedType);
  if (tag) {
    return tag.Struct.address === "0x2" && tag.Struct.module === "transfer" && tag.Struct.name === "Receiving";
  }
  return false;
}
function expectClient(options) {
  if (!options.client) {
    throw new Error(
      `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
var LIMITS = {
  // The maximum gas that is allowed.
  maxTxGas: "max_tx_gas",
  // The maximum number of gas objects that can be selected for one transaction.
  maxGasObjects: "max_gas_payment_objects",
  // The maximum size (in bytes) that the transaction can be:
  maxTxSizeBytes: "max_tx_size_bytes",
  // The maximum size (in bytes) that pure arguments can be:
  maxPureArgumentSize: "max_pure_argument_size"
};
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_OBJECTS_PER_FETCH = 50;
var chunk = (arr, size) => Array.from(
  { length: Math.ceil(arr.length / size) },
  (_2, i2) => arr.slice(i2 * size, i2 * size + size)
);
function isTransactionBlock(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var _TransactionBlock = class {
  constructor(transaction) {
    __privateAdd4(this, _input);
    __privateAdd4(this, _normalizeTransactionArgument);
    __privateAdd4(this, _getConfig);
    __privateAdd4(this, _validate);
    __privateAdd4(this, _prepareGasPayment);
    __privateAdd4(this, _prepareGasPrice);
    __privateAdd4(this, _prepareTransactions);
    __privateAdd4(this, _prepare);
    __privateAdd4(this, _blockData, void 0);
    __privateSet4(this, _blockData, new TransactionBlockDataBuilder(
      transaction ? transaction.blockData : void 0
    ));
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _TransactionBlock();
    __privateSet4(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromB64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(serialized) {
    const tx = new _TransactionBlock();
    if (typeof serialized !== "string" || !serialized.startsWith("{")) {
      __privateSet4(tx, _blockData, TransactionBlockDataBuilder.fromBytes(
        typeof serialized === "string" ? fromB64(serialized) : serialized
      ));
    } else {
      __privateSet4(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));
    }
    return tx;
  }
  setSender(sender) {
    __privateGet4(this, _blockData).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet4(this, _blockData).sender) {
      __privateGet4(this, _blockData).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet4(this, _blockData).expiration = expiration;
  }
  setGasPrice(price) {
    __privateGet4(this, _blockData).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet4(this, _blockData).gasConfig.budget = String(budget);
  }
  setGasOwner(owner) {
    __privateGet4(this, _blockData).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet4(this, _blockData).gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef2));
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  get blockData() {
    return __privateGet4(this, _blockData).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value2, type2) => {
        if (isSerializedBcs(value2)) {
          return __privateMethod3(this, _input, input_fn).call(this, "pure", {
            Pure: Array.from(value2.toBytes())
          });
        }
        return __privateMethod3(this, _input, input_fn).call(this, "pure", value2 instanceof Uint8Array ? Inputs.Pure(value2) : type2 ? Inputs.Pure(value2, type2) : value2);
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { kind: "GasCoin" };
  }
  /**
   * Add a new object input to the transaction.
   */
  object(value2) {
    if (typeof value2 === "object" && "kind" in value2) {
      return value2;
    }
    const id = getIdFromCallArg(value2);
    const inserted = __privateGet4(this, _blockData).inputs.find(
      (i2) => i2.type === "object" && id === getIdFromCallArg(i2.value)
    );
    if (inserted && is(inserted.value, ObjectCallArg) && "Shared" in inserted.value.Object && is(value2, ObjectCallArg) && "Shared" in value2.Object) {
      inserted.value.Object.Shared.mutable = inserted.value.Object.Shared.mutable || value2.Object.Shared.mutable;
    }
    return inserted ?? __privateMethod3(this, _input, input_fn).call(this, "object", typeof value2 === "string" ? normalizeSuiAddress(value2) : value2);
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction block. */
  add(transaction) {
    const index = __privateGet4(this, _blockData).transactions.push(transaction);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    return this.add(
      Transactions.SplitCoins(
        typeof coin === "string" ? this.object(coin) : coin,
        amounts.map(
          (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, amount)
        )
      )
    );
  }
  mergeCoins(destination, sources) {
    return this.add(
      Transactions.MergeCoins(
        typeof destination === "string" ? this.object(destination) : destination,
        sources.map((src) => typeof src === "string" ? this.object(src) : src)
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Transactions.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return this.add(
      Transactions.Upgrade({
        modules,
        dependencies,
        packageId,
        ticket: typeof ticket === "string" ? this.object(ticket) : ticket
      })
    );
  }
  moveCall({
    arguments: args,
    typeArguments,
    target
  }) {
    return this.add(
      Transactions.MoveCall({
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, arg)),
        typeArguments,
        target
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Transactions.TransferObjects(
        objects.map((obj) => typeof obj === "string" ? this.object(obj) : obj),
        typeof address === "string" ? this.pure.address(address) : __privateMethod3(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type: type2,
    objects
  }) {
    return this.add(
      Transactions.MakeMoveVec({
        type: type2,
        objects: objects.map((obj) => typeof obj === "string" ? this.object(obj) : obj)
      })
    );
  }
  /**
   * Serialize the transaction to a string so that it can be sent to a separate context.
   * This is different from `build` in that it does not serialize to BCS bytes, and instead
   * uses a separate format that is unique to the transaction builder. This allows
   * us to serialize partially-complete transactions, that can then be completed and
   * built in a separate context.
   *
   * For example, a dapp can construct a transaction, but not provide gas objects
   * or a gas budget. The transaction then can be sent to the wallet, where this
   * information is automatically filled in (e.g. by querying for coin objects
   * and performing a dry run).
   */
  serialize() {
    return JSON.stringify(__privateGet4(this, _blockData).snapshot());
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransactionBlock(bytes);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await __privateMethod3(this, _prepare, prepare_fn).call(this, options);
    return __privateGet4(this, _blockData).build({
      maxSizeBytes: __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod3(this, _prepare, prepare_fn).call(this, options);
    return __privateGet4(this, _blockData).getDigest();
  }
};
_blockData = /* @__PURE__ */ new WeakMap();
_input = /* @__PURE__ */ new WeakSet();
input_fn = function(type2, value2) {
  const index = __privateGet4(this, _blockData).inputs.length;
  const input = create2(
    {
      kind: "Input",
      // bigints can't be serialized to JSON, so just string-convert them here:
      value: typeof value2 === "bigint" ? String(value2) : value2,
      index,
      type: type2
    },
    TransactionBlockInput
  );
  __privateGet4(this, _blockData).inputs.push(input);
  return input;
};
_normalizeTransactionArgument = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return arg;
};
_getConfig = /* @__PURE__ */ new WeakSet();
getConfig_fn = function(key, { protocolConfig, limits }) {
  if (limits && typeof limits[key] === "number") {
    return limits[key];
  }
  if (!protocolConfig) {
    return DefaultOfflineLimits[key];
  }
  const attribute = protocolConfig == null ? void 0 : protocolConfig.attributes[LIMITS[key]];
  if (!attribute) {
    throw new Error(`Missing expected protocol config: "${LIMITS[key]}"`);
  }
  const value2 = "u64" in attribute ? attribute.u64 : "u32" in attribute ? attribute.u32 : attribute.f64;
  if (!value2) {
    throw new Error(`Unexpected protocol config value found for: "${LIMITS[key]}"`);
  }
  return Number(value2);
};
_validate = /* @__PURE__ */ new WeakSet();
validate_fn = function(options) {
  const maxPureArgumentSize = __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxPureArgumentSize", options);
  __privateGet4(this, _blockData).inputs.forEach((input, index) => {
    if (is(input.value, PureCallArg)) {
      if (input.value.Pure.length > maxPureArgumentSize) {
        throw new Error(
          `Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`
        );
      }
    }
  });
};
_prepareGasPayment = /* @__PURE__ */ new WeakSet();
prepareGasPayment_fn = async function(options) {
  if (__privateGet4(this, _blockData).gasConfig.payment) {
    const maxGasObjects = __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options);
    if (__privateGet4(this, _blockData).gasConfig.payment.length > maxGasObjects) {
      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);
    }
  }
  if (options.onlyTransactionKind || __privateGet4(this, _blockData).gasConfig.payment) {
    return;
  }
  const gasOwner = __privateGet4(this, _blockData).gasConfig.owner ?? __privateGet4(this, _blockData).sender;
  const coins = await expectClient(options).getCoins({
    owner: gasOwner,
    coinType: SUI_TYPE_ARG
  });
  const paymentCoins = coins.data.filter((coin) => {
    const matchingInput = __privateGet4(this, _blockData).inputs.find((input) => {
      if (is(input.value, BuilderCallArg) && "Object" in input.value && "ImmOrOwned" in input.value.Object) {
        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;
      }
      return false;
    });
    return !matchingInput;
  }).slice(0, __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options) - 1).map((coin) => ({
    objectId: coin.coinObjectId,
    digest: coin.digest,
    version: coin.version
  }));
  if (!paymentCoins.length) {
    throw new Error("No valid gas coins found for the transaction.");
  }
  this.setGasPayment(paymentCoins);
};
_prepareGasPrice = /* @__PURE__ */ new WeakSet();
prepareGasPrice_fn = async function(options) {
  if (options.onlyTransactionKind || __privateGet4(this, _blockData).gasConfig.price) {
    return;
  }
  this.setGasPrice(await expectClient(options).getReferenceGasPrice());
};
_prepareTransactions = /* @__PURE__ */ new WeakSet();
prepareTransactions_fn = async function(options) {
  const { inputs, transactions } = __privateGet4(this, _blockData);
  const moveModulesToResolve = [];
  const objectsToResolve = [];
  inputs.forEach((input) => {
    if (input.type === "object" && typeof input.value === "string") {
      objectsToResolve.push({ id: normalizeSuiAddress(input.value), input });
      return;
    }
  });
  transactions.forEach((transaction) => {
    if (transaction.kind === "MoveCall") {
      const needsResolution = transaction.arguments.some(
        (arg) => arg.kind === "Input" && !is(inputs[arg.index].value, BuilderCallArg)
      );
      if (needsResolution) {
        moveModulesToResolve.push(transaction);
      }
    }
    if (transaction.kind === "SplitCoins") {
      transaction.amounts.forEach((amount) => {
        if (amount.kind === "Input") {
          const input = inputs[amount.index];
          if (typeof input.value !== "object") {
            input.value = Inputs.Pure(suiBcs.U64.serialize(input.value));
          }
        }
      });
    }
    if (transaction.kind === "TransferObjects") {
      if (transaction.address.kind === "Input") {
        const input = inputs[transaction.address.index];
        if (typeof input.value !== "object") {
          input.value = Inputs.Pure(suiBcs.Address.serialize(input.value));
        }
      }
    }
  });
  if (moveModulesToResolve.length) {
    await Promise.all(
      moveModulesToResolve.map(async (moveCall) => {
        const [packageId, moduleName, functionName] = moveCall.target.split("::");
        const normalized = await expectClient(options).getNormalizedMoveFunction({
          package: normalizeSuiObjectId(packageId),
          module: moduleName,
          function: functionName
        });
        const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));
        const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;
        if (params.length !== moveCall.arguments.length) {
          throw new Error("Incorrect number of arguments.");
        }
        params.forEach((param, i2) => {
          const arg = moveCall.arguments[i2];
          if (arg.kind !== "Input")
            return;
          const input = inputs[arg.index];
          if (is(input.value, BuilderCallArg))
            return;
          const inputValue = input.value;
          const serType = getPureSerializationType(param, inputValue);
          if (serType) {
            input.value = Inputs.Pure(inputValue, serType);
            return;
          }
          const structVal = extractStructTag(param);
          if (structVal != null || typeof param === "object" && "TypeParameter" in param) {
            if (typeof inputValue !== "string") {
              throw new Error(
                `Expect the argument to be an object id string, got ${JSON.stringify(
                  inputValue,
                  null,
                  2
                )}`
              );
            }
            objectsToResolve.push({
              id: inputValue,
              input,
              normalizedType: param
            });
            return;
          }
          throw new Error(
            `Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(
              inputValue,
              null,
              2
            )}`
          );
        });
      })
    );
  }
  if (objectsToResolve.length) {
    const dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];
    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);
    const objects = (await Promise.all(
      objectChunks.map(
        (chunk2) => expectClient(options).multiGetObjects({
          ids: chunk2,
          options: { showOwner: true }
        })
      )
    )).flat();
    let objectsById = new Map(
      dedupedIds.map((id, index) => {
        return [id, objects[index]];
      })
    );
    const invalidObjects = Array.from(objectsById).filter(([_2, obj]) => obj.error).map(([id, _2]) => id);
    if (invalidObjects.length) {
      throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
    }
    objectsToResolve.forEach(({ id, input, normalizedType }) => {
      var _a2;
      const object2 = objectsById.get(id);
      const owner = (_a2 = object2.data) == null ? void 0 : _a2.owner;
      const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : void 0;
      if (initialSharedVersion) {
        const isByValue = normalizedType != null && extractMutableReference(normalizedType) == null && extractReference(normalizedType) == null;
        const mutable = isMutableSharedObjectInput(input.value) || isByValue || normalizedType != null && extractMutableReference(normalizedType) != null;
        input.value = Inputs.SharedObjectRef({
          objectId: id,
          initialSharedVersion,
          mutable
        });
      } else if (normalizedType && isReceivingType(normalizedType)) {
        input.value = Inputs.ReceivingRef(object2.data);
      } else {
        input.value = Inputs.ObjectRef(object2.data);
      }
    });
  }
};
_prepare = /* @__PURE__ */ new WeakSet();
prepare_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet4(this, _blockData).sender) {
    throw new Error("Missing transaction sender");
  }
  if (!options.protocolConfig && !options.limits && options.client) {
    options.protocolConfig = await options.client.getProtocolConfig();
  }
  await Promise.all([__privateMethod3(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod3(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);
  if (!options.onlyTransactionKind) {
    await __privateMethod3(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);
    if (!__privateGet4(this, _blockData).gasConfig.budget) {
      const dryRunResult = await expectClient(options).dryRunTransactionBlock({
        transactionBlock: __privateGet4(this, _blockData).build({
          maxSizeBytes: __privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
          overrides: {
            gasConfig: {
              budget: String(__privateMethod3(this, _getConfig, getConfig_fn).call(this, "maxTxGas", options)),
              payment: []
            }
          }
        })
      });
      if (dryRunResult.effects.status.status !== "success") {
        throw new Error(
          `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
          { cause: dryRunResult }
        );
      }
      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);
      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
      this.setGasBudget(
        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
      );
    }
  }
  __privateMethod3(this, _validate, validate_fn).call(this, options);
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class {
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit]
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getAllBalances", params: [input.owner] });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType]
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType]
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params) {
    return await this.transport.request({ method, params });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package]
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module]
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function]
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct]
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ]
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options]
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options]
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options]
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options]
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d) => {
      if (!isValidTransactionDigest(d)) {
        throw new Error(`Invalid Transaction digest ${d}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options]
    });
  }
  async executeTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock),
        Array.isArray(input.signature) ? input.signature : [input.signature],
        input.options,
        input.requestType
      ]
    });
  }
  async signAndExecuteTransactionBlock({
    transactionBlock,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transactionBlock instanceof Uint8Array) {
      transactionBytes = transactionBlock;
    } else {
      transactionBlock.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transactionBlock.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransactionBlock(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: []
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({ method: "suix_getStakes", params: [input.owner] });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds]
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: "suix_getLatestSuiSystemState", params: [] });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ]
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a2;
    let devInspectTxBytes;
    if (isTransactionBlock(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toB64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toB64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_a2 = input.gasPrice) == null ? void 0 : _a2.toString(), input.epoch]
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit]
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name]
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: []
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({ method: "sui_getCheckpoint", params: [input.id] });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch]
    });
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: "suix_getNetworkMetrics", params: [] });
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: "suix_getLatestAddressMetrics", params: [] });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder]
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics() {
    return await this.transport.request({ method: "suix_getMoveCallMetrics", params: [] });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.transport.request({ method: "suix_getCurrentEpoch", params: [] });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy() {
    return await this.transport.request({ method: "suix_getValidatorsApy", params: [] });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier() {
    const checkpoint = await this.getCheckpoint({ id: "0" });
    const bytes = fromB58(checkpoint.digest);
    return toHEX(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name]
    });
  }
  async resolveNameServiceNames({
    format = "dot",
    ...input
  }) {
    const { nextCursor, hasNextPage, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit]
    });
    return {
      hasNextPage,
      nextCursor,
      data: data.map((name2) => normalizeSuiNSName(name2, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version]
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransactionBlock({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_2, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e3) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/intent.js
var AppId2 = ((AppId22) => {
  AppId22[AppId22["Sui"] = 0] = "Sui";
  return AppId22;
})(AppId2 || {});
var IntentVersion2 = ((IntentVersion22) => {
  IntentVersion22[IntentVersion22["V0"] = 0] = "V0";
  return IntentVersion22;
})(IntentVersion2 || {});
var IntentScope2 = ((IntentScope22) => {
  IntentScope22[IntentScope22["TransactionData"] = 0] = "TransactionData";
  IntentScope22[IntentScope22["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope22[IntentScope22["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope22[IntentScope22["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope22;
})(IntentScope2 || {});
function intentWithScope(scope) {
  return [
    scope,
    0,
    0
    /* Sui */
  ];
}
function messageWithIntent(scope, message) {
  const intent = intentWithScope(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/publickey.js
function bytesEqual(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a3.length; i2++) {
    if (a3[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toB64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toB64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(message).toBytes(),
      signature,
      IntentScope2.PersonalMessage
    );
  }
  /**
   * Verifies that the signature is valid for for the provided TransactionBlock
   */
  verifyTransactionBlock(transactionBlock, signature) {
    return this.verifyWithIntent(transactionBlock, signature, IntentScope2.TransactionData);
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
    );
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin"
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 10,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array2) {
  return array2 === void 0 || array2.length === 0 ? void 0 : array2;
}

// node_modules/graphql/language/ast.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array2[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn2(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option2 of options) {
    const distance = lexicalDistance.measure(option2, threshold);
    if (distance !== void 0) {
      optionsByDistance[option2] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option2, threshold) {
    if (this._input === option2) {
      return 0;
    }
    const optionLowerCase = option2.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i2 = 1; i2 <= aLength; i2++) {
      const upRow = rows[(i2 - 1) % 3];
      const currentRow = rows[i2 % 3];
      let smallestCell = currentRow[0] = i2;
      for (let j = 1; j <= bLength; j++) {
        const cost = a3[i2 - 1] === b2[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i2 > 1 && j > 1 && a3[i2 - 1] === b2[j - 2] && a3[i2 - 2] === b2[j - 1]) {
          const doubleDiagonalCell = rows[(i2 - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array2 = new Array(strLength);
  for (let i2 = 0; i2 < strLength; ++i2) {
    array2[i2] = str.charCodeAt(i2);
  }
  return array2;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map[key] = value2;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions: variableDefinitions2, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions2, ", "), ")")} on ${typeCondition} ${wrap("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join(["scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types }) => wrap("", description, "\n") + join(
      ["union", name2, join(directives2, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values }) => wrap("", description, "\n") + join(["enum", name2, join(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join([name2, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join(["extend scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types }) => join(
      [
        "extend union",
        name2,
        join(directives2, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values }) => join(["extend enum", name2, join(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join(["extend input", name2, join(directives2, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap("{\n", indent(join(array2, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i2 = 1; i2 < name2.length; ++i2) {
    if (!isNameContinue(name2.charCodeAt(i2))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}

// node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name2) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value2) => value2.name);
    }
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isInteger(num2)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num2 = parseInt(valueNode.value, 10);
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num2;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isFinite(num2)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item of value2) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type2) => {
        if (isInputObjectType(type2)) {
          return type2.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name2 = node.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i2 = 0; i2 < fragmentNames.length; i2++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i2]
      );
      for (let j = i2 + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i2],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i2 = 0; i2 < fields.length; i2++) {
        for (let j = i2 + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i2],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name: name2, value: value2 }) => [name2.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var OrderedPairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a3)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b2);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a3, b2, weaklyPresent) {
    const map = this._data.get(a3);
    if (map === void 0) {
      this._data.set(a3, /* @__PURE__ */ new Map([[b2, weaklyPresent]]));
    } else {
      map.set(b2, weaklyPresent);
    }
  }
};
var PairSet = class {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a3, b2, weaklyPresent) {
    return a3 < b2 ? this._orderedPairSet.has(a3, b2, weaklyPresent) : this._orderedPairSet.has(b2, a3, weaklyPresent);
  }
  add(a3, b2, weaklyPresent) {
    if (a3 < b2) {
      this._orderedPairSet.add(a3, b2, weaklyPresent);
    } else {
      this._orderedPairSet.add(b2, a3, weaklyPresent);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type2 = context.getType();
      const selectionSet2 = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        } else if (selectionSet2.selections.length === 0) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type2.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions2 = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions2,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions2 = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions2 = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions2[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type2.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type2,
          fieldNodeMap,
          variableDefinitions2
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error2) {
    const typeStr = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error2.message,
          {
            nodes: node,
            originalError: error2
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type2, fieldNodeMap, variableDefinitions2) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type2.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value2 = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value2 || value2.kind === Kind.NULL;
  const isVariable = (value2 === null || value2 === void 0 ? void 0 : value2.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value2.name.value;
    const definition = variableDefinitions2[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type2, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized2(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a22);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/graphql/client.js
var __accessCheck5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet5 = (obj, member, getter) => {
  __accessCheck5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd5 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet5 = (obj, member, value2, setter) => {
  __accessCheck5(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var _url;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {}
  }) {
    __privateAdd5(this, _url, void 0);
    __privateAdd5(this, _queries, void 0);
    __privateAdd5(this, _headers, void 0);
    __privateAdd5(this, _fetch, void 0);
    __privateSet5(this, _url, url);
    __privateSet5(this, _queries, queries);
    __privateSet5(this, _headers, headers);
    __privateSet5(this, _fetch, (...args) => fetchFn(...args));
  }
  async query(options) {
    const res = await __privateGet5(this, _fetch).call(this, __privateGet5(this, _url), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet5(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      })
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet5(this, _queries)[query]
    });
  }
};
_url = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e3, r, i2, n2, t3, a3, o2) {
    if (super(e3), this.name = "GraphQLError", this.message = e3, t3) {
      this.path = t3;
    }
    if (r) {
      this.nodes = Array.isArray(r) ? r : [r];
    }
    if (i2) {
      this.source = i2;
    }
    if (n2) {
      this.positions = n2;
    }
    if (a3) {
      this.originalError = a3;
    }
    var l = o2;
    if (!l && a3) {
      var d = a3.extensions;
      if (d && "object" == typeof d) {
        l = d;
      }
    }
    this.extensions = l || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i;
var n;
function error(e3) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n} in ${e3}`);
}
function advance(e3) {
  if (e3.lastIndex = n, e3.test(i)) {
    return i.slice(n, n = e3.lastIndex);
  }
}
var t = / +(?=[^\s])/y;
function blockString(e3) {
  var r = e3.split("\n");
  var i2 = "";
  var n2 = 0;
  var a3 = 0;
  var o2 = r.length - 1;
  for (var l = 0; l < r.length; l++) {
    if (t.lastIndex = 0, t.test(r[l])) {
      if (l && (!n2 || t.lastIndex < n2)) {
        n2 = t.lastIndex;
      }
      a3 = a3 || l, o2 = l;
    }
  }
  for (var d = a3; d <= o2; d++) {
    if (d !== a3) {
      i2 += "\n";
    }
    i2 += r[d].slice(n2).replace(/\\"""/g, '"""');
  }
  return i2;
}
function ignored() {
  for (var e3 = 0 | i.charCodeAt(n++); 9 === e3 || 10 === e3 || 13 === e3 || 32 === e3 || 35 === e3 || 44 === e3 || 65279 === e3; e3 = 0 | i.charCodeAt(n++)) {
    if (35 === e3) {
      for (; 10 !== (e3 = i.charCodeAt(n++)) && 13 !== e3; ) {
      }
    }
  }
  n--;
}
function name() {
  var e3 = n;
  for (var r = 0 | i.charCodeAt(n++); r >= 48 && r <= 57 || r >= 65 && r <= 90 || 95 === r || r >= 97 && r <= 122; r = 0 | i.charCodeAt(n++)) {
  }
  if (e3 === n - 1) {
    throw error("Name");
  }
  var t3 = i.slice(e3, --n);
  return ignored(), t3;
}
function nameNode() {
  return {
    kind: "Name",
    value: name()
  };
}
var a = /(?:"""|(?:[\s\S]*?[^\\])""")/y;
var o = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
function value(e3) {
  var r;
  switch (i.charCodeAt(n)) {
    case 91:
      n++, ignored();
      var t3 = [];
      for (; 93 !== i.charCodeAt(n); ) {
        t3.push(value(e3));
      }
      return n++, ignored(), {
        kind: "ListValue",
        values: t3
      };
    case 123:
      n++, ignored();
      var l = [];
      for (; 125 !== i.charCodeAt(n); ) {
        var d = nameNode();
        if (58 !== i.charCodeAt(n++)) {
          throw error("ObjectField");
        }
        ignored(), l.push({
          kind: "ObjectField",
          name: d,
          value: value(e3)
        });
      }
      return n++, ignored(), {
        kind: "ObjectValue",
        fields: l
      };
    case 36:
      if (e3) {
        throw error("Variable");
      }
      return n++, {
        kind: "Variable",
        name: nameNode()
      };
    case 34:
      if (34 === i.charCodeAt(n + 1) && 34 === i.charCodeAt(n + 2)) {
        if (n += 3, null == (r = advance(a))) {
          throw error("StringValue");
        }
        return ignored(), {
          kind: "StringValue",
          value: blockString(r.slice(0, -3)),
          block: true
        };
      } else {
        var u = n;
        var s;
        n++;
        var c = false;
        for (s = 0 | i.charCodeAt(n++); 92 === s && (n++, c = true) || 10 !== s && 13 !== s && 34 !== s && s; s = 0 | i.charCodeAt(n++)) {
        }
        if (34 !== s) {
          throw error("StringValue");
        }
        return r = i.slice(u, n), ignored(), {
          kind: "StringValue",
          value: c ? JSON.parse(r) : r.slice(1, -1),
          block: false
        };
      }
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      var v = n++;
      var f;
      for (; (f = 0 | i.charCodeAt(n++)) >= 48 && f <= 57; ) {
      }
      var m = i.slice(v, --n);
      if (46 === (f = i.charCodeAt(n)) || 69 === f || 101 === f) {
        if (null == (r = advance(o))) {
          throw error("FloatValue");
        }
        return ignored(), {
          kind: "FloatValue",
          value: m + r
        };
      } else {
        return ignored(), {
          kind: "IntValue",
          value: m
        };
      }
    case 110:
      if (117 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 108 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "NullValue"
        };
      } else {
        break;
      }
    case 116:
      if (114 === i.charCodeAt(n + 1) && 117 === i.charCodeAt(n + 2) && 101 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "BooleanValue",
          value: true
        };
      } else {
        break;
      }
    case 102:
      if (97 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 115 === i.charCodeAt(n + 3) && 101 === i.charCodeAt(n + 4)) {
        return n += 5, ignored(), {
          kind: "BooleanValue",
          value: false
        };
      } else {
        break;
      }
  }
  return {
    kind: "EnumValue",
    value: name()
  };
}
function arguments_(e3) {
  if (40 === i.charCodeAt(n)) {
    var r = [];
    n++, ignored();
    do {
      var t3 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("Argument");
      }
      ignored(), r.push({
        kind: "Argument",
        name: t3,
        value: value(e3)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), r;
  }
}
function directives(e3) {
  if (64 === i.charCodeAt(n)) {
    var r = [];
    do {
      n++, r.push({
        kind: "Directive",
        name: nameNode(),
        arguments: arguments_(e3)
      });
    } while (64 === i.charCodeAt(n));
    return r;
  }
}
function type() {
  var e3 = 0;
  for (; 91 === i.charCodeAt(n); ) {
    e3++, n++, ignored();
  }
  var r = {
    kind: "NamedType",
    name: nameNode()
  };
  do {
    if (33 === i.charCodeAt(n)) {
      n++, ignored(), r = {
        kind: "NonNullType",
        type: r
      };
    }
    if (e3) {
      if (93 !== i.charCodeAt(n++)) {
        throw error("NamedType");
      }
      ignored(), r = {
        kind: "ListType",
        type: r
      };
    }
  } while (e3--);
  return r;
}
function selectionSetStart() {
  if (123 !== i.charCodeAt(n++)) {
    throw error("SelectionSet");
  }
  return ignored(), selectionSet();
}
function selectionSet() {
  var e3 = [];
  do {
    if (46 === i.charCodeAt(n)) {
      if (46 !== i.charCodeAt(++n) || 46 !== i.charCodeAt(++n)) {
        throw error("SelectionSet");
      }
      switch (n++, ignored(), i.charCodeAt(n)) {
        case 64:
          e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        case 111:
          if (110 === i.charCodeAt(n + 1)) {
            n += 2, ignored(), e3.push({
              kind: "InlineFragment",
              typeCondition: {
                kind: "NamedType",
                name: nameNode()
              },
              directives: directives(false),
              selectionSet: selectionSetStart()
            });
          } else {
            e3.push({
              kind: "FragmentSpread",
              name: nameNode(),
              directives: directives(false)
            });
          }
          break;
        case 123:
          n++, ignored(), e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: void 0,
            selectionSet: selectionSet()
          });
          break;
        default:
          e3.push({
            kind: "FragmentSpread",
            name: nameNode(),
            directives: directives(false)
          });
      }
    } else {
      var r = nameNode();
      var t3 = void 0;
      if (58 === i.charCodeAt(n)) {
        n++, ignored(), t3 = r, r = nameNode();
      }
      var a3 = arguments_(false);
      var o2 = directives(false);
      var l = void 0;
      if (123 === i.charCodeAt(n)) {
        n++, ignored(), l = selectionSet();
      }
      e3.push({
        kind: "Field",
        alias: t3,
        name: r,
        arguments: a3,
        directives: o2,
        selectionSet: l
      });
    }
  } while (125 !== i.charCodeAt(n));
  return n++, ignored(), {
    kind: "SelectionSet",
    selections: e3
  };
}
function variableDefinitions() {
  if (ignored(), 40 === i.charCodeAt(n)) {
    var e3 = [];
    n++, ignored();
    do {
      if (36 !== i.charCodeAt(n++)) {
        throw error("Variable");
      }
      var r = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("VariableDefinition");
      }
      ignored();
      var t3 = type();
      var a3 = void 0;
      if (61 === i.charCodeAt(n)) {
        n++, ignored(), a3 = value(true);
      }
      ignored(), e3.push({
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: r
        },
        type: t3,
        defaultValue: a3,
        directives: directives(true)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), e3;
  }
}
function fragmentDefinition() {
  var e3 = nameNode();
  if (111 !== i.charCodeAt(n++) || 110 !== i.charCodeAt(n++)) {
    throw error("FragmentDefinition");
  }
  return ignored(), {
    kind: "FragmentDefinition",
    name: e3,
    typeCondition: {
      kind: "NamedType",
      name: nameNode()
    },
    directives: directives(false),
    selectionSet: selectionSetStart()
  };
}
function definitions() {
  var e3 = [];
  do {
    if (123 === i.charCodeAt(n)) {
      n++, ignored(), e3.push({
        kind: "OperationDefinition",
        operation: "query",
        name: void 0,
        variableDefinitions: void 0,
        directives: void 0,
        selectionSet: selectionSet()
      });
    } else {
      var r = name();
      switch (r) {
        case "fragment":
          e3.push(fragmentDefinition());
          break;
        case "query":
        case "mutation":
        case "subscription":
          var t3;
          var a3 = void 0;
          if (40 !== (t3 = i.charCodeAt(n)) && 64 !== t3 && 123 !== t3) {
            a3 = nameNode();
          }
          e3.push({
            kind: "OperationDefinition",
            operation: r,
            name: a3,
            variableDefinitions: variableDefinitions(),
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        default:
          throw error("Document");
      }
    }
  } while (n < i.length);
  return e3;
}
function parse2(e3, r) {
  if (i = e3.body ? e3.body : e3, n = 0, ignored(), r && r.noLocation) {
    return {
      kind: "Document",
      definitions: definitions()
    };
  } else {
    return {
      kind: "Document",
      definitions: definitions(),
      loc: {
        start: 0,
        end: i.length,
        startToken: void 0,
        endToken: void 0,
        source: {
          body: i,
          name: "graphql.web",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      }
    };
  }
}

// node_modules/gql.tada/dist/gql-tada.mjs
var a2 = 0;
var e2 = /* @__PURE__ */ new Set();
function initGraphQLTada() {
  function graphql3(t3, i2) {
    var o2 = parse2(t3).definitions;
    var s = /* @__PURE__ */ new Set();
    for (var f of i2 || []) {
      for (var u of f.definitions) {
        if (u.kind === e.FRAGMENT_DEFINITION && !s.has(u)) {
          o2.push(u);
          s.add(u);
        }
      }
    }
    var d;
    if ((d = o2[0].kind === e.FRAGMENT_DEFINITION) && o2[0].directives) {
      o2[0].directives = o2[0].directives.filter((r) => "_unmask" !== r.name.value);
    }
    var c;
    return {
      kind: e.DOCUMENT,
      definitions: o2,
      get loc() {
        if (!c && d) {
          var r = t3 + function concatLocSources(r2) {
            try {
              a2++;
              var n2 = "";
              for (var t4 of r2) {
                if (!e2.has(t4)) {
                  e2.add(t4);
                  var { loc: i3 } = t4;
                  if (i3) {
                    n2 += i3.source.body;
                  }
                }
              }
              return n2;
            } finally {
              if (0 == --a2) {
                e2.clear();
              }
            }
          }(i2 || []);
          return {
            start: 0,
            end: r.length,
            source: {
              body: r,
              name: "GraphQLTada",
              locationOffset: {
                line: 1,
                column: 1
              }
            }
          };
        }
        return c;
      },
      set loc(r) {
        c = r;
      }
    };
  }
  graphql3.scalar = function scalar(r, n2) {
    return n2;
  };
  graphql3.persisted = function persisted(n2, a3) {
    return {
      kind: e.DOCUMENT,
      definitions: a3 ? a3.definitions : [],
      documentId: n2
    };
  };
  return graphql3;
}
var t2 = initGraphQLTada();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/graphql/schemas/2024.4/index.js
var graphql2 = initGraphQLTada();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i2 = 0; i2 < base64UrlString.length; i2++) {
    const base64UrlChar = base64UrlString.charAt(i2);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i2) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i2 % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i2}))`);
  }
  const lastCharOffset = (i2 + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i2}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i22 = 0; i22 < bits.length; i22 += 8) {
    const bitChunk = bits.slice(i22, i22 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name2, value2] = verifyExtendedClaim(extendedClaim);
  if (name2 !== claimName) {
    throw new Error(`Invalid field name: found ${name2} expected ${claimName}`);
  }
  return value2;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.vector(bcs.u8())
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/signature.js
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromB64(signature) : signature);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/utils.js
function toPaddedBigEndianBytes(num2, width) {
  const hex2 = num2.toString(16);
  return hexToBytes(hex2.padStart(width * 2, "0").slice(-width * 2));
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/zklogin/publickey.js
var __accessCheck6 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet6 = (obj, member, getter) => {
  __accessCheck6(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd6 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet6 = (obj, member, value2, setter) => {
  __accessCheck6(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var _data;
var _client;
var ZkLoginPublicIdentifier = class extends PublicKey2 {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value2, { client } = {}) {
    super();
    __privateAdd6(this, _data, void 0);
    __privateAdd6(this, _client, void 0);
    __privateSet6(this, _client, client);
    if (typeof value2 === "string") {
      __privateSet6(this, _data, fromB64(value2));
    } else if (value2 instanceof Uint8Array) {
      __privateSet6(this, _data, value2);
    } else {
      __privateSet6(this, _data, Uint8Array.from(value2));
    }
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet6(this, _data);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    return graphqlVerifyZkLoginSignature({
      address: parsedSignature.zkLogin.address,
      bytes: toB64(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PERSONAL_MESSAGE",
      client: __privateGet6(this, _client)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided TransactionBlock
   */
  verifyTransactionBlock(transactionBlock, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    return graphqlVerifyZkLoginSignature({
      address: parsedSignature.zkLogin.address,
      bytes: toB64(transactionBlock),
      signature: parsedSignature.serializedSignature,
      intentScope: "TRANSACTION_DATA",
      client: __privateGet6(this, _client)
    });
  }
};
_data = /* @__PURE__ */ new WeakMap();
_client = /* @__PURE__ */ new WeakMap();
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(iss);
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
var VerifyZkLoginSignatureQuery = graphql2(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
async function graphqlVerifyZkLoginSignature({
  address,
  bytes,
  signature,
  intentScope,
  client = new SuiGraphQLClient({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  var _a2, _b;
  const resp = await client.query({
    query: VerifyZkLoginSignatureQuery,
    variables: {
      bytes,
      signature,
      intentScope,
      author: address
    }
  });
  return ((_a2 = resp.data) == null ? void 0 : _a2.verifyZkloginSignature.success) === true && ((_b = resp.data) == null ? void 0 : _b.verifyZkloginSignature.errors.length) === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes = typeof signature === "string" ? fromB64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  const address = publicIdentifer.toSuiAddress();
  return {
    serializedSignature: toB64(bytes),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      address,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toB64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromB64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value2 >> _32n & _u32_max);
  const wl = Number(value2 & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a3, b2, c) {
  return a3 & b2 ^ ~a3 & c;
}
function Maj(a3, b2, c) {
  return a3 & b2 ^ a3 & c ^ b2 & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to2.length = length;
    to2.pos = pos;
    to2.finished = finished;
    to2.destroyed = destroyed;
    if (length % blockLen)
      to2.buffer.set(buffer);
    return to2;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C: C2, D, E, F: F2, G, H } = this;
    return [A, B, C2, D, E, F2, G, H];
  }
  // prettier-ignore
  set(A, B, C2, D, E, F2, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C2 | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C: C2, D, E, F: F2, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F2, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C2) | 0;
      H = G;
      G = F2;
      F2 = E;
      E = D + T1 | 0;
      D = C2;
      C2 = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C2 = C2 + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C2, D, E, F2, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@scure/base/lib/esm/index.js
function isBytes(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a3) => a3;
  const wrap2 = (a3, b2) => (c) => a3(b2(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap2, id);
  const decode = args.map((x) => x.decode).reduce(wrap2, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i2) => [l, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join2(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to2) => {
      astr("join.decode", to2);
      return to2.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  afn(fn2);
  return { encode: (from) => from, decode: (to2) => fn2(to2) };
}
function convertRadix(data, from, to2) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to2 < 2)
    throw new Error(`convertRadix: invalid to=${to2}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to2;
      carry = digitBase % to2;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to2 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a3, b2) => b2 === 0 ? a3 : gcd(b2, a3 % b2);
var radix2carry = (from, to2) => from + (to2 - gcd(from, to2));
var powers = (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix2(data, from, to2, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to2 <= 0 || to2 > 32)
    throw new Error(`convertRadix2: wrong to=${to2}`);
  if (radix2carry(from, to2) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to2} carryBits=${radix2carry(from, to2)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask2 = powers[to2] - 1;
  const res = [];
  for (const n2 of data) {
    anumber2(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to2; pos -= to2)
      res.push((carry >> pos - to2 & mask2) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to2 - pos & mask2;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num2) {
  anumber2(num2);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num2);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num2, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e3) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join2(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join2(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join2(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join2(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join2(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join2(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b2 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b2 >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join2(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/cryptography/keypair.js
var import_bech32 = __toESM(require_dist(), 1);
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toB64(bytes)
    };
  }
  /**
   * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransactionBlock(bytes) {
    return this.signWithIntent(bytes, IntentScope2.TransactionData);
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    return this.signWithIntent(
      bcs.vector(bcs.u8()).serialize(bytes).toBytes(),
      IntentScope2.PersonalMessage
    );
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/ed25519/publickey.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromB64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return import_tweetnacl.default.sign.detached.verify(message, bytes, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes2,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes2,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes2(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value2) {
  if (typeof value2 !== "boolean")
    throw new Error(title + " boolean expected, got " + value2);
}
var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes) {
  abytes2(bytes);
  let hex2 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex2 += hexes[bytes[i2]];
  }
  return hex2;
}
function numberToHexUnpadded(num2) {
  const hex2 = num2.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai = 0, hi2 = 0; ai < al; ai++, hi2 += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi2));
    const n2 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai] = n1 * 16 + n2;
  }
  return array2;
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes2(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes2(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e3) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e3);
    }
  } else if (isBytes2(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    abytes2(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    res.set(a3, pad);
    pad += a3.length;
  }
  return res;
}
function equalBytes(a3, b2) {
  if (a3.length !== b2.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a3.length; i2++)
    diff |= a3[i2] ^ b2[i2];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n;
}
function bitSet(n2, pos, value2) {
  return n2 | (value2 ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n2) => (_2n << BigInt(n2 - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object2;
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn2) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a3, b2) {
  const result = a3 % b2;
  return result >= _0n2 ? result : b2 + result;
}
function pow(num2, power, modulo) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n2)
    throw new Error("invalid modulus");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num2 % modulo;
    num2 = num2 * num2 % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a3 = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a3 !== _0n2) {
    const q2 = b2 / a3;
    const r = b2 % a3;
    const m = x - u * q2;
    const n2 = y - v * q2;
    b2 = a3, a3 = r, x = u, y = v, u = m, v = n2;
  }
  const gcd2 = b2;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++) {
    if (Z > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp, n2) {
      const root = Fp.pow(n2, p1div4);
      if (!Fp.eql(Fp.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp, n2) {
    if (Fp.pow(n2, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n2, Q1div2);
    let b2 = Fp.pow(n2, Q);
    while (!Fp.eql(b2, Fp.ONE)) {
      if (Fp.eql(b2, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t22 = Fp.sqr(b2); m < r; m++) {
        if (Fp.eql(t22, Fp.ONE))
          break;
        t22 = Fp.sqr(t22);
      }
      const ge2 = Fp.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp.sqr(ge2);
      x = Fp.mul(x, ge2);
      b2 = Fp.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp, n2) {
      const root = Fp.pow(n2, p1div4);
      if (!Fp.eql(Fp.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n2) {
      const n22 = Fp.mul(n2, _2n2);
      const v = Fp.pow(n22, c1);
      const nv = Fp.mul(n2, v);
      const i2 = Fp.mul(Fp.mul(nv, _2n2), v);
      const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num2;
  let p = f.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i2) => {
    if (f.is0(num2))
      return acc;
    tmp[i2] = acc;
    return f.mul(acc, num2);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num2, i2) => {
    if (f.is0(num2))
      return acc;
    tmp[i2] = f.mul(acc, tmp[i2]);
    return f.mul(acc, num2);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f, num2, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: redef.sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n2);
    }),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a3, b2, c) => c ? b2 : a3,
    toBytes: (num2) => isLE ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W2, bits) {
  if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
}
function calcWOpts(W2, bits) {
  validateW(W2, bits);
  const windows = Math.ceil(bits / W2) + 1;
  const windowSize = 2 ** (W2 - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i2) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n2, p = c.ZERO) {
      let d = elm;
      while (n2 > _0n3) {
        if (n2 & _1n3)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      let p = c.ZERO;
      let f = c.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W2, precomputes, n2, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        if (n2 === _0n3)
          break;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n3;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W2, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W2);
        if (W2 !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n2, transform) {
      const W2 = getW(P);
      return this.wNAF(W2, this.getPrecomputes(W2, P, transform), n2);
    },
    wNAFCachedUnsafe(P, n2, transform, prev) {
      const W2 = getW(P);
      if (W2 === 1)
        return this.unsafeLadder(P, n2, prev);
      return this.wNAFUnsafe(W2, this.getPrecomputes(W2, P, transform), n2, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W2) {
      validateW(W2, bits);
      pointWindowSizes.set(P, W2);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a: a3 } = opts;
  if (endo) {
    if (!Fp.eql(a3, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t3 = numberToHexUnpadded(tag);
      return t3 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b2 of lengthBytes)
          length = length << 8 | b2;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num2);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return b2n(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes2(data);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs2 = tlv.encode(2, int.encode(sig.r));
    const ss2 = tlv.encode(2, int.encode(sig.s));
    const seq = rs2 + ss2;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const Fn2 = Field(CURVE.n, CURVE.nBitLength);
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a3 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a3.x), Fp.toBytes(a3.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a: a3, b: b2 } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a3)), b2);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num2) {
    return inRange(num2, _1n4, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error2) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num2 = mod(num2, N);
    aInRange("private key", num2, _1n4, N);
    return num2;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z2 } = p;
    if (Fp.eql(z2, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z2);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z2, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp.eql(i2, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a3, b: b2 } = CURVE;
      const b3 = Fp.mul(b2, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t22 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a3, Z3);
      Y3 = Fp.mul(b3, t22);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t22 = Fp.mul(a3, t22);
      t3 = Fp.sub(t0, t22);
      t3 = Fp.mul(a3, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t22);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t22 = Fp.mul(Y1, Z1);
      t22 = Fp.add(t22, t22);
      t0 = Fp.mul(t22, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t22, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a3 = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t22 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t22);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t22);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a3, t4);
      X3 = Fp.mul(b3, t22);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t22 = Fp.mul(a3, t22);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t22);
      t22 = Fp.sub(t0, t22);
      t22 = Fp.mul(a3, t22);
      t4 = Fp.add(t4, t22);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, n2, Point2.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n4, N);
      const I = Point2.ZERO;
      if (sc === _0n4)
        return I;
      if (this.is0() || sc === _1n4)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point2.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n4, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a3, b2) {
      const G = Point2.BASE;
      const mul = (P, a4) => a4 === _0n4 || a4 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a4) : P.multiply(a4);
      const sum = mul(this, a3).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function modN2(a3) {
    return mod(a3, CURVE_ORDER);
  }
  function invN(a3) {
    return invert(a3, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a3 = point.toAffine();
      const x = Fp.toBytes(a3.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a3.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n4, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num2) => bytesToHex2(numberToBytesBE(num2, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b2, from, to2) => bytesToNumberBE(b2.slice(from, to2));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l * 2);
      return new Signature(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r, s);
    }
    assertValidity() {
      aInRange("r", this.r, _1n4, CURVE_ORDER);
      aInRange("s", this.s, _1n4, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir2 = invN(radj);
      const u1 = modN2(-h * ir2);
      const u2 = modN2(s * ir2);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN2(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num2) {
    aInRange("num < 2^" + CURVE.nBitLength, num2, _0n4, ORDER_MASK);
    return numberToBytesBE(num2, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e3 = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q2 = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q2.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q2.x === r ? 0 : 2) | Number(q2.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point2.fromHex(publicKey);
    } catch (error2) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is3 = invN(s);
    const u1 = modN2(h * is3);
    const u2 = modN2(r * is3);
    const R = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp, Z) {
  const q2 = Fp.ORDER;
  let l = _0n4;
  for (let o2 = q2 - _1n4; o2 % _2n3 === _0n4; o2 /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q2 - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n4; i2--) {
      let tv52 = i2 - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp.sqr(v);
      const tv2 = Fp.mul(u, v);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v);
      const isQR = Fp.eql(tv3, u);
      let y = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
  if (!Fp.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, opts.Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, opts.B);
    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, opts.A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, opts.A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, opts.B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
    y = Fp.mul(tv1, u);
    y = Fp.mul(y, value2);
    x = Fp.cmov(x, tv3, isValid);
    y = Fp.cmov(y, value2, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
    y = Fp.cmov(Fp.neg(y), y, e1);
    x = Fp.div(x, tv4);
    return { x, y };
  };
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
  return { ...create3(defHash), create: create3 };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value2, length) {
  anum(value2);
  anum(length);
  if (value2 < 0 || value2 >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value2);
  const res = Array.from({ length }).fill(0);
  for (let i2 = length - 1; i2 >= 0; i2--) {
    res[i2] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a3, b2) {
  const arr = new Uint8Array(a3.length);
  for (let i2 = 0; i2 < a3.length; i2++) {
    arr[i2] = a3[i2] ^ b2[i2];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b2[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b2[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b2[i2] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash, expand, DST: _DST } = options;
  abytes2(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L2 = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e3 = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L2 * (j + i2 * m);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e3[j] = mod(os2ip(tv), p);
    }
    u[i2] = e3;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P = Point2.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a3, b2) => (a3 + b2 / _2n4) / b2;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t22 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t22, _2n4, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  Fp: Fpk1,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a22, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n2) => numberToBytesBE(n2, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a3, b2) => Point.BASE.multiplyAndAddUnsafe(Q, a3, b2);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n5, secp256k1P);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a3 = ensureBytes("auxRand", auxRand, 32);
  const t3 = numTo32b(d ^ num(taggedHash("BIP0340/aux", a3)));
  const rand = taggedHash("BIP0340/nonce", t3, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e3 = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e3 * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n5, secp256k1P))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n5, secp256k1N))
      return false;
    const e3 = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e3));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error2) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/secp256k1/publickey.js
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromB64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256k1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256k1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256k1.verify(
      secp256k1.Signature.fromCompact(bytes),
      sha256(message),
      this.toRawBytes()
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// node_modules/@noble/curves/esm/p256.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp256.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  // Equation params: a, b
  b: CURVE_B,
  Fp: Fp256,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var mapSWU2 = (() => mapToCurveSimpleSWU(Fp256, {
  A: CURVE_A,
  B: CURVE_B,
  Z: Fp256.create(BigInt("-10"))
}))();
var htf2 = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU2(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromB64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha256(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/multisig/signer.js
var __accessCheck7 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet7 = (obj, member, getter) => {
  __accessCheck7(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd7 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet7 = (obj, member, value2, setter) => {
  __accessCheck7(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var _pubkey;
var _signers;
var MultiSigSigner = class extends Signer {
  constructor(pubkey, signers = []) {
    var _a2;
    super();
    __privateAdd7(this, _pubkey, void 0);
    __privateAdd7(this, _signers, void 0);
    __privateSet7(this, _pubkey, pubkey);
    __privateSet7(this, _signers, signers);
    let uniqueKeys = /* @__PURE__ */ new Set();
    let combinedWeight = 0;
    const weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({
      weight,
      address: publicKey.toSuiAddress()
    }));
    for (let signer of signers) {
      const address = signer.toSuiAddress();
      if (uniqueKeys.has(address)) {
        throw new Error(`Can't create MultiSigSigner with duplicate signers`);
      }
      uniqueKeys.add(address);
      const weight = (_a2 = weights.find((w) => w.address === address)) == null ? void 0 : _a2.weight;
      if (!weight) {
        throw new Error(`Signer ${address} is not part of the MultiSig public key`);
      }
      combinedWeight += weight;
    }
    if (combinedWeight < pubkey.getThreshold()) {
      throw new Error(`Combined weight of signers is less than threshold`);
    }
  }
  getKeyScheme() {
    return "MultiSig";
  }
  getPublicKey() {
    return __privateGet7(this, _pubkey);
  }
  sign(_data2) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransactionBlock or signPersonalMessage instead"
    );
  }
  signData(_data2) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransactionBlock or signPersonalMessage instead"
    );
  }
  async signTransactionBlock(bytes) {
    const signature = __privateGet7(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet7(this, _signers).map(async (signer) => (await signer.signTransactionBlock(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toB64(bytes)
    };
  }
  async signPersonalMessage(bytes) {
    const signature = __privateGet7(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet7(this, _signers).map(async (signer) => (await signer.signPersonalMessage(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toB64(bytes)
    };
  }
};
_pubkey = /* @__PURE__ */ new WeakMap();
_signers = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/multisig/publickey.js
var MAX_SIGNER_IN_MULTISIG = 10;
var MIN_SIGNER_IN_MULTISIG = 1;
var MultiSigPublicKey2 = class _MultiSigPublicKey extends PublicKey2 {
  /**
   * Create a new MultiSigPublicKey object
   */
  constructor(value2, options = {}) {
    super();
    if (typeof value2 === "string") {
      this.rawBytes = fromB64(value2);
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else if (value2 instanceof Uint8Array) {
      this.rawBytes = value2;
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else {
      this.multisigPublicKey = value2;
      this.rawBytes = suiBcs.MultiSigPublicKey.serialize(value2).toBytes();
    }
    if (this.multisigPublicKey.threshold < 1) {
      throw new Error("Invalid threshold");
    }
    const seenPublicKeys = /* @__PURE__ */ new Set();
    this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {
      const [scheme, bytes] = Object.entries(pubKey)[0];
      const publicKeyStr = Uint8Array.from(bytes).toString();
      if (seenPublicKeys.has(publicKeyStr)) {
        throw new Error(`Multisig does not support duplicate public keys`);
      }
      seenPublicKeys.add(publicKeyStr);
      if (weight < 1) {
        throw new Error(`Invalid weight`);
      }
      return {
        publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),
        weight
      };
    });
    const totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);
    if (this.multisigPublicKey.threshold > totalWeight) {
      throw new Error(`Unreachable threshold`);
    }
    if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {
      throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);
    }
  }
  /**
   * 	A static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.
   */
  static fromPublicKeys({
    threshold,
    publicKeys
  }) {
    return new _MultiSigPublicKey({
      pk_map: publicKeys.map(({ publicKey, weight }) => {
        const scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()];
        return {
          pubKey: { [scheme]: Array.from(publicKey.toRawBytes()) },
          weight
        };
      }),
      threshold
    });
  }
  /**
   * Checks if two MultiSig public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the MultiSig public key
   */
  toRawBytes() {
    return this.rawBytes;
  }
  getPublicKeys() {
    return this.publicKeys;
  }
  getThreshold() {
    return this.multisigPublicKey.threshold;
  }
  getSigner(...signers) {
    return new MultiSigSigner(this, signers);
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  toSuiAddress() {
    const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;
    const tmp = new Uint8Array(maxLength);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(suiBcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);
    let i2 = 3;
    for (const { publicKey, weight } of this.publicKeys) {
      const bytes = publicKey.toSuiBytes();
      tmp.set(bytes, i2);
      i2 += bytes.length;
      tmp.set([weight], i2++);
    }
    return normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i2), { dkLen: 32 })));
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["MultiSig"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, multisigSignature) {
    const parsed = parseSerializedSignature(multisigSignature);
    if (parsed.signatureScheme !== "MultiSig") {
      throw new Error("Invalid signature scheme");
    }
    const { multisig } = parsed;
    let signatureWeight = 0;
    if (!bytesEqual(
      suiBcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),
      suiBcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes()
    )) {
      return false;
    }
    for (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {
      if (!await publicKey.verify(message, signature)) {
        return false;
      }
      signatureWeight += weight;
    }
    return signatureWeight >= this.multisigPublicKey.threshold;
  }
  /**
   * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once
   * and that all the public keys involved are known and valid, and then serializes multisig into the standard format
   */
  combinePartialSignatures(signatures) {
    var _a2, _b;
    if (signatures.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    let bitmap = 0;
    const compressedSignatures = new Array(signatures.length);
    for (let i2 = 0; i2 < signatures.length; i2++) {
      let parsed = parseSerializedSignature(signatures[i2]);
      if (parsed.signatureScheme === "MultiSig") {
        throw new Error("MultiSig is not supported inside MultiSig");
      }
      let publicKey;
      if (parsed.signatureScheme === "ZkLogin") {
        publicKey = toZkLoginPublicIdentifier(
          (_a2 = parsed.zkLogin) == null ? void 0 : _a2.addressSeed,
          (_b = parsed.zkLogin) == null ? void 0 : _b.iss
        ).toRawBytes();
      } else {
        publicKey = parsed.publicKey;
      }
      compressedSignatures[i2] = {
        [parsed.signatureScheme]: Array.from(parsed.signature.map((x) => Number(x)))
      };
      let publicKeyIndex;
      for (let j = 0; j < this.publicKeys.length; j++) {
        if (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {
          if (bitmap & 1 << j) {
            throw new Error("Received multiple signatures from the same public key");
          }
          publicKeyIndex = j;
          break;
        }
      }
      if (publicKeyIndex === void 0) {
        throw new Error("Received signature from unknown public key");
      }
      bitmap |= 1 << publicKeyIndex;
    }
    let multisig = {
      sigs: compressedSignatures,
      bitmap,
      multisig_pk: this.multisigPublicKey
    };
    const bytes = suiBcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();
    let tmp = new Uint8Array(bytes.length + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(bytes, 1);
    return toB64(tmp);
  }
};
function parsePartialSignatures(multisig, options = {}) {
  let res = new Array(multisig.sigs.length);
  for (let i2 = 0; i2 < multisig.sigs.length; i2++) {
    const [signatureScheme, signature] = Object.entries(multisig.sigs[i2])[0];
    const pkIndex = asIndices(multisig.bitmap).at(i2);
    const pair = multisig.multisig_pk.pk_map[pkIndex];
    const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);
    if (signatureScheme === "MultiSig") {
      throw new Error("MultiSig is not supported inside MultiSig");
    }
    const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);
    res[i2] = {
      signatureScheme,
      signature: Uint8Array.from(signature),
      publicKey,
      weight: pair.weight
    };
  }
  return res;
}
function asIndices(bitmap) {
  if (bitmap < 0 || bitmap > 1024) {
    throw new Error("Invalid bitmap");
  }
  let res = [];
  for (let i2 = 0; i2 < 10; i2++) {
    if ((bitmap & 1 << i2) !== 0) {
      res.push(i2);
    }
  }
  return Uint8Array.from(res);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui.js/dist/esm/verify/index.js
async function verifyPersonalMessage(message, signature, options = {}) {
  const parsedSignature = parseSignature(signature, options);
  if (!await parsedSignature.publicKey.verifyPersonalMessage(
    message,
    parsedSignature.serializedSignature
  )) {
    throw new Error(`Signature is not valid for the provided message`);
  }
  return parsedSignature.publicKey;
}
function parseSignature(signature, options = {}) {
  const parsedSignature = parseSerializedSignature(signature);
  if (parsedSignature.signatureScheme === "MultiSig") {
    return {
      ...parsedSignature,
      publicKey: new MultiSigPublicKey2(parsedSignature.multisig.multisig_pk)
    };
  }
  const publicKey = publicKeyFromRawBytes(
    parsedSignature.signatureScheme,
    parsedSignature.publicKey,
    options
  );
  return {
    ...parsedSignature,
    publicKey
  };
}
function publicKeyFromRawBytes(signatureScheme, bytes, options = {}) {
  switch (signatureScheme) {
    case "ED25519":
      return new Ed25519PublicKey(bytes);
    case "Secp256k1":
      return new Secp256k1PublicKey(bytes);
    case "Secp256r1":
      return new Secp256r1PublicKey(bytes);
    case "MultiSig":
      return new MultiSigPublicKey2(bytes);
    case "ZkLogin":
      return new ZkLoginPublicIdentifier(bytes, options);
    default:
      throw new Error(`Unsupported signature scheme ${signatureScheme}`);
  }
}

// node_modules/@suiet/wallet-kit/dist/index.js
var import_react_dom = __toESM(require_react_dom());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var ui = Object.defineProperty;
var ci = (e3, t3, n2) => t3 in e3 ? ui(e3, t3, { enumerable: true, configurable: true, writable: true, value: n2 }) : e3[t3] = n2;
var ce = (e3, t3, n2) => (ci(e3, typeof t3 != "symbol" ? t3 + "" : t3, n2), n2);
var li = class extends TypeError {
  constructor(t3, n2) {
    let r;
    const { message: o2, explanation: s, ...l } = t3, { path: u } = t3, f = u.length === 0 ? o2 : `At path: ${u.join(".")} -- ${o2}`;
    super(s ?? f), s != null && (this.cause = f), Object.assign(this, l), this.name = this.constructor.name, this.failures = () => r ?? (r = [t3, ...n2()]);
  }
};
function fi(e3) {
  return Me(e3) && typeof e3[Symbol.iterator] == "function";
}
function Me(e3) {
  return typeof e3 == "object" && e3 != null;
}
function Ne(e3) {
  return typeof e3 == "symbol" ? e3.toString() : typeof e3 == "string" ? JSON.stringify(e3) : `${e3}`;
}
function di(e3) {
  const { done: t3, value: n2 } = e3.next();
  return t3 ? void 0 : n2;
}
function hi(e3, t3, n2, r) {
  if (e3 === true)
    return;
  e3 === false ? e3 = {} : typeof e3 == "string" && (e3 = { message: e3 });
  const { path: o2, branch: s } = t3, { type: l } = n2, { refinement: u, message: f = `Expected a value of type \`${l}\`${u ? ` with refinement \`${u}\`` : ""}, but received: \`${Ne(r)}\`` } = e3;
  return {
    value: r,
    type: l,
    refinement: u,
    key: o2[o2.length - 1],
    path: o2,
    branch: s,
    ...e3,
    message: f
  };
}
function* Qn(e3, t3, n2, r) {
  fi(e3) || (e3 = [e3]);
  for (const o2 of e3) {
    const s = hi(o2, t3, n2, r);
    s && (yield s);
  }
}
function* In(e3, t3, n2 = {}) {
  const { path: r = [], branch: o2 = [e3], coerce: s = false, mask: l = false } = n2, u = { path: r, branch: o2 };
  if (s && (e3 = t3.coercer(e3, u), l && t3.type !== "type" && Me(t3.schema) && Me(e3) && !Array.isArray(e3)))
    for (const h in e3)
      t3.schema[h] === void 0 && delete e3[h];
  let f = "valid";
  for (const h of t3.validator(e3, u))
    h.explanation = n2.message, f = "not_valid", yield [h, void 0];
  for (let [h, p, y] of t3.entries(e3, u)) {
    const A = In(p, y, {
      path: h === void 0 ? r : [...r, h],
      branch: h === void 0 ? o2 : [...o2, p],
      coerce: s,
      mask: l,
      message: n2.message
    });
    for (const v of A)
      v[0] ? (f = v[0].refinement != null ? "not_refined" : "not_valid", yield [v[0], void 0]) : s && (p = v[1], h === void 0 ? e3 = p : e3 instanceof Map ? e3.set(h, p) : e3 instanceof Set ? e3.add(p) : Me(e3) && (p !== void 0 || h in e3) && (e3[h] = p));
  }
  if (f !== "not_valid")
    for (const h of t3.refiner(e3, u))
      h.explanation = n2.message, f = "not_refined", yield [h, void 0];
  f === "valid" && (yield [void 0, e3]);
}
var De = class {
  constructor(t3) {
    const { type: n2, schema: r, validator: o2, refiner: s, coercer: l = (f) => f, entries: u = function* () {
    } } = t3;
    this.type = n2, this.schema = r, this.entries = u, this.coercer = l, o2 ? this.validator = (f, h) => {
      const p = o2(f, h);
      return Qn(p, h, this, f);
    } : this.validator = () => [], s ? this.refiner = (f, h) => {
      const p = s(f, h);
      return Qn(p, h, this, f);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t3, n2) {
    return gi(t3, this, n2);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t3, n2) {
    return pi(t3, this, n2);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t3) {
    return Mi(t3, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t3, n2) {
    return yi(t3, this, n2);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t3, n2 = {}) {
    return ft(t3, this, n2);
  }
};
function gi(e3, t3, n2) {
  const r = ft(e3, t3, { message: n2 });
  if (r[0])
    throw r[0];
}
function pi(e3, t3, n2) {
  const r = ft(e3, t3, { coerce: true, message: n2 });
  if (r[0])
    throw r[0];
  return r[1];
}
function yi(e3, t3, n2) {
  const r = ft(e3, t3, { coerce: true, mask: true, message: n2 });
  if (r[0])
    throw r[0];
  return r[1];
}
function Mi(e3, t3) {
  return !ft(e3, t3)[0];
}
function ft(e3, t3, n2 = {}) {
  const r = In(e3, t3, n2), o2 = di(r);
  return o2[0] ? [new li(o2[0], function* () {
    for (const s of r)
      s[0] && (yield s[0]);
  }), void 0] : [void 0, o2[1]];
}
function at(...e3) {
  const t3 = e3[0].type === "type", n2 = e3.map((o2) => o2.schema), r = Object.assign({}, ...n2);
  return t3 ? Ni(r) : L(r);
}
function Be(e3, t3) {
  return new De({ type: e3, schema: null, validator: t3 });
}
function vi() {
  return Be("any", () => true);
}
function bn(e3) {
  return new De({
    type: "array",
    schema: e3,
    *entries(t3) {
      if (e3 && Array.isArray(t3))
        for (const [n2, r] of t3.entries())
          yield [n2, r, e3];
    },
    coercer(t3) {
      return Array.isArray(t3) ? t3.slice() : t3;
    },
    validator(t3) {
      return Array.isArray(t3) || `Expected an array value, but received: ${Ne(t3)}`;
    }
  });
}
function mi() {
  return Be("bigint", (e3) => typeof e3 == "bigint");
}
function Ae() {
  return Be("boolean", (e3) => typeof e3 == "boolean");
}
function fe(e3) {
  const t3 = Ne(e3), n2 = typeof e3;
  return new De({
    type: "literal",
    schema: n2 === "string" || n2 === "number" || n2 === "boolean" ? e3 : null,
    validator(r) {
      return r === e3 || `Expected the literal \`${t3}\`, but received: ${Ne(r)}`;
    }
  });
}
function hr() {
  return Be("never", () => false);
}
function V(e3) {
  return new De({
    ...e3,
    validator: (t3, n2) => t3 === null || e3.validator(t3, n2),
    refiner: (t3, n2) => t3 === null || e3.refiner(t3, n2)
  });
}
function ot() {
  return Be("number", (e3) => typeof e3 == "number" && !isNaN(e3) || `Expected a number, but received: ${Ne(e3)}`);
}
function L(e3) {
  const t3 = e3 ? Object.keys(e3) : [], n2 = hr();
  return new De({
    type: "object",
    schema: e3 || null,
    *entries(r) {
      if (e3 && Me(r)) {
        const o2 = new Set(Object.keys(r));
        for (const s of t3)
          o2.delete(s), yield [s, r[s], e3[s]];
        for (const s of o2)
          yield [s, r[s], n2];
      }
    },
    validator(r) {
      return Me(r) || `Expected an object, but received: ${Ne(r)}`;
    },
    coercer(r) {
      return Me(r) ? { ...r } : r;
    }
  });
}
function F(e3) {
  return new De({
    ...e3,
    validator: (t3, n2) => t3 === void 0 || e3.validator(t3, n2),
    refiner: (t3, n2) => t3 === void 0 || e3.refiner(t3, n2)
  });
}
function _e(e3, t3) {
  return new De({
    type: "record",
    schema: null,
    *entries(n2) {
      if (Me(n2))
        for (const r in n2) {
          const o2 = n2[r];
          yield [r, r, e3], yield [r, o2, t3];
        }
    },
    validator(n2) {
      return Me(n2) || `Expected an object, but received: ${Ne(n2)}`;
    }
  });
}
function C() {
  return Be("string", (e3) => typeof e3 == "string" || `Expected a string, but received: ${Ne(e3)}`);
}
function Ai(e3) {
  const t3 = hr();
  return new De({
    type: "tuple",
    schema: null,
    *entries(n2) {
      if (Array.isArray(n2)) {
        const r = Math.max(e3.length, n2.length);
        for (let o2 = 0; o2 < r; o2++)
          yield [o2, n2[o2], e3[o2] || t3];
      }
    },
    validator(n2) {
      return Array.isArray(n2) || `Expected an array, but received: ${Ne(n2)}`;
    }
  });
}
function Ni(e3) {
  const t3 = Object.keys(e3);
  return new De({
    type: "type",
    schema: e3,
    *entries(n2) {
      if (Me(n2))
        for (const r of t3)
          yield [r, n2[r], e3[r]];
    },
    validator(n2) {
      return Me(n2) || `Expected an object, but received: ${Ne(n2)}`;
    },
    coercer(n2) {
      return Me(n2) ? { ...n2 } : n2;
    }
  });
}
function xe(e3) {
  const t3 = e3.map((n2) => n2.type).join(" | ");
  return new De({
    type: "union",
    schema: null,
    coercer(n2) {
      for (const r of e3) {
        const [o2, s] = r.validate(n2, { coerce: true });
        if (!o2)
          return s;
      }
      return n2;
    },
    validator(n2, r) {
      const o2 = [];
      for (const s of e3) {
        const [...l] = In(n2, s, r), [u] = l;
        if (u[0])
          for (const [f] of l)
            f && o2.push(f);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t3}\`, but received: ${Ne(n2)}`,
        ...o2
      ];
    }
  });
}
function Ii() {
  return Be("unknown", () => true);
}
var wn = xe([
  L({
    AddressOwner: C()
  }),
  L({
    ObjectOwner: C()
  }),
  L({
    Shared: L({
      initial_shared_version: V(C())
    })
  }),
  fe("Immutable")
]);
Be("SuiJsonValue", () => true);
var bi = xe([
  L({ u32: C() }),
  L({ u64: C() }),
  L({ f64: C() })
]);
L({
  attributes: _e(C(), V(bi)),
  featureFlags: _e(C(), Ae()),
  maxSupportedProtocolVersion: C(),
  minSupportedProtocolVersion: C(),
  protocolVersion: C()
});
xe([C(), fe("package")]);
var Bt = L({
  /** Base64 string representing the object digest */
  digest: C(),
  /** Hex code as string representing the object id */
  objectId: C(),
  /** Object version */
  version: xe([ot(), C(), mi()])
});
L({
  owner: wn,
  reference: Bt
});
L({
  objectId: C(),
  sequenceNumber: C()
});
L({
  payment: bn(Bt),
  /** Gas Object's owner */
  owner: C(),
  price: C(),
  budget: C()
});
var wi = at(
  Bt,
  L({
    type: C(),
    owner: wn,
    previousTransaction: C()
  })
);
var Ei = _e(C(), vi());
var Di = _e(C(), Ii());
var Ci = L({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: C(),
  /** Fields and values stored inside the Move object */
  fields: Ei,
  hasPublicTransfer: Ae()
});
var Ti = L({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: Di
});
var ji = xe([
  at(Ci, L({ dataType: fe("moveObject") })),
  at(Ti, L({ dataType: fe("package") }))
]);
var Si = L({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: C(),
  hasPublicTransfer: Ae(),
  version: C(),
  bcsBytes: C()
});
var Li = L({
  id: C(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: _e(C(), C())
});
var Oi = xe([
  at(Si, L({ dataType: fe("moveObject") })),
  at(Li, L({ dataType: fe("package") }))
]);
BigInt(1e9);
var gr = L({
  code: C(),
  error: F(C()),
  object_id: F(C()),
  parent_object_id: F(C()),
  version: F(C()),
  digest: F(C())
});
var xi = L({
  data: V(F(_e(C(), C()))),
  error: V(F(gr))
});
var Ri = xe([
  xi,
  F(_e(C(), C()))
]);
var pr = L({
  objectId: C(),
  version: C(),
  digest: C(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: V(F(C())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: V(F(ji)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: V(F(Oi)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: V(F(wn)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: V(F(C())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: V(F(C())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: V(F(Ri))
});
L({
  /* Whether to fetch the object type, default to be true */
  showType: V(F(Ae())),
  /* Whether to fetch the object content, default to be false */
  showContent: V(F(Ae())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: V(F(Ae())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: V(F(Ae())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: V(F(Ae())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: V(F(Ae())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: V(F(Ae()))
});
xe([
  fe("Exists"),
  fe("notExists"),
  fe("Deleted")
]);
bn(wi);
var Ui = L({
  data: V(F(pr)),
  error: V(F(gr))
});
function yr(e3) {
  return e3.data;
}
function Pi(e3) {
  if (e3.error && "object_id" in e3.error && "version" in e3.error && "digest" in e3.error) {
    const t3 = e3.error;
    return {
      objectId: t3.object_id,
      version: t3.version,
      digest: t3.digest
    };
  }
}
function zi(e3) {
  if (e3.error && "object_id" in e3.error && !("version" in e3.error) && !("digest" in e3.error))
    return e3.error.object_id;
}
function ki(e3) {
  if ("reference" in e3)
    return e3.reference;
  const t3 = yr(e3);
  return t3 ? {
    objectId: t3.objectId,
    version: t3.version,
    digest: t3.digest
  } : Pi(e3);
}
function Qi(e3) {
  var _a2;
  return "objectId" in e3 ? e3.objectId : ((_a2 = ki(e3)) == null ? void 0 : _a2.objectId) ?? zi(e3);
}
function Fi(e3) {
  return e3.data !== void 0;
}
function Bi(e3) {
  var _a2;
  const t3 = Fi(e3) ? e3.data : e3;
  return !(t3 == null ? void 0 : t3.type) && "data" in e3 ? ((_a2 = t3 == null ? void 0 : t3.content) == null ? void 0 : _a2.dataType) === "package" ? "package" : Wi(e3) : t3 == null ? void 0 : t3.type;
}
function Wi(e3) {
  var _a2;
  return (_a2 = Mr(e3)) == null ? void 0 : _a2.type;
}
function Yi(e3) {
  var _a2;
  return "fields" in e3 ? e3.fields : (_a2 = Mr(e3)) == null ? void 0 : _a2.fields;
}
function Gi(e3) {
  return e3.content !== void 0;
}
function Mr(e3) {
  const t3 = "data" in e3 ? yr(e3) : e3;
  if (!(!t3 || !Gi(t3) || t3.content.dataType !== "moveObject"))
    return t3.content;
}
L({
  objectId: C(),
  atCheckpoint: F(ot())
});
L({
  data: bn(Ui),
  nextCursor: F(V(C())),
  hasNextPage: Ae()
});
xe([
  L({
    details: pr,
    status: fe("VersionFound")
  }),
  L({
    details: C(),
    status: fe("ObjectNotExists")
  }),
  L({
    details: Bt,
    status: fe("ObjectDeleted")
  }),
  L({
    details: Ai([C(), ot()]),
    status: fe("VersionNotFound")
  }),
  L({
    details: L({
      asked_version: ot(),
      latest_version: ot(),
      object_id: C()
    }),
    status: fe("VersionTooHigh")
  })
]);
var _i = 32;
function Zi(e3, t3 = false) {
  let n2 = e3.toLowerCase();
  return !t3 && n2.startsWith("0x") && (n2 = n2.slice(2)), `0x${n2.padStart(_i * 2, "0")}`;
}
function Vi(e3, t3 = false) {
  return Zi(e3, t3);
}
var Fn = /^0x2::coin::Coin<(.+)>$/;
function qi(e3) {
  return !!e3.data || !!e3.type;
}
var ge = class _ge {
  static isCoin(t3) {
    var _a2;
    return ((_a2 = _ge.getType(t3)) == null ? void 0 : _a2.match(Fn)) != null;
  }
  static getCoinType(t3) {
    const [, n2] = t3.match(Fn) ?? [];
    return n2 || null;
  }
  static getCoinTypeArg(t3) {
    const n2 = _ge.getType(t3);
    return n2 ? _ge.getCoinType(n2) : null;
  }
  static isSUI(t3) {
    const n2 = _ge.getCoinTypeArg(t3);
    return n2 ? _ge.getCoinSymbol(n2) === "SUI" : false;
  }
  static getCoinSymbol(t3) {
    return t3.substring(t3.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(t3) {
    return {
      address: Vi(t3.split("::")[0]),
      module: t3.split("::")[1],
      name: t3.split("::")[2],
      typeParams: []
    };
  }
  static getID(t3) {
    return "fields" in t3 ? t3.fields.id.id : Qi(t3);
  }
  static totalBalance(t3) {
    return t3.reduce(
      (n2, r) => n2 + _ge.getBalanceFromCoinStruct(r),
      BigInt(0)
    );
  }
  /**
   * Sort coin by balance in an ascending order
   */
  static sortByBalance(t3) {
    return [...t3].sort(
      (n2, r) => _ge.getBalanceFromCoinStruct(n2) < _ge.getBalanceFromCoinStruct(r) ? -1 : _ge.getBalanceFromCoinStruct(n2) > _ge.getBalanceFromCoinStruct(r) ? 1 : 0
    );
  }
  static getBalanceFromCoinStruct(t3) {
    return BigInt(t3.balance);
  }
  static getBalance(t3) {
    var _a2;
    if (!_ge.isCoin(t3))
      return;
    const n2 = (_a2 = Yi(t3)) == null ? void 0 : _a2.balance;
    return BigInt(n2);
  }
  static getType(t3) {
    return qi(t3) ? Bi(t3) : t3.type;
  }
};
var En = class _En {
  constructor(t3, n2, r) {
    ce(this, "_objectId"), ce(this, "_typeArg"), ce(this, "_balance"), ce(this, "_symbol"), this._objectId = t3, this._balance = r, this._typeArg = n2, this._symbol = ge.getCoinSymbol(n2);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(t3) {
    return new _En(t3.objectId, t3.typeArg, t3.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
};
var me = ((e3) => (e3.DISCONNECTED = "disconnected", e3.CONNECTED = "connected", e3.CONNECTING = "connecting", e3))(me || {});
var Xi = class {
  constructor(t3) {
    ce(this, "client"), this.client = t3;
  }
  async getOwnedObjects(t3) {
    var _a2;
    let n2 = true, r = null, o2 = [];
    for (; n2; ) {
      const s = await this.client.getOwnedObjects({
        owner: t3,
        cursor: r,
        options: {
          showType: true,
          showDisplay: true,
          showContent: true,
          showOwner: true
        }
      });
      (_a2 = s.data) == null ? void 0 : _a2.forEach((l) => {
        const u = l.data;
        u && o2.push(u);
      }), n2 = s.hasNextPage, r = s.nextCursor;
    }
    return o2;
  }
  getSuiClient() {
    return this.client;
  }
  setSuiClient(t3) {
    this.client = t3;
  }
};
var Ki = class extends Xi {
  constructor(t3, n2) {
    super(t3), ce(this, "coinType"), this.coinType = n2;
  }
  /**
   * Get the coin object of one specific token type
   */
  async getOwnedCoins(t3) {
    let n2 = true, r = null, o2 = [];
    for (; n2; ) {
      const s = await this.client.getCoins({
        owner: t3,
        coinType: this.coinType,
        cursor: r
      });
      s.data.forEach((l) => {
        o2.push(
          new En(l.coinObjectId, l.coinType, BigInt(l.balance))
        );
      }), n2 = s.hasNextPage, r = s.nextCursor;
    }
    return o2;
  }
  async getBalance(t3) {
    const n2 = await this.client.getBalance({
      owner: t3,
      coinType: this.coinType
    });
    return BigInt(n2.totalBalance);
  }
};
var Hi = class {
  constructor(t3, n2) {
    ce(this, "address"), ce(this, "chainRpcUrl"), ce(this, "suiClient"), this.address = t3, this.chainRpcUrl = n2.chainRpcUrl, this.suiClient = new SuiClient({
      url: n2.chainRpcUrl
    });
  }
  getAddress() {
    return this.address;
  }
  getCoinBalance(t3) {
    return new Ki(this.suiClient, t3).getBalance(this.address);
  }
  getSuiBalance() {
    return this.getCoinBalance(SUI_TYPE_ARG);
  }
  getChainRpcUrl() {
    return this.chainRpcUrl;
  }
  setChainRpcUrl(t3) {
    this.chainRpcUrl = t3, this.suiClient = new SuiClient({
      url: t3
    });
  }
};
var Bn = 1e6;
var Xt = 1e9;
var Kt = 1e12;
function Ji(e3, t3) {
  return vr(
    e3,
    Object.assign(
      {
        decimals: 9
      },
      t3
    )
  );
}
function vr(e3, t3) {
  const { decimals: n2 = 0, withAbbr: r = true } = t3 ?? {};
  if (typeof e3 == "bigint" && !eo(e3))
    return Ar(BigInt(e3), {
      decimals: n2,
      withAbbr: r
    });
  if (Number(e3) === 0)
    return "0";
  if (Number(e3) < 0)
    return "-" + vr(-Number(e3), t3);
  const o2 = Number(e3) / 10 ** n2;
  return o2 > 0 && o2 < 1 ? $i(o2) : mr(o2, r);
}
function mr(e3, t3) {
  if (t3) {
    if (e3 >= Bn && e3 < Xt)
      return Ht(e3, Bn, "M");
    if (e3 >= Xt && e3 < Kt)
      return Ht(e3, Xt, "B");
    if (e3 >= Kt)
      return Ht(e3, Kt, "T");
  }
  return Intl.NumberFormat("en-US").format(e3);
}
function Ht(e3, t3, n2) {
  let r;
  typeof e3 == "bigint" ? r = String(e3 / (BigInt(t3) / 1000n)) : r = String(Math.floor(e3 / (t3 / 1e3)));
  const o2 = r.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(o2)).replace(",", ".") + n2;
}
function $i(e3) {
  if (e3 <= 0)
    return "0";
  const t3 = Math.ceil(-Math.log10(e3));
  return Number(e3) % Math.pow(10, 10 - (t3 + 2)) === 0 && Number(e3) % Math.pow(10, 10 - (t3 + 1)) === 0 ? Jt(e3, t3) : Number(e3) % Math.pow(10, 10 - (t3 + 2)) === 0 && Number(e3) % Math.pow(10, 10 - (t3 + 1)) !== 0 ? Jt(e3, t3 + 1) : Jt(e3, t3 + 2);
}
function Jt(e3, t3) {
  function n2(r) {
    if (isNaN(r))
      return r.toString();
    const o2 = "" + r;
    return /e/i.test(o2) ? r.toFixed(18).replace(/\.?0+$/, "") : r.toString();
  }
  return t3 = t3 || 0, t3 = Math.pow(10, t3), n2(Math.floor(e3 * t3) / t3);
}
function Ar(e3, t3) {
  if (e3 === 0n)
    return "0";
  if (e3 < 0n)
    return "-" + Ar(-e3, t3);
  const { decimals: n2 = 9, withAbbr: r = true } = t3 ?? {}, o2 = e3 / 10n ** BigInt(n2);
  return mr(o2, r);
}
function eo(e3) {
  const t3 = Number.MIN_SAFE_INTEGER, n2 = Number.MAX_SAFE_INTEGER;
  return e3 >= BigInt(t3) && e3 <= BigInt(n2);
}
function to(e3) {
  return typeof e3 != "string" ? "" : !e3 || !e3.startsWith("0x") ? e3 : e3.slice(0, 7) + "...." + e3.slice(-4, e3.length);
}
function Nr(e3) {
  return Uint8Array.from(atob(e3), (t3) => t3.charCodeAt(0));
}
var cn = {};
var Wt = {};
Wt.byteLength = io;
Wt.toByteArray = so;
Wt.fromByteArray = co;
var we = [];
var ye = [];
var no = typeof Uint8Array < "u" ? Uint8Array : Array;
var $t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (He = 0, ro = $t.length; He < ro; ++He)
  we[He] = $t[He], ye[$t.charCodeAt(He)] = He;
var He;
var ro;
ye[45] = 62;
ye[95] = 63;
function Ir(e3) {
  var t3 = e3.length;
  if (t3 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n2 = e3.indexOf("=");
  n2 === -1 && (n2 = t3);
  var r = n2 === t3 ? 0 : 4 - n2 % 4;
  return [n2, r];
}
function io(e3) {
  var t3 = Ir(e3), n2 = t3[0], r = t3[1];
  return (n2 + r) * 3 / 4 - r;
}
function oo(e3, t3, n2) {
  return (t3 + n2) * 3 / 4 - n2;
}
function so(e3) {
  var t3, n2 = Ir(e3), r = n2[0], o2 = n2[1], s = new no(oo(e3, r, o2)), l = 0, u = o2 > 0 ? r - 4 : r, f;
  for (f = 0; f < u; f += 4)
    t3 = ye[e3.charCodeAt(f)] << 18 | ye[e3.charCodeAt(f + 1)] << 12 | ye[e3.charCodeAt(f + 2)] << 6 | ye[e3.charCodeAt(f + 3)], s[l++] = t3 >> 16 & 255, s[l++] = t3 >> 8 & 255, s[l++] = t3 & 255;
  return o2 === 2 && (t3 = ye[e3.charCodeAt(f)] << 2 | ye[e3.charCodeAt(f + 1)] >> 4, s[l++] = t3 & 255), o2 === 1 && (t3 = ye[e3.charCodeAt(f)] << 10 | ye[e3.charCodeAt(f + 1)] << 4 | ye[e3.charCodeAt(f + 2)] >> 2, s[l++] = t3 >> 8 & 255, s[l++] = t3 & 255), s;
}
function ao(e3) {
  return we[e3 >> 18 & 63] + we[e3 >> 12 & 63] + we[e3 >> 6 & 63] + we[e3 & 63];
}
function uo(e3, t3, n2) {
  for (var r, o2 = [], s = t3; s < n2; s += 3)
    r = (e3[s] << 16 & 16711680) + (e3[s + 1] << 8 & 65280) + (e3[s + 2] & 255), o2.push(ao(r));
  return o2.join("");
}
function co(e3) {
  for (var t3, n2 = e3.length, r = n2 % 3, o2 = [], s = 16383, l = 0, u = n2 - r; l < u; l += s)
    o2.push(uo(e3, l, l + s > u ? u : l + s));
  return r === 1 ? (t3 = e3[n2 - 1], o2.push(
    we[t3 >> 2] + we[t3 << 4 & 63] + "=="
  )) : r === 2 && (t3 = (e3[n2 - 2] << 8) + e3[n2 - 1], o2.push(
    we[t3 >> 10] + we[t3 >> 4 & 63] + we[t3 << 2 & 63] + "="
  )), o2.join("");
}
var Dn = {};
Dn.read = function(e3, t3, n2, r, o2) {
  var s, l, u = o2 * 8 - r - 1, f = (1 << u) - 1, h = f >> 1, p = -7, y = n2 ? o2 - 1 : 0, A = n2 ? -1 : 1, v = e3[t3 + y];
  for (y += A, s = v & (1 << -p) - 1, v >>= -p, p += u; p > 0; s = s * 256 + e3[t3 + y], y += A, p -= 8)
    ;
  for (l = s & (1 << -p) - 1, s >>= -p, p += r; p > 0; l = l * 256 + e3[t3 + y], y += A, p -= 8)
    ;
  if (s === 0)
    s = 1 - h;
  else {
    if (s === f)
      return l ? NaN : (v ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, r), s = s - h;
  }
  return (v ? -1 : 1) * l * Math.pow(2, s - r);
};
Dn.write = function(e3, t3, n2, r, o2, s) {
  var l, u, f, h = s * 8 - o2 - 1, p = (1 << h) - 1, y = p >> 1, A = o2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = r ? 0 : s - 1, I = r ? 1 : -1, m = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (u = isNaN(t3) ? 1 : 0, l = p) : (l = Math.floor(Math.log(t3) / Math.LN2), t3 * (f = Math.pow(2, -l)) < 1 && (l--, f *= 2), l + y >= 1 ? t3 += A / f : t3 += A * Math.pow(2, 1 - y), t3 * f >= 2 && (l++, f /= 2), l + y >= p ? (u = 0, l = p) : l + y >= 1 ? (u = (t3 * f - 1) * Math.pow(2, o2), l = l + y) : (u = t3 * Math.pow(2, y - 1) * Math.pow(2, o2), l = 0)); o2 >= 8; e3[n2 + v] = u & 255, v += I, u /= 256, o2 -= 8)
    ;
  for (l = l << o2 | u, h += o2; h > 0; e3[n2 + v] = l & 255, v += I, l /= 256, h -= 8)
    ;
  e3[n2 + v - I] |= m * 128;
};
(function(e3) {
  const t3 = Wt, n2 = Dn, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e3.Buffer = u, e3.SlowBuffer = T, e3.INSPECT_MAX_BYTES = 50;
  const o2 = 2147483647;
  e3.kMaxLength = o2, u.TYPED_ARRAY_SUPPORT = s(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const i2 = new Uint8Array(1), a3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(a3, Uint8Array.prototype), Object.setPrototypeOf(i2, a3), i2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(i2) {
    if (i2 > o2)
      throw new RangeError('The value "' + i2 + '" is invalid for option "size"');
    const a3 = new Uint8Array(i2);
    return Object.setPrototypeOf(a3, u.prototype), a3;
  }
  function u(i2, a3, c) {
    if (typeof i2 == "number") {
      if (typeof a3 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(i2);
    }
    return f(i2, a3, c);
  }
  u.poolSize = 8192;
  function f(i2, a3, c) {
    if (typeof i2 == "string")
      return A(i2, a3);
    if (ArrayBuffer.isView(i2))
      return I(i2);
    if (i2 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i2
      );
    if (be(i2, ArrayBuffer) || i2 && be(i2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (be(i2, SharedArrayBuffer) || i2 && be(i2.buffer, SharedArrayBuffer)))
      return m(i2, a3, c);
    if (typeof i2 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const d = i2.valueOf && i2.valueOf();
    if (d != null && d !== i2)
      return u.from(d, a3, c);
    const g = w(i2);
    if (g)
      return g;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i2[Symbol.toPrimitive] == "function")
      return u.from(i2[Symbol.toPrimitive]("string"), a3, c);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i2
    );
  }
  u.from = function(i2, a3, c) {
    return f(i2, a3, c);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function h(i2) {
    if (typeof i2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i2 < 0)
      throw new RangeError('The value "' + i2 + '" is invalid for option "size"');
  }
  function p(i2, a3, c) {
    return h(i2), i2 <= 0 ? l(i2) : a3 !== void 0 ? typeof c == "string" ? l(i2).fill(a3, c) : l(i2).fill(a3) : l(i2);
  }
  u.alloc = function(i2, a3, c) {
    return p(i2, a3, c);
  };
  function y(i2) {
    return h(i2), l(i2 < 0 ? 0 : E(i2) | 0);
  }
  u.allocUnsafe = function(i2) {
    return y(i2);
  }, u.allocUnsafeSlow = function(i2) {
    return y(i2);
  };
  function A(i2, a3) {
    if ((typeof a3 != "string" || a3 === "") && (a3 = "utf8"), !u.isEncoding(a3))
      throw new TypeError("Unknown encoding: " + a3);
    const c = D(i2, a3) | 0;
    let d = l(c);
    const g = d.write(i2, a3);
    return g !== c && (d = d.slice(0, g)), d;
  }
  function v(i2) {
    const a3 = i2.length < 0 ? 0 : E(i2.length) | 0, c = l(a3);
    for (let d = 0; d < a3; d += 1)
      c[d] = i2[d] & 255;
    return c;
  }
  function I(i2) {
    if (be(i2, Uint8Array)) {
      const a3 = new Uint8Array(i2);
      return m(a3.buffer, a3.byteOffset, a3.byteLength);
    }
    return v(i2);
  }
  function m(i2, a3, c) {
    if (a3 < 0 || i2.byteLength < a3)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i2.byteLength < a3 + (c || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let d;
    return a3 === void 0 && c === void 0 ? d = new Uint8Array(i2) : c === void 0 ? d = new Uint8Array(i2, a3) : d = new Uint8Array(i2, a3, c), Object.setPrototypeOf(d, u.prototype), d;
  }
  function w(i2) {
    if (u.isBuffer(i2)) {
      const a3 = E(i2.length) | 0, c = l(a3);
      return c.length === 0 || i2.copy(c, 0, 0, a3), c;
    }
    if (i2.length !== void 0)
      return typeof i2.length != "number" || qt(i2.length) ? l(0) : v(i2);
    if (i2.type === "Buffer" && Array.isArray(i2.data))
      return v(i2.data);
  }
  function E(i2) {
    if (i2 >= o2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o2.toString(16) + " bytes");
    return i2 | 0;
  }
  function T(i2) {
    return +i2 != i2 && (i2 = 0), u.alloc(+i2);
  }
  u.isBuffer = function(i2) {
    return i2 != null && i2._isBuffer === true && i2 !== u.prototype;
  }, u.compare = function(i2, a3) {
    if (be(i2, Uint8Array) && (i2 = u.from(i2, i2.offset, i2.byteLength)), be(a3, Uint8Array) && (a3 = u.from(a3, a3.offset, a3.byteLength)), !u.isBuffer(i2) || !u.isBuffer(a3))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i2 === a3)
      return 0;
    let c = i2.length, d = a3.length;
    for (let g = 0, M = Math.min(c, d); g < M; ++g)
      if (i2[g] !== a3[g]) {
        c = i2[g], d = a3[g];
        break;
      }
    return c < d ? -1 : d < c ? 1 : 0;
  }, u.isEncoding = function(i2) {
    switch (String(i2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, u.concat = function(i2, a3) {
    if (!Array.isArray(i2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i2.length === 0)
      return u.alloc(0);
    let c;
    if (a3 === void 0)
      for (a3 = 0, c = 0; c < i2.length; ++c)
        a3 += i2[c].length;
    const d = u.allocUnsafe(a3);
    let g = 0;
    for (c = 0; c < i2.length; ++c) {
      let M = i2[c];
      if (be(M, Uint8Array))
        g + M.length > d.length ? (u.isBuffer(M) || (M = u.from(M)), M.copy(d, g)) : Uint8Array.prototype.set.call(
          d,
          M,
          g
        );
      else if (u.isBuffer(M))
        M.copy(d, g);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      g += M.length;
    }
    return d;
  };
  function D(i2, a3) {
    if (u.isBuffer(i2))
      return i2.length;
    if (ArrayBuffer.isView(i2) || be(i2, ArrayBuffer))
      return i2.byteLength;
    if (typeof i2 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i2
      );
    const c = i2.length, d = arguments.length > 2 && arguments[2] === true;
    if (!d && c === 0)
      return 0;
    let g = false;
    for (; ; )
      switch (a3) {
        case "ascii":
        case "latin1":
        case "binary":
          return c;
        case "utf8":
        case "utf-8":
          return Vt(i2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return c * 2;
        case "hex":
          return c >>> 1;
        case "base64":
          return kn(i2).length;
        default:
          if (g)
            return d ? -1 : Vt(i2).length;
          a3 = ("" + a3).toLowerCase(), g = true;
      }
  }
  u.byteLength = D;
  function P(i2, a3, c) {
    let d = false;
    if ((a3 === void 0 || a3 < 0) && (a3 = 0), a3 > this.length || ((c === void 0 || c > this.length) && (c = this.length), c <= 0) || (c >>>= 0, a3 >>>= 0, c <= a3))
      return "";
    for (i2 || (i2 = "utf8"); ; )
      switch (i2) {
        case "hex":
          return je(this, a3, c);
        case "utf8":
        case "utf-8":
          return Z(this, a3, c);
        case "ascii":
          return Te(this, a3, c);
        case "latin1":
        case "binary":
          return Ie(this, a3, c);
        case "base64":
          return k(this, a3, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return qe(this, a3, c);
        default:
          if (d)
            throw new TypeError("Unknown encoding: " + i2);
          i2 = (i2 + "").toLowerCase(), d = true;
      }
  }
  u.prototype._isBuffer = true;
  function S(i2, a3, c) {
    const d = i2[a3];
    i2[a3] = i2[c], i2[c] = d;
  }
  u.prototype.swap16 = function() {
    const i2 = this.length;
    if (i2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let a3 = 0; a3 < i2; a3 += 2)
      S(this, a3, a3 + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const i2 = this.length;
    if (i2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let a3 = 0; a3 < i2; a3 += 4)
      S(this, a3, a3 + 3), S(this, a3 + 1, a3 + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const i2 = this.length;
    if (i2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let a3 = 0; a3 < i2; a3 += 8)
      S(this, a3, a3 + 7), S(this, a3 + 1, a3 + 6), S(this, a3 + 2, a3 + 5), S(this, a3 + 3, a3 + 4);
    return this;
  }, u.prototype.toString = function() {
    const i2 = this.length;
    return i2 === 0 ? "" : arguments.length === 0 ? Z(this, 0, i2) : P.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(i2) {
    if (!u.isBuffer(i2))
      throw new TypeError("Argument must be a Buffer");
    return this === i2 ? true : u.compare(this, i2) === 0;
  }, u.prototype.inspect = function() {
    let i2 = "";
    const a3 = e3.INSPECT_MAX_BYTES;
    return i2 = this.toString("hex", 0, a3).replace(/(.{2})/g, "$1 ").trim(), this.length > a3 && (i2 += " ... "), "<Buffer " + i2 + ">";
  }, r && (u.prototype[r] = u.prototype.inspect), u.prototype.compare = function(i2, a3, c, d, g) {
    if (be(i2, Uint8Array) && (i2 = u.from(i2, i2.offset, i2.byteLength)), !u.isBuffer(i2))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i2
      );
    if (a3 === void 0 && (a3 = 0), c === void 0 && (c = i2 ? i2.length : 0), d === void 0 && (d = 0), g === void 0 && (g = this.length), a3 < 0 || c > i2.length || d < 0 || g > this.length)
      throw new RangeError("out of range index");
    if (d >= g && a3 >= c)
      return 0;
    if (d >= g)
      return -1;
    if (a3 >= c)
      return 1;
    if (a3 >>>= 0, c >>>= 0, d >>>= 0, g >>>= 0, this === i2)
      return 0;
    let M = g - d, N = c - a3;
    const B = Math.min(M, N), ne = this.slice(d, g), Y = i2.slice(a3, c);
    for (let Q = 0; Q < B; ++Q)
      if (ne[Q] !== Y[Q]) {
        M = ne[Q], N = Y[Q];
        break;
      }
    return M < N ? -1 : N < M ? 1 : 0;
  };
  function O(i2, a3, c, d, g) {
    if (i2.length === 0)
      return -1;
    if (typeof c == "string" ? (d = c, c = 0) : c > 2147483647 ? c = 2147483647 : c < -2147483648 && (c = -2147483648), c = +c, qt(c) && (c = g ? 0 : i2.length - 1), c < 0 && (c = i2.length + c), c >= i2.length) {
      if (g)
        return -1;
      c = i2.length - 1;
    } else if (c < 0)
      if (g)
        c = 0;
      else
        return -1;
    if (typeof a3 == "string" && (a3 = u.from(a3, d)), u.isBuffer(a3))
      return a3.length === 0 ? -1 : K(i2, a3, c, d, g);
    if (typeof a3 == "number")
      return a3 = a3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? g ? Uint8Array.prototype.indexOf.call(i2, a3, c) : Uint8Array.prototype.lastIndexOf.call(i2, a3, c) : K(i2, [a3], c, d, g);
    throw new TypeError("val must be string, number or Buffer");
  }
  function K(i2, a3, c, d, g) {
    let M = 1, N = i2.length, B = a3.length;
    if (d !== void 0 && (d = String(d).toLowerCase(), d === "ucs2" || d === "ucs-2" || d === "utf16le" || d === "utf-16le")) {
      if (i2.length < 2 || a3.length < 2)
        return -1;
      M = 2, N /= 2, B /= 2, c /= 2;
    }
    function ne(Q, X) {
      return M === 1 ? Q[X] : Q.readUInt16BE(X * M);
    }
    let Y;
    if (g) {
      let Q = -1;
      for (Y = c; Y < N; Y++)
        if (ne(i2, Y) === ne(a3, Q === -1 ? 0 : Y - Q)) {
          if (Q === -1 && (Q = Y), Y - Q + 1 === B)
            return Q * M;
        } else
          Q !== -1 && (Y -= Y - Q), Q = -1;
    } else
      for (c + B > N && (c = N - B), Y = c; Y >= 0; Y--) {
        let Q = true;
        for (let X = 0; X < B; X++)
          if (ne(i2, Y + X) !== ne(a3, X)) {
            Q = false;
            break;
          }
        if (Q)
          return Y;
      }
    return -1;
  }
  u.prototype.includes = function(i2, a3, c) {
    return this.indexOf(i2, a3, c) !== -1;
  }, u.prototype.indexOf = function(i2, a3, c) {
    return O(this, i2, a3, c, true);
  }, u.prototype.lastIndexOf = function(i2, a3, c) {
    return O(this, i2, a3, c, false);
  };
  function x(i2, a3, c, d) {
    c = Number(c) || 0;
    const g = i2.length - c;
    d ? (d = Number(d), d > g && (d = g)) : d = g;
    const M = a3.length;
    d > M / 2 && (d = M / 2);
    let N;
    for (N = 0; N < d; ++N) {
      const B = parseInt(a3.substr(N * 2, 2), 16);
      if (qt(B))
        return N;
      i2[c + N] = B;
    }
    return N;
  }
  function oe(i2, a3, c, d) {
    return pt(Vt(a3, i2.length - c), i2, c, d);
  }
  function $(i2, a3, c, d) {
    return pt(ti(a3), i2, c, d);
  }
  function j(i2, a3, c, d) {
    return pt(kn(a3), i2, c, d);
  }
  function R(i2, a3, c, d) {
    return pt(ni(a3, i2.length - c), i2, c, d);
  }
  u.prototype.write = function(i2, a3, c, d) {
    if (a3 === void 0)
      d = "utf8", c = this.length, a3 = 0;
    else if (c === void 0 && typeof a3 == "string")
      d = a3, c = this.length, a3 = 0;
    else if (isFinite(a3))
      a3 = a3 >>> 0, isFinite(c) ? (c = c >>> 0, d === void 0 && (d = "utf8")) : (d = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const g = this.length - a3;
    if ((c === void 0 || c > g) && (c = g), i2.length > 0 && (c < 0 || a3 < 0) || a3 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let M = false;
    for (; ; )
      switch (d) {
        case "hex":
          return x(this, i2, a3, c);
        case "utf8":
        case "utf-8":
          return oe(this, i2, a3, c);
        case "ascii":
        case "latin1":
        case "binary":
          return $(this, i2, a3, c);
        case "base64":
          return j(this, i2, a3, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return R(this, i2, a3, c);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), M = true;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(i2, a3, c) {
    return a3 === 0 && c === i2.length ? t3.fromByteArray(i2) : t3.fromByteArray(i2.slice(a3, c));
  }
  function Z(i2, a3, c) {
    c = Math.min(i2.length, c);
    const d = [];
    let g = a3;
    for (; g < c; ) {
      const M = i2[g];
      let N = null, B = M > 239 ? 4 : M > 223 ? 3 : M > 191 ? 2 : 1;
      if (g + B <= c) {
        let ne, Y, Q, X;
        switch (B) {
          case 1:
            M < 128 && (N = M);
            break;
          case 2:
            ne = i2[g + 1], (ne & 192) === 128 && (X = (M & 31) << 6 | ne & 63, X > 127 && (N = X));
            break;
          case 3:
            ne = i2[g + 1], Y = i2[g + 2], (ne & 192) === 128 && (Y & 192) === 128 && (X = (M & 15) << 12 | (ne & 63) << 6 | Y & 63, X > 2047 && (X < 55296 || X > 57343) && (N = X));
            break;
          case 4:
            ne = i2[g + 1], Y = i2[g + 2], Q = i2[g + 3], (ne & 192) === 128 && (Y & 192) === 128 && (Q & 192) === 128 && (X = (M & 15) << 18 | (ne & 63) << 12 | (Y & 63) << 6 | Q & 63, X > 65535 && X < 1114112 && (N = X));
        }
      }
      N === null ? (N = 65533, B = 1) : N > 65535 && (N -= 65536, d.push(N >>> 10 & 1023 | 55296), N = 56320 | N & 1023), d.push(N), g += B;
    }
    return ee(d);
  }
  const H = 4096;
  function ee(i2) {
    const a3 = i2.length;
    if (a3 <= H)
      return String.fromCharCode.apply(String, i2);
    let c = "", d = 0;
    for (; d < a3; )
      c += String.fromCharCode.apply(
        String,
        i2.slice(d, d += H)
      );
    return c;
  }
  function Te(i2, a3, c) {
    let d = "";
    c = Math.min(i2.length, c);
    for (let g = a3; g < c; ++g)
      d += String.fromCharCode(i2[g] & 127);
    return d;
  }
  function Ie(i2, a3, c) {
    let d = "";
    c = Math.min(i2.length, c);
    for (let g = a3; g < c; ++g)
      d += String.fromCharCode(i2[g]);
    return d;
  }
  function je(i2, a3, c) {
    const d = i2.length;
    (!a3 || a3 < 0) && (a3 = 0), (!c || c < 0 || c > d) && (c = d);
    let g = "";
    for (let M = a3; M < c; ++M)
      g += ri[i2[M]];
    return g;
  }
  function qe(i2, a3, c) {
    const d = i2.slice(a3, c);
    let g = "";
    for (let M = 0; M < d.length - 1; M += 2)
      g += String.fromCharCode(d[M] + d[M + 1] * 256);
    return g;
  }
  u.prototype.slice = function(i2, a3) {
    const c = this.length;
    i2 = ~~i2, a3 = a3 === void 0 ? c : ~~a3, i2 < 0 ? (i2 += c, i2 < 0 && (i2 = 0)) : i2 > c && (i2 = c), a3 < 0 ? (a3 += c, a3 < 0 && (a3 = 0)) : a3 > c && (a3 = c), a3 < i2 && (a3 = i2);
    const d = this.subarray(i2, a3);
    return Object.setPrototypeOf(d, u.prototype), d;
  };
  function G(i2, a3, c) {
    if (i2 % 1 !== 0 || i2 < 0)
      throw new RangeError("offset is not uint");
    if (i2 + a3 > c)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(i2, a3, c) {
    i2 = i2 >>> 0, a3 = a3 >>> 0, c || G(i2, a3, this.length);
    let d = this[i2], g = 1, M = 0;
    for (; ++M < a3 && (g *= 256); )
      d += this[i2 + M] * g;
    return d;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(i2, a3, c) {
    i2 = i2 >>> 0, a3 = a3 >>> 0, c || G(i2, a3, this.length);
    let d = this[i2 + --a3], g = 1;
    for (; a3 > 0 && (g *= 256); )
      d += this[i2 + --a3] * g;
    return d;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 1, this.length), this[i2];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 2, this.length), this[i2] | this[i2 + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 2, this.length), this[i2] << 8 | this[i2 + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), (this[i2] | this[i2 + 1] << 8 | this[i2 + 2] << 16) + this[i2 + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), this[i2] * 16777216 + (this[i2 + 1] << 16 | this[i2 + 2] << 8 | this[i2 + 3]);
  }, u.prototype.readBigUInt64LE = Re(function(i2) {
    i2 = i2 >>> 0, Ke(i2, "offset");
    const a3 = this[i2], c = this[i2 + 7];
    (a3 === void 0 || c === void 0) && rt(i2, this.length - 8);
    const d = a3 + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 24, g = this[++i2] + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + c * 2 ** 24;
    return BigInt(d) + (BigInt(g) << BigInt(32));
  }), u.prototype.readBigUInt64BE = Re(function(i2) {
    i2 = i2 >>> 0, Ke(i2, "offset");
    const a3 = this[i2], c = this[i2 + 7];
    (a3 === void 0 || c === void 0) && rt(i2, this.length - 8);
    const d = a3 * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + this[++i2], g = this[++i2] * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + c;
    return (BigInt(d) << BigInt(32)) + BigInt(g);
  }), u.prototype.readIntLE = function(i2, a3, c) {
    i2 = i2 >>> 0, a3 = a3 >>> 0, c || G(i2, a3, this.length);
    let d = this[i2], g = 1, M = 0;
    for (; ++M < a3 && (g *= 256); )
      d += this[i2 + M] * g;
    return g *= 128, d >= g && (d -= Math.pow(2, 8 * a3)), d;
  }, u.prototype.readIntBE = function(i2, a3, c) {
    i2 = i2 >>> 0, a3 = a3 >>> 0, c || G(i2, a3, this.length);
    let d = a3, g = 1, M = this[i2 + --d];
    for (; d > 0 && (g *= 256); )
      M += this[i2 + --d] * g;
    return g *= 128, M >= g && (M -= Math.pow(2, 8 * a3)), M;
  }, u.prototype.readInt8 = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 1, this.length), this[i2] & 128 ? (255 - this[i2] + 1) * -1 : this[i2];
  }, u.prototype.readInt16LE = function(i2, a3) {
    i2 = i2 >>> 0, a3 || G(i2, 2, this.length);
    const c = this[i2] | this[i2 + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, u.prototype.readInt16BE = function(i2, a3) {
    i2 = i2 >>> 0, a3 || G(i2, 2, this.length);
    const c = this[i2 + 1] | this[i2] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, u.prototype.readInt32LE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), this[i2] | this[i2 + 1] << 8 | this[i2 + 2] << 16 | this[i2 + 3] << 24;
  }, u.prototype.readInt32BE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), this[i2] << 24 | this[i2 + 1] << 16 | this[i2 + 2] << 8 | this[i2 + 3];
  }, u.prototype.readBigInt64LE = Re(function(i2) {
    i2 = i2 >>> 0, Ke(i2, "offset");
    const a3 = this[i2], c = this[i2 + 7];
    (a3 === void 0 || c === void 0) && rt(i2, this.length - 8);
    const d = this[i2 + 4] + this[i2 + 5] * 2 ** 8 + this[i2 + 6] * 2 ** 16 + (c << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(a3 + this[++i2] * 2 ** 8 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 24);
  }), u.prototype.readBigInt64BE = Re(function(i2) {
    i2 = i2 >>> 0, Ke(i2, "offset");
    const a3 = this[i2], c = this[i2 + 7];
    (a3 === void 0 || c === void 0) && rt(i2, this.length - 8);
    const d = (a3 << 24) + // Overflow
    this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + this[++i2];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++i2] * 2 ** 24 + this[++i2] * 2 ** 16 + this[++i2] * 2 ** 8 + c);
  }), u.prototype.readFloatLE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), n2.read(this, i2, true, 23, 4);
  }, u.prototype.readFloatBE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 4, this.length), n2.read(this, i2, false, 23, 4);
  }, u.prototype.readDoubleLE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 8, this.length), n2.read(this, i2, true, 52, 8);
  }, u.prototype.readDoubleBE = function(i2, a3) {
    return i2 = i2 >>> 0, a3 || G(i2, 8, this.length), n2.read(this, i2, false, 52, 8);
  };
  function se(i2, a3, c, d, g, M) {
    if (!u.isBuffer(i2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (a3 > g || a3 < M)
      throw new RangeError('"value" argument is out of bounds');
    if (c + d > i2.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(i2, a3, c, d) {
    if (i2 = +i2, a3 = a3 >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      se(this, i2, a3, c, N, 0);
    }
    let g = 1, M = 0;
    for (this[a3] = i2 & 255; ++M < c && (g *= 256); )
      this[a3 + M] = i2 / g & 255;
    return a3 + c;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(i2, a3, c, d) {
    if (i2 = +i2, a3 = a3 >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      se(this, i2, a3, c, N, 0);
    }
    let g = c - 1, M = 1;
    for (this[a3 + g] = i2 & 255; --g >= 0 && (M *= 256); )
      this[a3 + g] = i2 / M & 255;
    return a3 + c;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 1, 255, 0), this[a3] = i2 & 255, a3 + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 2, 65535, 0), this[a3] = i2 & 255, this[a3 + 1] = i2 >>> 8, a3 + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 2, 65535, 0), this[a3] = i2 >>> 8, this[a3 + 1] = i2 & 255, a3 + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 4, 4294967295, 0), this[a3 + 3] = i2 >>> 24, this[a3 + 2] = i2 >>> 16, this[a3 + 1] = i2 >>> 8, this[a3] = i2 & 255, a3 + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 4, 4294967295, 0), this[a3] = i2 >>> 24, this[a3 + 1] = i2 >>> 16, this[a3 + 2] = i2 >>> 8, this[a3 + 3] = i2 & 255, a3 + 4;
  };
  function Ln(i2, a3, c, d, g) {
    zn(a3, d, g, i2, c, 7);
    let M = Number(a3 & BigInt(4294967295));
    i2[c++] = M, M = M >> 8, i2[c++] = M, M = M >> 8, i2[c++] = M, M = M >> 8, i2[c++] = M;
    let N = Number(a3 >> BigInt(32) & BigInt(4294967295));
    return i2[c++] = N, N = N >> 8, i2[c++] = N, N = N >> 8, i2[c++] = N, N = N >> 8, i2[c++] = N, c;
  }
  function On(i2, a3, c, d, g) {
    zn(a3, d, g, i2, c, 7);
    let M = Number(a3 & BigInt(4294967295));
    i2[c + 7] = M, M = M >> 8, i2[c + 6] = M, M = M >> 8, i2[c + 5] = M, M = M >> 8, i2[c + 4] = M;
    let N = Number(a3 >> BigInt(32) & BigInt(4294967295));
    return i2[c + 3] = N, N = N >> 8, i2[c + 2] = N, N = N >> 8, i2[c + 1] = N, N = N >> 8, i2[c] = N, c + 8;
  }
  u.prototype.writeBigUInt64LE = Re(function(i2, a3 = 0) {
    return Ln(this, i2, a3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = Re(function(i2, a3 = 0) {
    return On(this, i2, a3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(i2, a3, c, d) {
    if (i2 = +i2, a3 = a3 >>> 0, !d) {
      const B = Math.pow(2, 8 * c - 1);
      se(this, i2, a3, c, B - 1, -B);
    }
    let g = 0, M = 1, N = 0;
    for (this[a3] = i2 & 255; ++g < c && (M *= 256); )
      i2 < 0 && N === 0 && this[a3 + g - 1] !== 0 && (N = 1), this[a3 + g] = (i2 / M >> 0) - N & 255;
    return a3 + c;
  }, u.prototype.writeIntBE = function(i2, a3, c, d) {
    if (i2 = +i2, a3 = a3 >>> 0, !d) {
      const B = Math.pow(2, 8 * c - 1);
      se(this, i2, a3, c, B - 1, -B);
    }
    let g = c - 1, M = 1, N = 0;
    for (this[a3 + g] = i2 & 255; --g >= 0 && (M *= 256); )
      i2 < 0 && N === 0 && this[a3 + g + 1] !== 0 && (N = 1), this[a3 + g] = (i2 / M >> 0) - N & 255;
    return a3 + c;
  }, u.prototype.writeInt8 = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 1, 127, -128), i2 < 0 && (i2 = 255 + i2 + 1), this[a3] = i2 & 255, a3 + 1;
  }, u.prototype.writeInt16LE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 2, 32767, -32768), this[a3] = i2 & 255, this[a3 + 1] = i2 >>> 8, a3 + 2;
  }, u.prototype.writeInt16BE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 2, 32767, -32768), this[a3] = i2 >>> 8, this[a3 + 1] = i2 & 255, a3 + 2;
  }, u.prototype.writeInt32LE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 4, 2147483647, -2147483648), this[a3] = i2 & 255, this[a3 + 1] = i2 >>> 8, this[a3 + 2] = i2 >>> 16, this[a3 + 3] = i2 >>> 24, a3 + 4;
  }, u.prototype.writeInt32BE = function(i2, a3, c) {
    return i2 = +i2, a3 = a3 >>> 0, c || se(this, i2, a3, 4, 2147483647, -2147483648), i2 < 0 && (i2 = 4294967295 + i2 + 1), this[a3] = i2 >>> 24, this[a3 + 1] = i2 >>> 16, this[a3 + 2] = i2 >>> 8, this[a3 + 3] = i2 & 255, a3 + 4;
  }, u.prototype.writeBigInt64LE = Re(function(i2, a3 = 0) {
    return Ln(this, i2, a3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = Re(function(i2, a3 = 0) {
    return On(this, i2, a3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function xn(i2, a3, c, d, g, M) {
    if (c + d > i2.length)
      throw new RangeError("Index out of range");
    if (c < 0)
      throw new RangeError("Index out of range");
  }
  function Rn(i2, a3, c, d, g) {
    return a3 = +a3, c = c >>> 0, g || xn(i2, a3, c, 4), n2.write(i2, a3, c, d, 23, 4), c + 4;
  }
  u.prototype.writeFloatLE = function(i2, a3, c) {
    return Rn(this, i2, a3, true, c);
  }, u.prototype.writeFloatBE = function(i2, a3, c) {
    return Rn(this, i2, a3, false, c);
  };
  function Un(i2, a3, c, d, g) {
    return a3 = +a3, c = c >>> 0, g || xn(i2, a3, c, 8), n2.write(i2, a3, c, d, 52, 8), c + 8;
  }
  u.prototype.writeDoubleLE = function(i2, a3, c) {
    return Un(this, i2, a3, true, c);
  }, u.prototype.writeDoubleBE = function(i2, a3, c) {
    return Un(this, i2, a3, false, c);
  }, u.prototype.copy = function(i2, a3, c, d) {
    if (!u.isBuffer(i2))
      throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !d && d !== 0 && (d = this.length), a3 >= i2.length && (a3 = i2.length), a3 || (a3 = 0), d > 0 && d < c && (d = c), d === c || i2.length === 0 || this.length === 0)
      return 0;
    if (a3 < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), i2.length - a3 < d - c && (d = i2.length - a3 + c);
    const g = d - c;
    return this === i2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(a3, c, d) : Uint8Array.prototype.set.call(
      i2,
      this.subarray(c, d),
      a3
    ), g;
  }, u.prototype.fill = function(i2, a3, c, d) {
    if (typeof i2 == "string") {
      if (typeof a3 == "string" ? (d = a3, a3 = 0, c = this.length) : typeof c == "string" && (d = c, c = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !u.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (i2.length === 1) {
        const M = i2.charCodeAt(0);
        (d === "utf8" && M < 128 || d === "latin1") && (i2 = M);
      }
    } else
      typeof i2 == "number" ? i2 = i2 & 255 : typeof i2 == "boolean" && (i2 = Number(i2));
    if (a3 < 0 || this.length < a3 || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= a3)
      return this;
    a3 = a3 >>> 0, c = c === void 0 ? this.length : c >>> 0, i2 || (i2 = 0);
    let g;
    if (typeof i2 == "number")
      for (g = a3; g < c; ++g)
        this[g] = i2;
    else {
      const M = u.isBuffer(i2) ? i2 : u.from(i2, d), N = M.length;
      if (N === 0)
        throw new TypeError('The value "' + i2 + '" is invalid for argument "value"');
      for (g = 0; g < c - a3; ++g)
        this[g + a3] = M[g % N];
    }
    return this;
  };
  const Xe = {};
  function Zt(i2, a3, c) {
    Xe[i2] = class extends c {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: a3.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i2}]`, this.stack, delete this.name;
      }
      get code() {
        return i2;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: d,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i2}]: ${this.message}`;
      }
    };
  }
  Zt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(i2) {
      return i2 ? `${i2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Zt(
    "ERR_INVALID_ARG_TYPE",
    function(i2, a3) {
      return `The "${i2}" argument must be of type number. Received type ${typeof a3}`;
    },
    TypeError
  ), Zt(
    "ERR_OUT_OF_RANGE",
    function(i2, a3, c) {
      let d = `The value of "${i2}" is out of range.`, g = c;
      return Number.isInteger(c) && Math.abs(c) > 2 ** 32 ? g = Pn(String(c)) : typeof c == "bigint" && (g = String(c), (c > BigInt(2) ** BigInt(32) || c < -(BigInt(2) ** BigInt(32))) && (g = Pn(g)), g += "n"), d += ` It must be ${a3}. Received ${g}`, d;
    },
    RangeError
  );
  function Pn(i2) {
    let a3 = "", c = i2.length;
    const d = i2[0] === "-" ? 1 : 0;
    for (; c >= d + 4; c -= 3)
      a3 = `_${i2.slice(c - 3, c)}${a3}`;
    return `${i2.slice(0, c)}${a3}`;
  }
  function Jr(i2, a3, c) {
    Ke(a3, "offset"), (i2[a3] === void 0 || i2[a3 + c] === void 0) && rt(a3, i2.length - (c + 1));
  }
  function zn(i2, a3, c, d, g, M) {
    if (i2 > c || i2 < a3) {
      const N = typeof a3 == "bigint" ? "n" : "";
      let B;
      throw a3 === 0 || a3 === BigInt(0) ? B = `>= 0${N} and < 2${N} ** ${(M + 1) * 8}${N}` : B = `>= -(2${N} ** ${(M + 1) * 8 - 1}${N}) and < 2 ** ${(M + 1) * 8 - 1}${N}`, new Xe.ERR_OUT_OF_RANGE("value", B, i2);
    }
    Jr(d, g, M);
  }
  function Ke(i2, a3) {
    if (typeof i2 != "number")
      throw new Xe.ERR_INVALID_ARG_TYPE(a3, "number", i2);
  }
  function rt(i2, a3, c) {
    throw Math.floor(i2) !== i2 ? (Ke(i2, c), new Xe.ERR_OUT_OF_RANGE("offset", "an integer", i2)) : a3 < 0 ? new Xe.ERR_BUFFER_OUT_OF_BOUNDS() : new Xe.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${a3}`,
      i2
    );
  }
  const $r = /[^+/0-9A-Za-z-_]/g;
  function ei(i2) {
    if (i2 = i2.split("=")[0], i2 = i2.trim().replace($r, ""), i2.length < 2)
      return "";
    for (; i2.length % 4 !== 0; )
      i2 = i2 + "=";
    return i2;
  }
  function Vt(i2, a3) {
    a3 = a3 || 1 / 0;
    let c;
    const d = i2.length;
    let g = null;
    const M = [];
    for (let N = 0; N < d; ++N) {
      if (c = i2.charCodeAt(N), c > 55295 && c < 57344) {
        if (!g) {
          if (c > 56319) {
            (a3 -= 3) > -1 && M.push(239, 191, 189);
            continue;
          } else if (N + 1 === d) {
            (a3 -= 3) > -1 && M.push(239, 191, 189);
            continue;
          }
          g = c;
          continue;
        }
        if (c < 56320) {
          (a3 -= 3) > -1 && M.push(239, 191, 189), g = c;
          continue;
        }
        c = (g - 55296 << 10 | c - 56320) + 65536;
      } else
        g && (a3 -= 3) > -1 && M.push(239, 191, 189);
      if (g = null, c < 128) {
        if ((a3 -= 1) < 0)
          break;
        M.push(c);
      } else if (c < 2048) {
        if ((a3 -= 2) < 0)
          break;
        M.push(
          c >> 6 | 192,
          c & 63 | 128
        );
      } else if (c < 65536) {
        if ((a3 -= 3) < 0)
          break;
        M.push(
          c >> 12 | 224,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else if (c < 1114112) {
        if ((a3 -= 4) < 0)
          break;
        M.push(
          c >> 18 | 240,
          c >> 12 & 63 | 128,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return M;
  }
  function ti(i2) {
    const a3 = [];
    for (let c = 0; c < i2.length; ++c)
      a3.push(i2.charCodeAt(c) & 255);
    return a3;
  }
  function ni(i2, a3) {
    let c, d, g;
    const M = [];
    for (let N = 0; N < i2.length && !((a3 -= 2) < 0); ++N)
      c = i2.charCodeAt(N), d = c >> 8, g = c % 256, M.push(g), M.push(d);
    return M;
  }
  function kn(i2) {
    return t3.toByteArray(ei(i2));
  }
  function pt(i2, a3, c, d) {
    let g;
    for (g = 0; g < d && !(g + c >= a3.length || g >= i2.length); ++g)
      a3[g + c] = i2[g];
    return g;
  }
  function be(i2, a3) {
    return i2 instanceof a3 || i2 != null && i2.constructor != null && i2.constructor.name != null && i2.constructor.name === a3.name;
  }
  function qt(i2) {
    return i2 !== i2;
  }
  const ri = function() {
    const i2 = "0123456789abcdef", a3 = new Array(256);
    for (let c = 0; c < 16; ++c) {
      const d = c * 16;
      for (let g = 0; g < 16; ++g)
        a3[d + g] = i2[c] + i2[g];
    }
    return a3;
  }();
  function Re(i2) {
    return typeof BigInt > "u" ? ii : i2;
  }
  function ii() {
    throw new Error("BigInt not supported");
  }
})(cn);
var lo = class {
  static toHex(t3) {
    return cn.Buffer.from(t3).toString("hex");
  }
  static ensureUint8Array(t3) {
    return typeof t3 == "string" ? Uint8Array.from(cn.Buffer.from(t3, "base64")) : t3 instanceof Uint8Array ? t3 : Uint8Array.from(t3);
  }
  static bytesEqual(t3, n2) {
    if (t3 === n2)
      return true;
    if (t3.length !== n2.length)
      return false;
    for (let r = 0; r < t3.length; r++)
      if (t3[r] !== n2[r])
        return false;
    return true;
  }
};
function Ot(e3, t3) {
  return Object.prototype.hasOwnProperty.call(e3, t3);
}
async function fo(e3, t3) {
  let n2;
  if (Ot(e3, "bytes"))
    n2 = e3.bytes;
  else if (Ot(e3, "messageBytes"))
    n2 = e3.messageBytes;
  else
    throw new Error(
      "input should be either SuiSignPersonalMessageOutput or SuiSignMessageOutput"
    );
  try {
    const r = await verifyPersonalMessage(
      Nr(n2),
      e3.signature
    );
    return lo.bytesEqual(r.toRawBytes(), t3);
  } catch {
    return false;
  }
}
function Lu(e3) {
  return new TextDecoder().decode(Nr(e3));
}
function he(e3) {
  return Object.freeze(e3);
}
var Ue = ((e3) => (e3.SUI_WALLET = "Sui Wallet", e3.SUIET_WALLET = "Suiet", e3.ETHOS_WALLET = "Ethos Wallet", e3.SURF_WALLET = "Surf Wallet", e3.GLASS_WALLET = "GlassWallet", e3.MORPHIS_WALLET = "Morphis Wallet", e3.MARTIAN_WALLET = "Martian Sui Wallet", e3.ONEKEY_WALLET = "OneKey Wallet", e3.SPACECY_WALLET = "Spacecy Sui Wallet", e3.SENSUI_WALLET = "Sensui Wallet", e3.NIGHTLY_WALLET = "Nightly", e3.ELLI_WALLET = "Elli", e3.TOKENPOCKET_WALLET = "TokenPocket Wallet", e3.FRONTIER_WALLET = "Frontier Wallet", e3))(Ue || {});
var ho = he({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
});
var go = he({
  name: "Sui Wallet",
  label: "Sui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////9/f39/f3+/v7x+Pz///95wfGj1PXI5fgEMJeQAAAAB3RSTlMAECNgmNr40ET05wAAAOBJREFUeNplUksOgjAQbYw38LdloQdw5VZJDGuNiWtXdGvUFjlAtT2AVC4AekrLvKKYvoTMm5fpfGGswWCdit2cfTFNZYO49YfSYwW/t2+FS0TCTH6x/Q/wISPZwcYJSVc4uxdg1wI2Yn0QbmCXbAKin7AHtiCbq6wicvI5syK/+azowlZSoxNGc4l7IWswhqKlagtD4Kl9CAWBAmspbGHwhJK+HDMlkiaIcJ9BWWqMu64yhcbGVMU5nKoc/XC2fGs/HMbPra78+MGCwhUGSw7OEB4qOKU7Nrki/p2/8zt8ABpiv63tyiOHAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
});
var po = he({
  name: "Ethos Wallet",
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
});
var yo = he({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
});
var Mo = he({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
});
var vo = he({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAADkrSURBVHgB5X0LuF5ldea79n9OasAZY+v1mak5ccaOlwrBqtWq5UTxWqeJWgWVS6JSL1VJdBy1oklwqiICwXqhgBIEK4KSE0eUqpDgpbUzjkYFbe1UTtSnzwPBTnweCcrJv9d8+/vW7dv/nxu5kNAPcv7L3vu7rbXe9a71fXv/hHthuXPZsqn7DCeOncNg0YB4IYgXMGEqHZoiAlpwfoX+AzMTp694lqjZ3nK7HQ1vB2OWB9hKjC08xPZ5V89swb2sEI7wcudzTpqaBB1Pg3Zx+jidBL0wCXRBGhm5cEEmcNbPzHoOp/+6QnK+fJvOS98k6ZPX84t0JCkBbyFqb5zbObFl/pUzsziCyxGnADy9bAHmzz+2RbsMaJYly53q5MTJrm00Zt0iWFGCLMROzk2uSQ+WI52g5dqsEBQUAvk4ad25vsZaS8rAW9I3l01e8fnNOMLKEaMAcyecNE2D5rQklKWdhTPcwikLsFi5Ck+OIVp0PoOCQug5lIVcRFwUwYUelIrkeD651AtRLD2+PR2aAe3cOLH+izM4AsphrQC85ORj28l2WZLWytTTBSqc4q8xTohwYef/uDumClIJ3xAgY4Jcw1CRV8pU6gX6yqUo0wGLIoIr5db0ZvMchmvnr79uFodpOSwVYO6Ek6dTx1Z3gF+EpsJ2BVCL7nx5RAPz/Vkw4CLg7r/uy5YrbiDuQDmAzgaVa8q53AoXQO1SmjB31ObuMbVBmbTNdE2DzRgO106uv24zDrNyWCkALznl+CF4TZqwabFaiHXrGcnSSCytwDspAJuASI9FSy3ET67LZ5kltwL3hRiWV7LruSCIuIhYLwLXkHasX9JXQRflF6me2fR3zcTHrr0Mh0k5LBRgbjpZPNHq1Jtp8knPCkCRxWfYZjj0oyJ7YnnqBopbEGYgyBG4QrZ0LrgSEUAErt+bgMXvN+F7VktnNgJpPSt9oe78cF4+rcHWFIqunXfxdetxD5d7VAF4+qSpISYvpYamuWdBJMLj4GvzTFZwrAQPqF1ARILyfYF6PYYQ/2eF4E41iDiggR/Pp1eugj0aAEaIJYXruISRWUFYlErHllzHzM67aNU9yRHuEQXoQrkW//6M9HYNR0KVeyQsvCnzyIHUqaCgx+X8/FKOWVhnSKKcIdQPJZImZIpMHooeWXTEFcRnReguaTrlbKVdBDKKMKttrpopKJ67psBHsGbiqF9dQOs2b8chLodcAfhppxzfNs361PKUQT2KQXDw2zUHCK8k6OuCByKzV5jvvm4y8SsNU83qI8L0iGQScndyWzqhGER93y8cBCHCoFGU0DEClmuoXZqgQtPQ7BywYv6Fh5YoHjIF4OnlC9qWV6e3K3kEMkcFqj7TCV7+Hj1LHoVmxOtzGFhei1KwW6MigWYFVXzyFoX9W8ZQw8ZMQlsTouCEoc94RChtwVwAIgqguB/IBbhg8q/+ZhUOUTkkCnDnk5ZPzZuHTWm8C8cnbICeb44TV1mtJl4c2itf34Vc8i5MdNawViKImje4hRbn0rfMvtXX2cFSQ26T7bgoQCGskHRyGJsRyRIpljHVbfHsZLNzmj58w1Yc5NLgIBd+yorT5k3iO2l8Uzbx6nZRyZ9JzFJf1bClJgnopAYERieRXrzGNDvLQQRRqL+mjITEy4XRFEIcqP1SGM8EAMEhWEgRuiINKtCb39IPrLDE2muox5PTpnbyxJa7XvfsM3CQy0FVgOHTXnF+S1ifRnm/7jNr9GQTo4XdmuA+XE0dcKWgynbZBF8Im5/r55MrVW5czzffXCgAK+VIpW3Z2qCcIiY2/SrEoRoC1W0Crug6pqDMRV3E63jdxhRYPMuC5GrWzb3uWatxEMtBcQGdvx/e1VyaZmpZhPJMrQr7zr7ZuYBn9DzWFqtWto0q9SsVsmfbStIFFWnUxJFC/LgYHxhJ+xZRtLYaKG1V7sD6xq19ZiOC6gJK8igmljx89RC3KGecD5kHTSIRzUxM3LXiYEQJB1wBOPl7Hgw2pNW6xbkBGXTRcRGxWq5G7ARfjZM0qyFrZPbscTt8onvK0XKVjq3CLfP/Rcm6jw2qKITqZFLpYxSMKgtg0QMR4rGsz7o66VxFZ5yLfTemKpVCxjmw80uZHQ7nlsy/cPMsDmA5oArQCT+FeJtSpQsDpI8slOiAS7glApYpD9YkEYKwccQVPKCyTPhKH0SIFkI2RDEUq0iYzPY4YavSxNAUwUmj931vhdFWKI1iaLQSUcWsvSutoB1GwlJDDqLZyXZ4QMnhAeMA2fKp2ZTeTrXRHfbZnrwjyZAaoZJJVGdLFT3yeswZl1aD+XJgVORtqy7AhEmBcijIsJEFBNHGpnQAom+uiEoAnCZaHaxctVsuAtm1pa/qs4pz0vFhTICEAqJp7AvnmsHmO18zPYUDVA6IAmTho9mU+j1lphxYvfMgDlxIkJ9qbZFUr4KnEDlmZezq5y2BTz3VolFbdbanihHy/+prBfk9NJe2lRzCPJkaMZOsTZimWDM5AoBvQ3KdtEGIm7IMtQQpUNIZsVkUrGhMu3Awb3IT/9nTF+IAFMJ+liL8QRF+jHcpGnDOdIkCcOU7ozDMHwefPhKXi8DqJdmMI0Eh3O0ol3A4VSm6H889Oeoo4IlPAD3wgaXGn9wCbJ0Fbr+twMTYtQDVROUQqFPHPc2JWUuKc4TCgcyFFSWPS+CWKNM5STXODpvhkvnr9o8T7JcCdGyfd0x8mxtepCbfRPNUoqOoqGDfFCtW/w/xlxYIVTZcp4UDpmvkAFDfX8LbbNy/mzLCohFkXXvxi6n5o+cjK0GvtNdcBf7spznu/OmtP0SC6YjUhP7A3xfu0xtnGGMkmXXkEb8TFCTaMkE7l+xPdLBfLoB3TF6aNHOR9CzLvWS1yKZbDsk/4ztscbX5PgVUJ2yK6AyfhxIykk9bSC5BtEpPdfdAZJCOomxNQVmm5SuoefFLxgo/T9ALXwJ60YlUCVM6xEAQfrHpggpQvS/jtFSF0pI4PicU5ONAzShiIRtiOnXxTh5civ0od1sB+ImvWs1dnF/3jTz5oW9ZXH/gPerjyb1zl6r1VIhczRwJGatxMFfCUHP0uqw7mTixsW92ZpGJ6vP+iJrnPQ97nKSkBM3Jr6j0yTiA7xWVbUrBLcE1pMyN9StOmtm8EQybA9J6y3sntzZr6cplcytPOB93sxDuRhk+4fQz0gysU9FoRKspNWNJ1leu4M0TPOZLUXwe22KKxtZi58yRFlX+M4SZ0QVQpJsOv/ljUvvk67n5yIf2afz8tU1oL/qgrfXXbkdgQcLS/p6CAnM1T4n7B2KoXIWtYf58LpRCeq4hhdQrJs6//jLsY9lnBeDFifRNTnwniWqBrarJpNsGiQZqsiTr553bZ98QUQ805gQ8aRKSM/aq8XH0jTr5Qh4bMTru8YH4/kEPxGDN6vy6z+P/2g1oL/4QbHuYWvdIO11pq/xE4AoFLIwjebKIqnnB6PxWwYVnT9P3vxiiPW5fSeE+u4B2crJj/AsKp6sRj1FzGM99oOTFwiKQcjlzp626DoVNC88dIM37+4WVR42LquaF5Vj426w47W4JP1/9tKeDTn99GCWCMgZ70s7DQ0RhCWSDZK78BMEoQHjjTYSkMtw9su5HWDBJdAOvnF6AfSj7pADDx7/q/NTrhZZCI92kY8SnYjTqyk35KwZEukqeD7M4ORLipBtyEGNsZp+XjLa2Gq/+F/W0wa1ejtFL/gT0hCfsdpy87TZgxx27PN4kJWhOf0PuUai+FprMhxyAc0HYV+TvFRBt+mxu/RR4ZkmTFjrNpaQVk0VzTbebeu/LXruAuce/ajqh66axsNp1qx/2BJ/VwkMuUwyquYABAwWrH419y0dyrTIpVGEagHpzSDm+aCEGHzh7/ACTwNsvXAv+4rX5fb76vkehefwT0bwoRQkPeNDIJW3nDi75YDCjnquJMF99j9od6NiCG3Vf72pd7yTK6w2sfCu2OWQ8PbmCzdiLslcKkPz+Ap6c953UtakqIQJIIsUGQLUCtNJR9/vq83RNlfskzxWnSn647wRs48VIqBmSSOP8/lnvGg/9yeLbtWu4vX1b31/bDDWnrEDznOePzs3XsxIUhYzCln4argdBV3PRKFRwTHrZ9UquYfuPhGPBciJVKFoSZDw7OcTj9iY/sHcuoJl3Rqp3oTSj8GW5WTYbVfLvOK+ZvXKV+zzdiGkRPVAzXy67uEMvxE9qUA1y/87m9dmRMsxhGsIbXjte+Dt2JOGvZd62DUWnAqxauJcOXPFxbq/59Mjl9NTkDl71RkKN2ICjv/l4Ni/uXbRQ2YaY55FCPkVNxJeJtQUiChbgfICx6K4GK7EXZY8K0LH+lrBGVVDJjS7iRd4j2SyhvSP8huLMCIibUlsdeoDIgK0vlHIe2NDCHCIZ2bB2uv6cmPz+Yx49fnxXX90Jn1hwhY3MMgdtz8faDZ8GbxivBINXvjFUCjeSIDBCsHbXfmmvGLgx16gS5dwyqMgNOOANoYLDdNbqO1dOT2EPZc8KMJh3vnaEo5FSvaUJCNk96Y4qTM8uNGJWX1AWulCmiuvMnl7j17N4SoLPg2kAq8Vpl5PgH4UmKcC40l59Ndprr7XsctFfQRi2bEsVWrTXXMk8cxX368pI8MozoMiYt40bIoGD+jP5BJY2RV/Vwi1PppiHoB3eFekvBWWwkCl/MTGBS7GHslsF2Pm405enVpeW+tgE5tm1oHRF7XSM8lpU0XCKzLWLRhNIM3xlqBoMlFkJ8CKDg63AQRxOFXqp/GUzT4L8DP3jyuxsZ/1lYOafYSsE5CpVIXv3dnjNpzIajExmUQIK0Yqmhk0wjo1A5SbUINRrsaKknu0DNUpN1WKlVhGSC5i+879NT2M3pdn9QVqtDcf1avP5I2uWXHttGJxph6CD1GMFAYoyCJ+IsbC+stq+mouRvYKZPjflxIIyb3jNeL9/2zYM338O9NyyoGcooH30Tzby/Jo/tTNXot1w5UjV9JROCVaG65zSdZrRVmrtxzmYui1YGqcCEAylVEagkdnWbrpgBth9WLhLBcjWD5qinppWbVUjMQU3X2eOgHo5ENEVCtVW6U+IpZPEPWTJL90wUtbEqglwfMxmceKLQL873u+353wgkz5rB4IwArMFWrUfHti4Poh3n7mSxylB0ynBK86oLupG0MKToAEOPKYnMQKKpAjB2j0aVrZgkxc76ErU/Zuee8uS47GL0uz6QLPaelWDFgXKEpI1NFJH8FlcXS+ddZWxC4JAqfpOLSRux2U1S7VQPfakx1Nz0oswrrRXXQ2+ZVZ0r6BPF76pilFVIxt8kclMNFDWLNqZRAw3fnrEOpqnPAMDVQLON5lXrMgg0Fkyc4Czes1Q3J2OmSyy0lNsfVRRSsYgDbZrsIsyVgH4uNd2GjMlIF3a4OinrV15MyblyXoTH7tg4NqvhN3JF2EkA27p1HBB8COGMEHB6EEPouaVp2DsuDbdCL7qM4ClCuTWcLcm6kOK+i6Opmxko4xwuCFxgpkx7uAPnpGRgBqKiTDiuGxmgqQKUBnmmeQLnd5cATNqMu2N6quRmK6qXXKB8QqQNIbhUJe/C0s0ym6zB/cYVs2HI/GXcUuqmHWWzbLExjxfwHojBtklQbkpQkbZKVbPUPP2N+3S7/Oll/UslSqfa/21Q+IAKqJZ8hNZeK2Ps92YOMGnLhlptklKQMvPqPhDdIeuWG4I8pEpuAcjfmW2NIlS5QDDsBxBJGocUL4tb7R//S948Wum0svxMlaHoYAA3hxVAygLOhGLwzlsoy6zamu9chZrCpRMZyB7Pyp/5/ADSZRIfemrk14IPHwhRsodOzBcfRb4jh0B+s2q5cYPs3Y1elPMulD9lrw7/KX/ye3HLhhpvlOCwYqVFVYVYTvB8zGbVZPmVArqOm1wY/CZtoU5GRhHNCvnTN/11qceO9K3/heJqKzWGJu8MxbNsWlxgT8dgC7U6vnRV5Oy+ConIFdIt/32SMuFl6CifHKV4tCn8loQo/P7L92F3//4ZQkBbveZJVgSq8y0J7R8fLD9qWEbYYHeEtwiRhDatfYbN3D78VEloIwEK0mi2cAkwIi5Hfme62mK8S47FbQLUCkmTMGAYLDMEy/o92tEAah7Lg9g3inm26O1mwcr55KG0naOATaXHaGVFGGqa5qtQogIIB/VsQTXYXCY3zzwAWl1brzfb6/8TPL9X4Vl9rhuv1EoNZPS4emY2UdihK1opxHGAMUoSoBxSpCRYPlKuB8AKvShSDD686TF5E26Ghr5GcxVw3yMX8Ij9xpWCsCLX700nTulF3o40tcuhx2DoBAKcEQGVwgOLk19eyXlAgjs8BhUSTgHUOtQEeI73kxj/f4tW4GrPmt1wODSZ7h1uStKeZvcW6OA9UcuZsvE9VAJ7Teux/Dj60a6RE9OxHD5qqpWiXTDfJFNi6ZQHGXcilhhmcSNBQOt2nRPvWDuLU87Ph6rFCBx4mXxajd+rgh5MfT4B2VzErtbhk6dAX+IqEVxVCgGe0Yh4Mkhjgoh+Bl78dIXER7+MIyULtnzvnPLPFkvS2VtHJrXVDoU+kU2PMBStPI+M3kDPkNqBCQA/21CgktHlaDplOC0lcWhFq1zzhOF78QkyMRZL3HFt3t8AGUqfeJKTQ2WV32JH4iaZRaeUd1s6WlrWggDLJFecFHaUaEMFFGsOG3XfobHDhbLolK0Yo0ONYBC8JMej+ZlL8S40r73vML8YQG0I6/QF3KUJOtXmFGFV4Van3rrWnDB5GmDUEd2B5dewP3+NU8+ISnBqnJllfnhkjUQNK+CQ5KGQjJMMUdoGzycLkbojszc19K4a8i3Mjz2tcdz94xdJzRVnl5HidBRVrM27wdTW+mc8L8QL8k4qskEdHFH+tsyef3ou8UsmgeneP9PT8a4wld+tkv2oNdkZCWqQ0EZzNbiGG0lUNTe7ZEwvjj8Qb1O+7dfoeFZZ4zsMspKcOoqkMrM6lDFZHWcxKTp8mBALmeUnIYigkAHc/Cd0MP3/9V9di62PlijA15eGpU8ulYViY/2ryc91wFxZpWfFmDtWQYJhFHt1gDX4GJ9oMpna9vNmcl6HvQA9At/7rpE/D7b01Uo/5DphCsUm8Gofak/lvY0QqgE5GloChRHxhW+g+naT3+M4Qf+fLwSnLLK0TFgnPUHklRjrvQuz5/MIcdUppIHgqy1AHC+lUTd2HZ+RwDmxap3lugIsZcnaty6zXphKhabApwYerwfLE3vd3ML9ImHDoqFMMT5f3kX74/z+7cX66/wRnHE/bMHTk4+OFiK8x0Slm6jo1GksLX9qg341Fhpf/bPGJ47qgTUKcHJK6EcRDpHPoXlVSmQdmg01BbNZqgv0KOqHIqyS/VI2VyUkj9pBAYLtiBdz6RbtyhZPVQOeWP50/P1Gi4xomZbmifOo/Wa1ca0K128P87vJ+EP3/HulOy5QydMO22VmVVJTsJcKCmHYRumX002AgNDhFH1JiF+EHtkjzTSgtBPkxKc9zYeRYJnYnDqKq8WMf5mIPIT4VWWl9CBAL0VQkNqR6dy1hS/4w8W5na7P8MkfJ+cIMQAdWW3busTVymHjY98AByNjyic6VOqbD9qNGsmyyzRHM2D0/r+a8b7/faSyzPpk173D5cMqhLSeIL2kdW+mS38E61GfXpvyHYlqD5JQxgil09uuv3pLTRWCZ70zIQEq4QPtblaR0qOdyGWnoVsHMscV/skLe4lcuMsIDY3R9O5ze7PoMXxAsVcQxhzrfTuDWVsfczvzxBqVi35f/meEOaWEZ2gLTj55czNO1eO9/ufSrD/zW9Zm+auYiGhNYG1c2XevRCOa4jVer2z0ApFKGIZ0rjCGQdjKJpdxt3+9Mc0PH+8EgxOeZP2WV4kCWZuKtqeyESdM3pGrIMxH6vXDY7L7cmJGf6d8Imv56IC+mgWmzhtt+chODZaK5yhiJ1C8YEMms/Q+FqzK+RE9+UvHBvvd4Jv//oaGWURfKP8YdQPuGtj33QqkV7snz63oFzG/Q2qAr8x9tW6JR6zlHIwmQiQ2SgTMdx5/ttGieHvJyQ45c2k0Yoqq0ySWb0Qa3X3IwDk3bXNVBxkdnxuq/uTwGaxD83B0CL9KgaHojTxGKwNgbF2xpMlYa0gGlMRvG54YI4Jo1zbkx6XoHEkjZ39fnvxFaE1nQiVvTseU2plWmRf246wGI6zGLjG1br7iKoQwlr2+XHZ61RJbWRzYGPrrvhZig7WjUGCpASDk98krlfG5sgu86hI54tFekI+FgxOjc7PKLu86a5Hv27xxET7bXiC25E9ZLhLTl9v6BQoa4iqW2OoPM6nLc/QrXUyPyCihfgpeWXIqpO0rVrOft6DU57//W8HHjwK/cNXJtJ02201cMdEpKACyIVQPZGUZIwqEYk5ZcAuKamzzIGmpGFzRGoSfq8fYpqGLd/JqJ6ARqaZaP7LMRisfN/IGNu//3JCuPPEs3D9oCobl9VXPulNOkB1js2JyHpyYriooaZdYCImChilrsA7ExMn5t/qZBGZDvWvzhBbLWqJbeiD/JS7Gdxm3dqV8DlZPt22zfQ2Wpl1toIAB+MAMNZHNp2gup0gfF24ER215xmx9p7d0ZsAJYvN2gcO/AbunvlH30P7mYtGxpndwXNebqg7coJI1vfPoSzLB7qFCqjJ0P2uucFxDTftYjZFdU3qN6ibMUMOiC0sRYiPBSpbSDXVP9kRLfS+9iwebGu4SCcvGy/8jX+DduN1PsLo20s7oe9CJKJr4jB34koDVYln2HtLC4sZGE+x6ZCzJcxQ/1IFRqFCNlSWt6nu4aYZ4M7RexKb556MwXTtAiUv6K2TC0cjnVFtKTOj9sIDTDUDNFOk/XUmWxkTEXyqBfMQGbQx0HANzOdDpySfzKFytrpLPMt+Dj3zqaBxfv/W5Pf/6nIhQTqSmuyRTT6CMpOllT3XYiMQS7SQU4AuzK9IkwOaVzOs6BhBbxRQHI2JnCYS/JGX3/07jCvNc08Bzb+vzY+k5jxvxL7+ryBkISGzz4w0nt0O01TyWs3CfFkbWhNbN2GzJxLU4/h7mW9NVJhQEKMmNUmLmeQ8tcqQtUqDfcgDuDllvPCHb/sL61+lpS4BH0WVVuOQw1Ckhiqz2GCtx0q1qlDVDiAolQzBQ1ZUpIwhTwMzGfBISKmf7ryDMa7MPxr0iGMqpdUMpn2EdcjptoCj+z1ISiFPwP06arbA5qWKKYmCu7KsE4Lfswpl/k0R+ohXhXyKi1StX0vYVUjOOW+ncdDfnncR6NZtLAMUDmIthWe9ocbxAGniGu2HHDiGUdp1mdeSC0BQ7NGizfhApCeq1ObS/PJWBNWPovMUzj+asItC/+E/Ocyr7dlsm1wQ1CnomXlAKmQ1XznVcH4osVunTkzslq5GhXp90J4fKO3X5MscnKCdgy8FT+AAg2z54/z+J68Bf/+HGDFzX8U39+VmoUbvZkoCFcYbQ/dVIRl94Daf6q6HFBEj8HMmP+yPKwizEEIwVEdgpKCr83eOwa6Kuk+yUTqo2SCD7JwgR3tQZMjvp7q9Wgv0E4fJI0P7yKxRfw7tepuikyFhUcE7gn6pe1I2+eynEZ1SP3cqn/Z3/wftJ2fE13C1mVJt1b2cZpSVtCjkG+yb39K5UGuvdzgBnqJ25IvhbUTIOAMOjgi9Qi+r6kYnb4iOeTLwm6PPIbDyL7fIsCXILIgLz0FJdAJmqhkhHJG4cnUJAbqEgH7ur/8zAoSEY671vlRWA5rqkbgAO6XSCAGiPPnJ6scJv/P7fO7Fok1cr4DlJ4F3m+4bnwHrkrod1kM9XWYjTuTzhGoQpGkJVzADDo6nWxhq47LmosvkaoIsl5778lsPRvMnr8Yuy7/eCv7eNzjOpy6xl60AOt0KbKqqbOoYMIIEHhc2XMXHPkN273lAzzJEjloRIDkS5yySMHDzTJXlRs7VnPu2Uei/Ywfa//4exi/vUL/CcSgW9JnHrmde8jLSlsy59tbjfxcICNWziM1/S3uR4ZjplpPAPd6j72z6pEIhv7ri2lXYPKJLAp2dlGDX1t8lhFwG3j3RUslGsZF0R3LiYMOsE6ZkcUI657MX8auJR4KviWtAjbsMRfNshVAnwLYsqve2t570KfWcunS8379iQ8r0/TzfBlERPGi9Aa8x4prsgbTi4PIpraKuZbn9CvYJYNZd422NJSpv+0VRuKvRLrEFwNovVlsp+0ssIk1K+vRl1Lz4dOyutJs3YHjdFdCgzOZUyHWQjGZZnfI5FKsko1FjgnwqhS4Re0hplZFPS5GsBcLqg8nVRFZDEP2U1lnmky0yaJ6V4v1Tl40VfrvhS2F4AUZJBKsQ1VNfsfuwuMWa9KNekGLWbC+a7xEDVU6rUgwXFYk3Om5VEt1Qw0rUtV8Gsvmyo49OS9tnEv3OY7HLkpJC7RevwDApgON0yz527o9BAnxpRQdk8JbHXn7msjzKDxMu3LZMFTkvyZyogem2DZWjRpkRaphouf7o+zXnb16mO/khye+ftnR04P/8k6QAM2b17tOKshVg0WjVaYTWGxdcDMIpCMgFY9+qZ+iNxfb+cziGoAZKnszSqcr2mrXG/tB/fDgGrzsT2A3kdz5/50VnJeL347oqCvBOUc3hI2CuV9Ty3LXuMfK+jnJ0QnQCKmCfTM4Pb+TwCFf3fX1r1DSBXE/ka+/kliX9MV/anPfWUej/ZfL7ay6AG15pTTulKdjST7UD7vUOERS1m6Isuk8DtfrCyGx/SmHjYiWhAeHFAxgss066TBIpGcq/GIDm6X+M5sQ9QH7KBrafPDchwC85dNC6Im4maB3UvML89p0y+ZqwR8P5udWzcdnQPT6R3PgAVnvXvpBDorgd1n62tT1Yn1Uz86euD53lP2TU73ePZqNTX5CjAnVBUCyl2gLF1ehxUp10uXTfNHL3j2t4mDRYWKSnx1Ah+AapwiqPhDKf2d39pIIRslYMQyo56r7UvPZM2qPw04JQe/FZ3MG/LJSZo1UIBGARmZ4DCi6BEIKPOBsxzs3eYnZCjpKeJcpRLC2SNfOdgr0ym0qWVKtUBNlTyRJwbs/tk/GcFO+funSXk5DXAY55JHjmS9xuuE6M1VI6MjKGuwXYOCvTJSPn+hNOZSVbRkOqqiSTU040SWsL5oooWDrCu+7M7pfGGq9JY6Isng7y/+wdNO5Zg1YS5A8/cT74n77LvvcgVqYjdA5VxssaSpFkpzx9QWVhkExzyV10V1FD2yfSxbPpzZQgnCzNoufDRK4qiqBp5vMiK0cXQOQAtVzSwIfy0LS+f9ofY4+lywu8+mU0WPYstIkQ8vVfI5lRBRsfqO5T4MpMzcSFFJn5GA2JosYY2K8BABpuwQxADnRDbZyS6uVZPU5YiuakV2F3pVsKHl707m4dQHUL1itovVQZajFE1v0Bqr0BHvUZjAR/xnLpu0M0b6fhMa9dn744Vde9y7VmN9B1cPckiuM2eWy2QjLhXfEneLOe29U6uPL946F/T6VLCH0yRQZf+aooXj0d9tl9s4hX2xe113Or46Xvxi0oxjThVeuWcWtQ53zJ6SIdlRZvXnEGmuN+f7fDaq++CMMbNqK/+YaDA6lUggIah76RQLOOj40cc5aFswO4R+1+ji59v12hQf5oL6indSJChXpj3plKMFoHeXMcwkykY83yZXdP+F3pEOFNp2Pw8hegvT4pwVe+Bi67gGUw5fdbOfQq/FysIzxFxh8SeoatHlXYqxI5tXCbSgWjbvi6Cyr9/e0pbl7/50S7g/yf31Yg/0ff42D2pr4hAUNCIL3bdo70L7hkeIymj1yDOswK4wr36TgA31KiJDZWrc2wa1eZP4kdA7fWtmC800LU0GQ3X899CtHyvYD+PZVui1h3X0D6lxeHOmXo7gK+ZWsAdPn1eZVcwHBz4xrcNpFFuHsxeLVJFl5kSR7xrt08NjKDnTc64flolr6UkBBgV4V/9H20H303d5AfU0amZOR/lZhZfzggMNBzWwxTJrmarI5ykXiAPAHDhrdOJOe1lZwiFG8jaRObOkJlF/obl2pVkLZY0Ctf2bj24aEPIHr9STjQhR77qPwvlzt2EHeK8ONZNDt2dDeIgFIqmXek127DZfc00NtuC0JlC5s0OAScxVgoBeO1YetQ5CJiPEcfTc1LX5mfFbi70l51MYbXZ8h3xsTM1X5CA3ntlxml3SVFjnVBgYsQAhrEYxBUgI4zfdoyMRjwlrZ1A87yJ8e2cDVcA4DqjOIu2EiaKlRuMI1t3VuoC+8Oajk6hY+/+6j8zzvWK52SdA+IvPkHhJtvBv3wZtVg98CBy7o4UEMoURBAGvPDFtHEG98O7Any16/L1l+q9IRO+QlaEXJjkydGq3smC9ZrHyt00i8BRC7n2m1nkTn11OCwndiev22Pec2/orsz2KxbcuTVwIsLqNML7ETQfT3Lxqly7RtOQvPiE3BYlm3bkjLcDP7M1eDbOz7hv1KqylzcGns+R8iZECFqnpUg/wUJ3XYH+f/YQf57Ehr9EsamjIuw/6w9uBIgyS+v2IZ5dWqkSSC2HcuBu6EE4cFEFTEoyBLYPu/sr95/Qq7amqq7v2pR1k7h7VYM6Em4cwuNDGL4B035dEef++TDV/hdeeADQdPT+R//7/+V8u5fIPzwZolpyFaNdCrZoDh9cdR8NCfvBeRfeUniKRvZ8hZG5cQV5x9UNIGZ3xVTQnnxhEdxsxBXrLV5SOhaEsGf600Y2cCbLd2nCWlwc7r82GK5uXmDefV4IyNTC4dHTzBGmspDfpPpDScRjpBCT3giBukf/+BmtBd+iLvfEIijdkaU3j9sChMr30Z7hPyPr2P+0U3FBi11RLVhqRuoqKD67+B4JCSrehQcgImCUG2/E2s0tBHl7vTlu903WQESG/xuk9M9FJMLUNZoXVfGrAMxkFGV5PKjTf8u+eMPHgK/fxAKPfoxGHzwo8Rf3YT2s1cl13Ab4q1xzbMT5L/wxN1D/j/c1D0VBPzzW2upiu+NzL8ctDAc5lKFlpXjLEEHjHgqLqg8PPqCWXtDBsakrxbQMm/uXrMCDBICtN5TMgiKgQkh8E7FhrZmW6qly//r3Y/3D5NCf7gEg0c9BsOkBPj6JqJEMps/fQPo95642+vajZ/K/wD4r5ZK0eDTw+jQXoecDVX3YRpJJHjCya+A5jbN63bCt6SPEkvlZTCS330xb3L4HalaOrf4tbckJZuKWTIlOk4yGNX7cqUE3fL60N9Cc/X7cG8qHRp0yLBbyE9IMfzYBzPhy0XvIHBQdvJmBDvkVGROZbER9pNzMr9V+h2SeYRmaok0a5ujhugE5HwORDCVLfPOvjHcHYy8mXWj2jXIVnaoEFaPRbXe0hdXFFOl//ww3NtKhwa7E34H+Tvfd2Z6/X4wOEuZOX0gqiJM6r8GyC+rfKI+RhOUQZIGBxaKlv9pRFRav3j0bM1Jd7bosaAAmKk2PwK6s0Viztpr5b+SapQhljYe8dv4t1S6h0QPzz4zkz6EAMhyBBqEqXvUQAJun1oEsi3vBj81HAfCY+AsUIk1EVFVu0cARSHnQJfpuRP+5ldbWpr/i3TCAqqSCjHpAZiKKw9A7Aryho5/E6WD/Iv/EvjHm8pnE6lSZuF0jSef+yJXrkVKzvLmJd274hGYMTiVA4X3qLiZaJ1hD1lAYcqC7fPf5z8pZwhAW9anRSHeqDqs1ZFXF7rtWOaxRmmI/+knuLcX/mGC/Pe+M0O/W6XZd+RpZrbMbMTPgQB+lchH4Z5ZGYHKLbTPQZUopv4K4sRj1hPpS3qzMY6lflIosN6dUh9IfEwl62tdjQcJ//dn92oU6H41rH3vO3OeoCvGf2j8+QoEzrb9XoRiyxrQ630X0YEzOOhIjMGqPgW/TyFbYCv35CxjyLUCjHR7uPjV/y99eT+7ld/8iC4jhLDC2EK4166Lfk48ISWBTtzFlByhJUF+e9GH0Cbr11SL/DB2mf0mBOJAoWPVmopEBSSbZ8IvpjKZQrgN589c5Xk4RGHuDmBRg26MKQReKbwsiZc6Z+e9/8ZFcVgjTwtPEcc6ZYuyEBG2KtTkw4ueJ77jqq+AL/0c7i0lQ/5fvCtlCW9iclbP0PyLrYCH0Li8BJSMWRSy6E15o3N/yClaFSyaJxF8IIFwbPAIQIkndNVGmkh0ZHN/bKO/GEKTM+zjQ4SlYvTEGp8IWdAHRQQqkE7qFGD95xhHeGmvuQrD/7EatO02vV++TC6V7eYu9NpTluSZx3WMyNskXu8+trbCq9vdKxLBvbU9iEth9yKVD0agFwb9sgo8R7S2P76xML1z8atT6ounDV40yRPbCL9nK/pPmmzwBEZ6k7KCtOIAbAQ51GXHHRied3ay/pt7kBskZOOFL57puUVH3FbMuiUpI3MbvmcgLPOS5YcLthL166fatUAdPVPj64XFW2eZ3Dh5zuYl/WGO/80gJE0hdflsSWdPRCCOWKdE4lcKapW6sf5z6d9GHEmlWxAavv0t6fUHI8fCPpByblxt95PyX326uvJEFYqhe/QU4kqMVFpjJbDwrZjlOJF9N7Lb1XyGHi5MdC3GlLEI0JX2uFdvYtJfD5FqSYArxqHVE6lKXxolOwp1HTFcsRQHZEvYQS7dz8cPP3GppWjzIBqPxUJqh3dpmfnkuHij8yPvKTrL3CpzlXqvU8QehOvnQAADMSylDdGjHZudd87mRePGO7GriRjycG2D5niFdyEAAchgaxBBjVi2ZspHsolrEwp0W0dp+a7vB7hHS4L89txzOFk/kY1KBFWMEJp/DagHU35E56siIehP04WFIdmwqXedadQg28+gOSRP/VTCB3uYB9+sWl6YI2pAFogwxvd7HbspGQUanrbNSyM8oHoVhBhZAFHNRn6fFGDs/YD3YOmgvv3oh4Ftt8qaqe6AYI+rG4Sdtio0mWExjto3QxdSJOrLqGi8gH3vhTBohkmfjH0rD1C8D6rF5veNM1joGdAHPDvv3BsX7WrsE7ubmJQ0SCjA04XRVpYQLKIarnU6UxoSsKPwjJz1M0UnDxMlaL9wbeIo63ULtduPx+rk7Aqq32TbNaTI1mwp5XRWyq7QLpbNvT7EmF6ytkK93KVoThfaN/1Iso0voLNWKZa3dnfj3y0C5An6vYQC0IiAbYDyHKR6mbJ3Y0j0aRDtVtbbKcA9qgR33NH9hnBh+V0JKGZWKfxGWXrld5X7hHxp9NuwhG1IEIU9lazoIi7Wkm7eetkTmKtqMw8hNbrGo4tyYuQqJiOmATYm5v+C3U3DbhEg1z2kFTzgWwqaqyZLXAvXbpIZUgJSLSBZhggw/3rZTFH1Uw+9EvDNCfI/8pG8KdSAksuOHA79VKRTzxqryPJrfH+NAp/qQwmJVRPYDDhs7LBaKXADxFWW7i7uRgOr3l4tyfKF/KzGJ+ZUds5h1Z7motnTCbTlwtmWsFaFb09MYMe50tuKH4iWl7fUYw46Av7ERvBlhzZE5Gu/gOHqtfLbAuzKaYKXOZawzKE5qIAleBz17YelEDZvIMxLb+2khGYM+T0l2fpN4TcEhVdIEkkR3dpi1jsbxOzF7ebfW8o1r52/bvMs9lD2iAD5pJ13rWsH806j7oFSqsFknFZ0va1yYqySjqmqbhSNhCg68E/MID/i6WAjQfe8ofcnyL/pZkuUNDIEI88CsSp0Us6jL4pn6uyCUrCvuNj5bUZxjhGFsahGbahp8gMbFN2VJdpdfOZaIIrXelscwtBACrjL+bdYtxezsmcEyO2mpeKW2hXsc6LyNa22e+LhgGhTYROp6c+W9Uiu5LINjMs3Mg5S4ZsS5L/5rdxBf4RQdVmRYAUIdromVsn6LQcyppV4ThiKHCUKEB4sR3QiAjLo+dAkkW4eoQAeYV0ptoOea8qNDlteQes2b8delL1SgK5MfuuSzantdeSoX90g6dheetmye1c5zhbq5PEJPgipGX5iA/HlG3CgC3/+Om7fdRZ42+0+VQKh8jb2Uma5muZCWuthSlSgfAdcPWl9pB11JRRdQaXwMikWgVTxvluTYm/Vhvc8X3VBgv7N2MtC2IfCi5cvaCcnv5N6OKVX1wxZ8g7ht8igqhzWDkDOte16UfHm1GXjnxe4r6X7xfDul0M7q4/MPKud8nIPtYoLCLoaY3oltRSmWd2bx+9iuW0cpyaAfD5CnToHTbjLSpx8OZ2C8zAGVb5XLq4hoOw23jpx/qZF2Iey1wiQ+5NcQTMYLEn92F76Z6vhhlYU0NQYVTF2G4I6Xl/WJNs1wZfPYL+R4JataFe9DbjJcvnR2nTzDnsnjcxb6KIPcyOZe+1e2fdgy+QQwxULZnMx0GUjb5l1LmJjWrd1jvw1sEl2HdMvuDLf9OkXc8xLsI9lnxQgd+ybF86mrqwyV6AdZjUc6ZxEUaV3NTki9QPCvAoJg2+eunyG764StJ+7DsNVb0+Qv00bB3qeMjpcNjuTJBY5DLtgweZ92flLGFvwELUQQ57ETpFmqR9bRneaX8jcAtnlmt5FrThtWsDbG9bfLwPcjXLWv3x7y7se+rgFCbuenAfUhIE0sPRZIYdhUk36LLtXoPCpAXGelbzC9r1/yNyIjnnk3rmpjuWf85fA578oMBtcMmk7gkbRyrpXiedNqOShqoIT3Is7T7RdUjD2EFyNMHilFWRw7zRQ8FIjJXWpXh+s/mAyVp24rnRk7X3W3XC3bsbYu8ndRWmfePoGpnZZ7h0FRyB+Chj1+9EfxzVvjvl0rSnV0f1Y1Ngfjojlxwny33Me5yeGWC6crA5d1dNJV99vPfLcvvtg6Us5bjQ/i8pvygD7cxW53NkD9sQPRZ6D0XE3ygq5PO5YHiXn80SWRWVfU/F5Kgo5M3nB9S/A3Sx7lQfYVaG75lbwbwymkH92zr1T8Gj6UilaQQOnzcpsZaFNQKH87R4QRbfdXn417EGjzxLm67/G7V9/hrBjh3KlsDmCLcSHRSzMFPxzIazkilc5bQRBIlBAOZM9BascgA19GEUn6hlRq4U9WMvUQlMAkqQwzpQ7WiXiNCwgnp1I4Tn2o+wXAnTlzictn/oNDDal9MSUM2lWWO+xYyBuhtTn7VZM3LwyGZdQS85PAznmkaXiW28H/v5b5UkgZElbea/X9CAZQFyPz/0oGzsRLY/8fYFns+AQHUCtXudQLJqUNPgc2N6IclH1jAHroz/PqN4N5H0O+f/sSm4ZDHkJffiGrdiPst8KkLuTlKBFsyn1eiEHshNhEGH5c9QFhMGFzRMeYrILs+dGXMj6uXZFcVOFn9fGR7LocqtUbLsfpAoevTfP+X9vYcZdB/dD3aqPCNBu+OIK0SgiRKXRG0S441lbh3cNl8y/cN9JX7/scxQwrtA31882aJek3m2VOXXtzUaiO6f8O6hbNZ9cP4QgsvD+9+ETqdMvH0XUwfEaIzc+KPbeWsCn9hqwJ1xUdbwCFuZeAlADC9/uG30KwYXvGuH9gvMXT/yTb8UhVcwk/MkDIvyuHBAF6IoqQer2LHRm8wFLEXugJwStTGC5XiZfx1rn1qmYq5t6DVxch5kxPIM4XbNRfRySP5dHZpgM14s1xoUe/UvCKtxpBPVkR/mw+mknMAc7910BrHf2e+yofMJhjwsypc+zky1Pz7/wulkcoHLAFKArWQlKMmLWMYCrwQHwhQ/41wEhR0Jn3xTF9twe9HK5ujE2BEtckNPTvsF9W7cMBgL5Q6g6Lu2RjYHqEK/ySbJTMCe6giJYWsnVTqtTnVInVDqkBiCowdgy2Q6n99fn98sBVYCuZCWYx8cltzkj37g16thh6Fo+tZoxlyuotnF/hmH8UjimOIGyFKuykmCOup+x9faMa8SzYOAsxBpV3JZdgHXfrtRkIoMrNPBsocJ38WNc3Hs1TLX20o780X5ZCJouS2tnM5OTO5ccaOGXlg9imXvq8jUN410FVjWmZdu/BpEdg6vY1q0muE+1iXjMYcOgO1iNY7dGJo06aZbwTyydJOw0JA5MnzSuJ8QcPQmBizt0q72TzHYvRR1pVGNSiKH6gQ8Sp5RzL5j3kS+vxEEqBxwBYpn8+vo1aUSr0jB+EezNhq5f5L8sJoqgAX32FZOgQI8QFh9Mxgtr5VbCpjsrSn5I3IfYc/DmnrSEhOeoeUbA/BBOhE73vJq/j70yR8LorQuk1269ZcXBFL504OAXnk5hYotN6e1UNpxMwFqOaWKxKmVf5sRJwVmtVzBViIDG2YFIBL8Z0IIp+gJZBYQgkWUrxUPpFm5yClDQhxGzg0Cw8gq9BG26U2UfYCtIVFwRINkFRarSKzKlm51sBsnff2ErDnI5JAqgZe4Pl69rwG+EkDlUKVhGTNIopBay4Dl3EXgdEKiL6CdmLCoDwg0bejJpIqjAtfZC2g6uwPMRAVtIggEN0uSGmYoPRjdCrlShfyr8cEMJLpi8z6/X7O2Gjv0th1QBupJ4wXQz4Es5Zw6hDCzcwhwsTC26xw8Io8mhMrscwN8Fb2sBjWOIth3RABSVMbwPHIP6/TPlg64LMIhrJxT5SlBAV5asJLekDr9i8sLrNuMQloPKAcaVxAs2J1kflyZ3jYk7snP53L3ta2edEbJz+juozOmycU4o3cyhYaPQa86ZyD2IhpXVccDNOT7mWY9GC1aR9v29RA1C8vUr5NzE2sH8Xz/uUAsfuAcQIJY7EzeYBJ+fgrWlxrrH5eYdisVvG0Mux/Maq5yXK1HrIuj2TQPekIPXDGTlYgIyKNeoXVbsmyPT2AimtnpbRQw85cadA6w4kImdfS33qAJo4elTT2uJVyc8WuSkS0iaQLcLS9AeSvyiiwhEMEKtfgdRgJ5guL8wYzEKI65TVFwlX48e/5DcBLyfPX6jsL85va6dvOTQW3y/HBYKoIWfkRSBeU2arIWST6OIANGiytYstVLftNPPHbg1C7pIfZVghTzaLVdkLL9I0X47EWSKZfdJqjWLcMtTwcCjZLDjBjemf4eF4LUcVgqgZe6Ek6dTx1YD4SEVPQJGmkSprNYjCw3ghMGX98J4LJyj8JweIYMWEpZQ1bXAogF/pLwt66oCSrv26rO7eScP185ff/gIXsthqQBa7nzOSVOTw2Z1muBp1p3IMcaP0UFXgvWrpVPTf0pHd6o+l0VzD/LPcxO9bFxUrn541w/9TAlTGNeu+zXmNt53/Ze34DAth7UCxLLzWScvA4bL0gQvTb1eEC0wFxVAFnj5uToXZK0k7jJiSMjCMKuETk34yLeXjTsn1bM9/ZtpwZdNrv/8ZhwB5YhRgFjmnnPSdJr95QnSj00CWVxgWuw83JPQCamx+JzDNis2oeu5Eeb7RM8SUoF4qhIkpZhN386kTxsnJn65hdYfmgTOgSpHpALEwslNDCdoMXF7fBLE4iSRY5PA798ng5EDVJatC1TK0ZXVm1sI2cBs4TybHMWNPOAtw7nB5vlXzsziCC5HvAKMK3cte9li2tkuSIqQFKKdSqNcSMVtdN8tSMNeCNJMABC2q80KeZtNf2aTUm0fDrA16c3sXFqPP9KFPa78f3JWYVNfaX2rAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
});
var mo = he({
  name: "Morphis Wallet",
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
});
var Ao = he({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
});
var No = he({
  name: "Spacecy Sui Wallet",
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
});
var Io = he({
  name: "Sensui Wallet",
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbLSURBVGje7Vh9bNVXGX7ec87vtrdfdEA/oN2AlAyIgMKq4qbrwrJlGQuJupGoi0YTXZhmKxqdLnGMRI1LXEzI3By4LLiPxJmpi8im0aESkqEMh2yEjUHH+kGBAu3uvb299/7O+/jH/ehte9t9tKsl6Zu8ucnN7z3nfc77vB/nALMyK7MyK/9Pkene8Nj8c9V9Ib8Sc3b9oLWIO/fc7u49T/4Wm/yMB3Cy7OSyRMT9KWGClpgLELMB4s4hbt1LkMjNd74tF9/vmma6nO/GwYpA8GigbLEgHLNqSVhiXUr0Fx9k3WkDUFERXRbQX2tJOM067qgFIAJe9/PFrJ2xAEzKNjhS8qfuqLlfwmaBVCcVC2csAGvCXpt3FmOch1MfK1f0zlgAlRm8acgXHAmrI53P0Wr3t7vkwowFIFgZlxDtQj3kkI8E4Qg68kXPzL2XRB/ojL7eFGrklnjEfTxmAp9wZftPu9SzXz7TmJgWB/41p+frB2pO//FI5ZmGS64TH6zp/KTCvChABSDnrMpta+ML/vF+N/11Q2+9M5fNHXBp57Xq9Le65fyHDoDX0b18qOeIAMuH/0TSwGxeE1uw672s8YeGC6tS4n6UtqYtDVuTMkYyxiRDyr8heOA7p9yeDy2JDx/q2mzJ5YZEQcEo4He+Ut19zzOgncj+hbrzm0DZa4iN1nOOo0qgCqcatYJrDfHciehbDxKvVk05gK3YagTYMsL5YQ2Euu3Ksu6W8ez/PK9vPRQPW8W84u4b5NSpggLXVV6xBYIdREf5lAK4tfIb1xvlEguipCp2Dtaxs5TtPxtjdYHqowacZwsNTIf7gCocFQGJrrKopIEvpE3i/ikFYMXfaUufPoR8sr8ice/VXZcnSxqnB79rgKW2MLjlNet0PhKOipgL8I5zIPDNJF77zJQAICiGerUBMVZxLGnclk/3LY+Vst03p+cqS95hkAU7YgbSfCdWBKqxQPVtFUFvWSUVUgUr9xGUSQN4o7JjtSHqDYERqkgFYbixNdbUNx7wiJgfClljiuhmRg1yEer2ICUfqfH9rY6860ykPPQiUOBTCby2+t38c+9KH5U2AUsV4PaWVMvx8exeru65BpQbDATI2ROAleyvg0IUexDO3Xprv/TnQD+0/7L+dSryRQUqYe3X4HH3pCLghKtGU0eII5WD0ScmpJ6RLUJUZOmT3SgbvcLwFnea/t5nc85nz0TYkBx6XkWQ06smTSGjaB6TvJD2Row/uxyu6F4L4gaR/CZZ4BbDSeyou266sODoaNvaTNorBAqBCpqJ42WTopBAoyMzSY43Dy3aO5FN2vFuAaoLzJPs6VMAAwHJAQ7xwQK3Rpa85fnbvVCqL0DqAXR+8AgA4YjkFdkhEI57+lW9KyFy24hZhYDk6QPCqu5qG2rsKJH4zkNu9hB4CLxIoGUSnVQEVMMzDsNTQpLuwETfJ114j2V2UykCQRCGAgUHyxh5pJTtubJTN3qgtWBJIIMUJ5UDEZjDxQl82kXGffp4qaZrndBuIorqFodBCAgBn26NzT822rajtqM2JeE2FSCvNBjyKcQnV4VU9hV30BNVc+aV+u7VurNV3rgfe0GEACDFIAghASBmMnikBHUMUnqfh7QW6AOBwsQWYcW5SQGYGy49YMCBfARSTm4f/c0zoD3ruc1D1jN36CxKgjyVLPls62DToTEPXhUnbwJkM0VQrCHYIZBwUgAEoobYmS+hBL76q8bEhoLzzZ3R2vnnf+LFtKvkSCICcvRtgwOhD7ePXv9o7dFFoHnIi5R7ERQrYfZPyYWGeLM+bsNTBMt/33AFhqxjxIf/ifrwYoRYFaGvD1QLo7HNXdots7w3AIzXBz6WuPz7xeu+Xt093/hwL8GVJbZNgWy7MrnkwKSnUcHSs0L9gQVRnx5iRkRCMWszxl4fitSHEHgx8PkOCoC535y8xaDvp2MrXPpnoWDl6JPP6YlXkosPTtmNrFJXbDfA80sGY5IWi9CYnOadBxTIgsh1UmZp8I4Qt6/pX9NfosY9TSBT6LxFSsrDmyB+ygAIRFM+/NLiZOJv5RoibQwyYhAiB0SyqiJQk48C4iTa18SaSnJ5RaLpL572cxATKy6fEHkjFTn/1JQ/bNVi9cUyJj9/RTKxw8MwIwYZIwhlmEIe+UHMdKvXuz4RW/D4RGuuGmzeHYrZoMZ05qiTCcn7S0dsCl7mBK0Dt/TNvcMws1GN/D0Um8hIAQQ9pE8hf/VMb7gm1vT4e1nzo7GF+4YkbAPxlBK//F3isd9M28vcEwuHllF9S0CprtDMQJTp/97YV9eDWZmVWZmVWbkU5H+A2tIeEhTccwAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
});
var bo = he({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
});
var wo = he({
  name: "Elli",
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYySURBVHgBdVdLbBVlFD5nemtvuRLKGxMTaVlBUgIREzExQJCFCTG4cONC6ka3JkbjAhMxSCExutTEhXRhjIkJ0bjk0YWBghBLqZiItnFHa5Fi+m5njuf5z9xemKb33vnn/8/jO995DELlarvx9/GCsI+A9iBm64gI+eJb4g+75F7X7YYfESD/kd/KXqju8X28Lt+DvPsc7Ht6ID3Sz1/Hu2AFz7PwAy5AHpkQl6IK9DPj5SIMULvEhuq+dFUfqG2mkDUMQxsdgr3d05nKyeEy6zuox1Vmof+Ihd2jWFWYBbGWyWYWCgXaWpH2xb/LIpFFIdvO7YEczhsC1//sw7bsazWvFTL33KBl6QZZLIZHAaWfIwfXjwcaKEHR/XEQ6M0aZnSc2BzZHfEVkeiaUnTRDcFSoG5yjiQ7FAXxVf9cpVmoshDMD1RwjiPc/IPKKMUTcrUlAXFVfLFUXEXAOUEIq8+b9sDEmUvTNYuVyUFncBgsHpjlaMTDZIsbSWFMkBRLw4vwuQJaIJuM7qpBInKklseLoLrZlRcI4Sm5I0aQpCQAgsyNwCpokEKGHsQaKeNdVxyShaxMfScoJnKSm52FhZS8CjQTYtUaEuCHU/xdQ/VVMYYgm3NFD9WvXSWcmUFoAhMg37IVlnp3q/Mdo7egbXIi4AOvRJBv3Ya6J3D1whblQX7UglqYueFRfPijPnQVN5w6CasvajRg6vRZ0JCIwMYa7PrqS8DZ2Za9D955F+cPH5FTaIIZmcyzDaWs8YKEgSEDUNiMXO1/3cX1n3/6GOVnYHlHj9OwQP5NU/1n9Nnqax0bVhu7CxpqL1ZW5CyWmVQ7++cFqbL8sDZ5DzacPtXikSrv72fl3RBCtFqKET1iRH+LERnL2PjJKZY5AV5h0Z3WaGRGZ3mQ822uCVUfugJtExMt3sy9dBiWera7N+JBjlG25bc8W+ztbTkn/Fhz8YKdi1JtLEFFgDTjybMrh/kjh2mlp7tFUOeFi+zRjNV5NtaoK0I1FOIl1YeGWs4ts6yZY0dJUbbeApYlQFmUWzTrZBPkjTpOnfiAWbylBU72hNrHx2DNpUsqTHjV+OFHaB8fh46REVytXGT8y7Ko0YmWvI64hi7n3hQQat55HxActm6GqTMftxjRefUato+NSYjQCk1BtX8mGOZ7sPbb71qUq4xtm8nJZyFztEVfBgaLxpNSW+UYMSHZCLp/4v0mYj1x+zdYYeP+e/01kP1Cpodv9UkqslGTaZ8S9uxJlrEJTDGVmaCVq1DSZ6BCck1F9DLnfVz7/MqOZ+j+h+81Cc7mZixzytChkLZq6NTZj2hly0Z0eUo4DPK64Ywgy7n9c+FnMEYC7wEUJVdu60O/QMFeLu/YDt4zSe5FXDY3p04VTzY4RDc0lAvPP5dmhmjlROXYoAqsEnrXSp0KvblEWTUBoqxj5A6s/eZ7/X749hs4e+xl48WV69D12RewtHsXLOzfB0vd291rnyl9HmrqWNbhIKMUm2iveYLVRijjSLFtE80deZHr/04yMt6wEYz3iFFyLfbuhPn9z2Lx1KaScFp0CDEqIJg88pRHHB0sjP0Bi0MkJ4oYSqOhkeZKfegmN6hZXHhhnz7pYGMEoUX2vjqqgaMXk4zPCpB2aN8ZveTJ6cMIGRZYOVkOGclMrE4/WFIlzXvNUxakx9A0nxDWvAaENPRRyMOC6Vh6R0jjNUFpp53T9ayZvH4GnYHBA+/9PA+QppPPdz5++bwGPhb5+EKYFDq4BNXpmVxZxUdI051HEZWYptz08ExID3hxPWJsp8QDCrih+oJRplGMmNrZ4hsTmyucl3xnNhc5YjmX2hDGCNxCKCtgsDd1LmU6KIOp8gJCXsCkgprO1JRSqy2rrDjF+zKtFvHSIpkwyEvFgAmjNCR4u9RqF0okHVOltLZNmIUSa2JWHd1I0laNqcpa58QmRykfsCS789Nl/jqYalCFro/6hmZ8yysmR2parQ7YZQyJhmnX0b02CS4uv8qah6P4UBqZCkchOqZOQIQxB/ge6/E60vHPeCdMBQ6j/RJGXygGqXP5UKsjv5/v4/mFX5fggLP1Eflcca3ZeV/zVMFgs/cYhGkWyU7CAOx85Vyc+x+o7DqjAADBkAAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
});
var Eo = he({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://tokenpocket.pro/"
  }
});
var Do = he({
  name: "Frontier Wallet",
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
});
var Co = [
  ho,
  go,
  ...[
    po,
    yo,
    Mo,
    mo,
    vo,
    Ao,
    No,
    Io,
    bo,
    wo,
    Eo,
    Do
  ].sort((e3, t3) => e3.name < t3.name ? -1 : 1)
];
var Le = ((e3) => (e3.STANDARD__CONNECT = "standard:connect", e3.STANDARD__DISCONNECT = "standard:disconnect", e3.STANDARD__EVENTS = "standard:events", e3.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", e3.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", e3.SUI__SIGN_PERSONAL_MESSAGE = "sui:signPersonalMessage", e3.SUI__SIGN_MESSAGE = "sui:signMessage", e3))(Le || {});
var ue = ((e3) => (e3.UNKNOWN_ERROR = "UNKNOWN_ERROR", e3.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", e3.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", e3.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", e3.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", e3.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", e3.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", e3.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", e3.WALLET__SIGN_PERSONAL_MSG_ERROR = "WALLET.SIGN_PERSONAL_MSG_ERROR", e3.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", e3.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", e3))(ue || {});
var br = class extends Error {
  constructor(t3, n2 = ue.UNKNOWN_ERROR, r) {
    super(t3), ce(this, "code"), ce(this, "details"), this.details = r, this.code = n2, this.message = this.formatErrorStr(n2, t3, r);
  }
  formatErrorStr(t3, n2, r) {
    let o2 = `[${this.code}] ${n2}`;
    return r && (o2 += " | details: " + JSON.stringify(r)), o2;
  }
};
var ie = class extends br {
  constructor(t3 = "kit unknown error", n2 = ue.KIT__UNKNOWN_ERROR, r) {
    super(t3, n2, r);
  }
};
var Pe = class extends br {
  constructor(t3 = "wallet unknown error", n2 = ue.WALLET__UNKNOWN_ERROR, r) {
    super(t3, n2, r);
  }
};
var To = class extends Pe {
  constructor(t3) {
    super(`wallet does not implement function: ${t3}`, ue.WALLET__METHOD_NOT_IMPLEMENTED_ERROR);
  }
};
function jo(e3, t3) {
  let n2 = ue.WALLET__CONNECT_ERROR, r = e3.message;
  switch (t3) {
    case Ue.SUI_WALLET:
    case Ue.ETHOS_WALLET:
    case Ue.GLASS_WALLET:
    case Ue.MORPHIS_WALLET:
      r.includes("Permission rejected") && (n2 = ue.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case Ue.SUIET_WALLET:
      r.includes("User rejects approval") && (n2 = ue.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case Ue.SPACECY_WALLET:
      n2 = ue.WALLET__CONNECT_ERROR__USER_REJECTED;
      break;
    case Ue.SURF_WALLET:
      r.includes("The user rejected the request") && (n2 = ue.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
  }
  return {
    code: n2,
    message: r,
    details: {
      wallet: t3
    }
  };
}
var So = class {
  constructor(t3) {
    ce(this, "standardWalletAdapter"), this.standardWalletAdapter = t3;
  }
  get name() {
    return this.standardWalletAdapter.name;
  }
  get icon() {
    return this.standardWalletAdapter.icon;
  }
  get version() {
    return this.standardWalletAdapter.version;
  }
  get accounts() {
    return this.standardWalletAdapter.accounts;
  }
  get chains() {
    return this.standardWalletAdapter.chains;
  }
  get features() {
    return this.standardWalletAdapter.features;
  }
  async connect(t3) {
    const n2 = this.getFeature(
      Le.STANDARD__CONNECT
    );
    try {
      return await n2.connect(t3);
    } catch (r) {
      const { code: o2, message: s, details: l } = jo(r, this.name);
      throw new Pe(s, o2, l);
    }
  }
  async disconnect() {
    const t3 = this.getFeature(
      Le.STANDARD__DISCONNECT
    );
    try {
      return await t3.disconnect();
    } catch (n2) {
      throw new Pe(n2.message, ue.WALLET__DISCONNECT_ERROR);
    }
  }
  on(t3, n2) {
    const r = this.getFeature(
      Le.STANDARD__EVENTS
    );
    try {
      return r.on(t3, n2);
    } catch (o2) {
      throw new Pe(o2.message, ue.WALLET__LISTEN_TO_EVENT_ERROR);
    }
  }
  async signAndExecuteTransactionBlock(t3) {
    const n2 = this.getFeature(Le.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
    try {
      return await n2.signAndExecuteTransactionBlock(t3);
    } catch (r) {
      throw new Pe(r.message, ue.WALLET__SIGN_TX_ERROR);
    }
  }
  signTransactionBlock(t3) {
    const n2 = this.getFeature(Le.SUI__SIGN_TRANSACTION_BLOCK);
    try {
      return n2.signTransactionBlock(t3);
    } catch (r) {
      throw new Pe(r.message, ue.WALLET__SIGN_TX_ERROR);
    }
  }
  async signMessage(t3) {
    const n2 = this.getFeature(
      Le.SUI__SIGN_MESSAGE
    );
    try {
      return await n2.signMessage(t3);
    } catch (r) {
      throw new Pe(r.message, ue.WALLET__SIGN_MSG_ERROR);
    }
  }
  signPersonalMessage(t3) {
    const n2 = this.getFeature(Le.SUI__SIGN_PERSONAL_MESSAGE);
    try {
      return n2.signPersonalMessage(t3);
    } catch (r) {
      throw new Pe(
        r.message,
        ue.WALLET__SIGN_PERSONAL_MSG_ERROR
      );
    }
  }
  hasFeature(t3) {
    const { features: n2 } = this.standardWalletAdapter;
    return Ot(n2, t3);
  }
  getFeature(t3) {
    const { features: n2 } = this.standardWalletAdapter;
    if (!Ot(n2, t3))
      throw new To(t3);
    return n2[t3];
  }
};
var Lo = function(e3, t3, n2, r, o2) {
  if (typeof t3 == "function" ? e3 !== t3 || !o2 : !t3.has(e3))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t3.set(e3, n2), n2;
};
var Oo = function(e3, t3, n2, r) {
  if (n2 === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t3 == "function" ? e3 !== t3 || !r : !t3.has(e3))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n2 === "m" ? r : n2 === "a" ? r.call(e3) : r ? r.value : t3.get(e3);
};
var It;
var yt;
var bt = /* @__PURE__ */ new Set();
var tt = {};
function xo() {
  if (yt || (yt = Object.freeze({ register: Wn, get: Ro, on: Uo }), typeof window > "u"))
    return yt;
  const e3 = Object.freeze({ register: Wn });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: t3 }) => t3(e3));
  } catch (t3) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, t3);
  }
  try {
    window.dispatchEvent(new Po(e3));
  } catch (t3) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, t3);
  }
  return yt;
}
function Wn(...e3) {
  var _a2;
  return e3 = e3.filter((t3) => !bt.has(t3)), e3.length ? (e3.forEach((t3) => bt.add(t3)), (_a2 = tt.register) == null ? void 0 : _a2.forEach((t3) => Yn(() => t3(...e3))), function() {
    var _a3;
    e3.forEach((t3) => bt.delete(t3)), (_a3 = tt.unregister) == null ? void 0 : _a3.forEach((t3) => Yn(() => t3(...e3)));
  }) : () => {
  };
}
function Ro() {
  return [...bt];
}
function Uo(e3, t3) {
  var _a2;
  return ((_a2 = tt[e3]) == null ? void 0 : _a2.push(t3)) || (tt[e3] = [t3]), function() {
    var _a3;
    tt[e3] = (_a3 = tt[e3]) == null ? void 0 : _a3.filter((n2) => t3 !== n2);
  };
}
function Yn(e3) {
  try {
    e3();
  } catch (t3) {
    console.error(t3);
  }
}
var Po = class extends Event {
  constructor(t3) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    }), It.set(this, void 0), Lo(this, It, t3);
  }
  get detail() {
    return Oo(this, It, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
It = /* @__PURE__ */ new WeakMap();
function zo(e3) {
  return "standard:connect" in e3.features && "standard:events" in e3.features && "sui:signAndExecuteTransactionBlock" in e3.features;
}
var ko = class {
  constructor() {
    ce(this, "walletStandardSdk"), ce(this, "walletAdapterMap"), ce(this, "clearOnRegisterListener"), ce(this, "subscriptions", /* @__PURE__ */ new Set()), this.walletStandardSdk = null, this.clearOnRegisterListener = null, this.walletAdapterMap = /* @__PURE__ */ new Map();
  }
  activate() {
    this.walletStandardSdk = xo(), this.walletStandardSdk.get().forEach((t3) => {
      this.setDetectedWalletAdapters(t3);
    }), this.clearOnRegisterListener = this.walletStandardSdk.on(
      "register",
      (...t3) => {
        t3.forEach((n2) => {
          this.setDetectedWalletAdapters(n2);
        }), this.notifySubscribers();
      }
    );
  }
  deactivate() {
    this.clearOnRegisterListener && this.clearOnRegisterListener(), this.walletAdapterMap.clear();
  }
  getDetectedWalletAdapters() {
    return Array.from(this.walletAdapterMap.values());
  }
  subscribe(t3) {
    return this.subscriptions.add(t3), () => {
      this.subscriptions.delete(t3);
    };
  }
  notifySubscribers() {
    this.subscriptions.forEach((t3) => {
      t3(this.getDetectedWalletAdapters());
    });
  }
  setDetectedWalletAdapters(t3) {
    zo(t3) && (this.walletAdapterMap.has(t3.name) || this.walletAdapterMap.set(t3.name, new So(t3)));
  }
};
var Qo = ((e3) => (e3.DEV_NET = "sui:devnet", e3.TEST_NET = "sui:testnet", e3.MAIN_NET = "sui:mainnet", e3.DEVNET = "sui:devnet", e3.TestNET = "sui:testnet", e3))(Qo || {});
var Fo = {
  id: "sui:devnet",
  name: "Sui Devnet",
  rpcUrl: "https://fullnode.devnet.sui.io/"
};
var Bo = {
  id: "sui:testnet",
  name: "Sui Testnet",
  rpcUrl: "https://fullnode.testnet.sui.io/"
};
var Wo = {
  id: "sui:mainnet",
  name: "Sui Mainnet",
  rpcUrl: "https://rpc.mainnet.sui.io/"
};
var it = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
};
var Yo = [Fo, Bo, Wo];
function Se(e3) {
  return `Failed to call ${e3}, missing context provider to run within`;
}
var Go = {
  configuredWallets: [],
  detectedWallets: [],
  allAvailableWallets: [],
  chains: [],
  chain: void 0,
  name: void 0,
  adapter: void 0,
  connecting: false,
  connected: false,
  account: void 0,
  status: me.DISCONNECTED,
  address: void 0,
  async select() {
    throw new ie(Se("select"));
  },
  on() {
    throw new ie(Se("on"));
  },
  async disconnect() {
    throw new ie(Se("disconnect"));
  },
  getAccounts() {
    throw new ie(Se("getAccounts"));
  },
  async signAndExecuteTransactionBlock() {
    throw new ie(Se("signAndExecuteTransactionBlock"));
  },
  async signTransactionBlock() {
    throw new ie(Se("signTransactionBlock"));
  },
  async signPersonalMessage() {
    throw new ie(Se("signPersonalMessage"));
  },
  async signMessage() {
    throw new ie(Se("signMessage"));
  },
  verifySignedMessage() {
    throw new ie(Se("verifySignedMessage"));
  }
};
var wr = (0, import_react.createContext)(Go);
function dt() {
  return (0, import_react.useContext)(wr);
}
function ln(e3, t3) {
  return ln = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o2) {
    return r.__proto__ = o2, r;
  }, ln(e3, t3);
}
function ht(e3, t3) {
  e3.prototype = Object.create(t3.prototype), e3.prototype.constructor = e3, ln(e3, t3);
}
var gt = function() {
  function e3() {
    this.listeners = [];
  }
  var t3 = e3.prototype;
  return t3.subscribe = function(r) {
    var o2 = this, s = r || function() {
    };
    return this.listeners.push(s), this.onSubscribe(), function() {
      o2.listeners = o2.listeners.filter(function(l) {
        return l !== s;
      }), o2.onUnsubscribe();
    };
  }, t3.hasListeners = function() {
    return this.listeners.length > 0;
  }, t3.onSubscribe = function() {
  }, t3.onUnsubscribe = function() {
  }, e3;
}();
function U() {
  return U = Object.assign ? Object.assign.bind() : function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n2 = arguments[t3];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (e3[r] = n2[r]);
    }
    return e3;
  }, U.apply(this, arguments);
}
var xt = typeof window > "u";
function ae() {
}
function _o(e3, t3) {
  return typeof e3 == "function" ? e3(t3) : e3;
}
function fn(e3) {
  return typeof e3 == "number" && e3 >= 0 && e3 !== 1 / 0;
}
function Rt(e3) {
  return Array.isArray(e3) ? e3 : [e3];
}
function Er(e3, t3) {
  return Math.max(e3 + (t3 || 0) - Date.now(), 0);
}
function wt(e3, t3, n2) {
  return Yt(e3) ? typeof t3 == "function" ? U({}, n2, {
    queryKey: e3,
    queryFn: t3
  }) : U({}, t3, {
    queryKey: e3
  }) : e3;
}
function ze(e3, t3, n2) {
  return Yt(e3) ? [U({}, t3, {
    queryKey: e3
  }), n2] : [e3 || {}, t3];
}
function Zo(e3, t3) {
  if (e3 === true && t3 === true || e3 == null && t3 == null)
    return "all";
  if (e3 === false && t3 === false)
    return "none";
  var n2 = e3 ?? !t3;
  return n2 ? "active" : "inactive";
}
function Gn(e3, t3) {
  var n2 = e3.active, r = e3.exact, o2 = e3.fetching, s = e3.inactive, l = e3.predicate, u = e3.queryKey, f = e3.stale;
  if (Yt(u)) {
    if (r) {
      if (t3.queryHash !== Cn(u, t3.options))
        return false;
    } else if (!Ut(t3.queryKey, u))
      return false;
  }
  var h = Zo(n2, s);
  if (h === "none")
    return false;
  if (h !== "all") {
    var p = t3.isActive();
    if (h === "active" && !p || h === "inactive" && p)
      return false;
  }
  return !(typeof f == "boolean" && t3.isStale() !== f || typeof o2 == "boolean" && t3.isFetching() !== o2 || l && !l(t3));
}
function _n(e3, t3) {
  var n2 = e3.exact, r = e3.fetching, o2 = e3.predicate, s = e3.mutationKey;
  if (Yt(s)) {
    if (!t3.options.mutationKey)
      return false;
    if (n2) {
      if (Ye(t3.options.mutationKey) !== Ye(s))
        return false;
    } else if (!Ut(t3.options.mutationKey, s))
      return false;
  }
  return !(typeof r == "boolean" && t3.state.status === "loading" !== r || o2 && !o2(t3));
}
function Cn(e3, t3) {
  var n2 = (t3 == null ? void 0 : t3.queryKeyHashFn) || Ye;
  return n2(e3);
}
function Ye(e3) {
  var t3 = Rt(e3);
  return Vo(t3);
}
function Vo(e3) {
  return JSON.stringify(e3, function(t3, n2) {
    return dn(n2) ? Object.keys(n2).sort().reduce(function(r, o2) {
      return r[o2] = n2[o2], r;
    }, {}) : n2;
  });
}
function Ut(e3, t3) {
  return Dr(Rt(e3), Rt(t3));
}
function Dr(e3, t3) {
  return e3 === t3 ? true : typeof e3 != typeof t3 ? false : e3 && t3 && typeof e3 == "object" && typeof t3 == "object" ? !Object.keys(t3).some(function(n2) {
    return !Dr(e3[n2], t3[n2]);
  }) : false;
}
function Pt(e3, t3) {
  if (e3 === t3)
    return e3;
  var n2 = Array.isArray(e3) && Array.isArray(t3);
  if (n2 || dn(e3) && dn(t3)) {
    for (var r = n2 ? e3.length : Object.keys(e3).length, o2 = n2 ? t3 : Object.keys(t3), s = o2.length, l = n2 ? [] : {}, u = 0, f = 0; f < s; f++) {
      var h = n2 ? f : o2[f];
      l[h] = Pt(e3[h], t3[h]), l[h] === e3[h] && u++;
    }
    return r === s && u === r ? e3 : l;
  }
  return t3;
}
function qo(e3, t3) {
  if (e3 && !t3 || t3 && !e3)
    return false;
  for (var n2 in e3)
    if (e3[n2] !== t3[n2])
      return false;
  return true;
}
function dn(e3) {
  if (!Zn(e3))
    return false;
  var t3 = e3.constructor;
  if (typeof t3 > "u")
    return true;
  var n2 = t3.prototype;
  return !(!Zn(n2) || !n2.hasOwnProperty("isPrototypeOf"));
}
function Zn(e3) {
  return Object.prototype.toString.call(e3) === "[object Object]";
}
function Yt(e3) {
  return typeof e3 == "string" || Array.isArray(e3);
}
function Xo(e3) {
  return new Promise(function(t3) {
    setTimeout(t3, e3);
  });
}
function Vn(e3) {
  Promise.resolve().then(e3).catch(function(t3) {
    return setTimeout(function() {
      throw t3;
    });
  });
}
function Cr() {
  if (typeof AbortController == "function")
    return new AbortController();
}
var Ko = function(e3) {
  ht(t3, e3);
  function t3() {
    var r;
    return r = e3.call(this) || this, r.setup = function(o2) {
      var s;
      if (!xt && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o2();
        };
        return window.addEventListener("visibilitychange", l, false), window.addEventListener("focus", l, false), function() {
          window.removeEventListener("visibilitychange", l), window.removeEventListener("focus", l);
        };
      }
    }, r;
  }
  var n2 = t3.prototype;
  return n2.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n2.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o2;
      (o2 = this.cleanup) == null || o2.call(this), this.cleanup = void 0;
    }
  }, n2.setEventListener = function(o2) {
    var s, l = this;
    this.setup = o2, (s = this.cleanup) == null || s.call(this), this.cleanup = o2(function(u) {
      typeof u == "boolean" ? l.setFocused(u) : l.onFocus();
    });
  }, n2.setFocused = function(o2) {
    this.focused = o2, o2 && this.onFocus();
  }, n2.onFocus = function() {
    this.listeners.forEach(function(o2) {
      o2();
    });
  }, n2.isFocused = function() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? true : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }, t3;
}(gt);
var st = new Ko();
var Ho = function(e3) {
  ht(t3, e3);
  function t3() {
    var r;
    return r = e3.call(this) || this, r.setup = function(o2) {
      var s;
      if (!xt && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o2();
        };
        return window.addEventListener("online", l, false), window.addEventListener("offline", l, false), function() {
          window.removeEventListener("online", l), window.removeEventListener("offline", l);
        };
      }
    }, r;
  }
  var n2 = t3.prototype;
  return n2.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n2.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o2;
      (o2 = this.cleanup) == null || o2.call(this), this.cleanup = void 0;
    }
  }, n2.setEventListener = function(o2) {
    var s, l = this;
    this.setup = o2, (s = this.cleanup) == null || s.call(this), this.cleanup = o2(function(u) {
      typeof u == "boolean" ? l.setOnline(u) : l.onOnline();
    });
  }, n2.setOnline = function(o2) {
    this.online = o2, o2 && this.onOnline();
  }, n2.onOnline = function() {
    this.listeners.forEach(function(o2) {
      o2();
    });
  }, n2.isOnline = function() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? true : navigator.onLine;
  }, t3;
}(gt);
var Et = new Ho();
function Jo(e3) {
  return Math.min(1e3 * Math.pow(2, e3), 3e4);
}
function zt(e3) {
  return typeof (e3 == null ? void 0 : e3.cancel) == "function";
}
var Tr = function(t3) {
  this.revert = t3 == null ? void 0 : t3.revert, this.silent = t3 == null ? void 0 : t3.silent;
};
function Dt(e3) {
  return e3 instanceof Tr;
}
var jr = function(t3) {
  var n2 = this, r = false, o2, s, l, u;
  this.abort = t3.abort, this.cancel = function(A) {
    return o2 == null ? void 0 : o2(A);
  }, this.cancelRetry = function() {
    r = true;
  }, this.continueRetry = function() {
    r = false;
  }, this.continue = function() {
    return s == null ? void 0 : s();
  }, this.failureCount = 0, this.isPaused = false, this.isResolved = false, this.isTransportCancelable = false, this.promise = new Promise(function(A, v) {
    l = A, u = v;
  });
  var f = function(v) {
    n2.isResolved || (n2.isResolved = true, t3.onSuccess == null || t3.onSuccess(v), s == null ? void 0 : s(), l(v));
  }, h = function(v) {
    n2.isResolved || (n2.isResolved = true, t3.onError == null || t3.onError(v), s == null ? void 0 : s(), u(v));
  }, p = function() {
    return new Promise(function(v) {
      s = v, n2.isPaused = true, t3.onPause == null || t3.onPause();
    }).then(function() {
      s = void 0, n2.isPaused = false, t3.onContinue == null || t3.onContinue();
    });
  }, y = function A() {
    if (!n2.isResolved) {
      var v;
      try {
        v = t3.fn();
      } catch (I) {
        v = Promise.reject(I);
      }
      o2 = function(m) {
        if (!n2.isResolved && (h(new Tr(m)), n2.abort == null || n2.abort(), zt(v)))
          try {
            v.cancel();
          } catch {
          }
      }, n2.isTransportCancelable = zt(v), Promise.resolve(v).then(f).catch(function(I) {
        var m, w;
        if (!n2.isResolved) {
          var E = (m = t3.retry) != null ? m : 3, T = (w = t3.retryDelay) != null ? w : Jo, D = typeof T == "function" ? T(n2.failureCount, I) : T, P = E === true || typeof E == "number" && n2.failureCount < E || typeof E == "function" && E(n2.failureCount, I);
          if (r || !P) {
            h(I);
            return;
          }
          n2.failureCount++, t3.onFail == null || t3.onFail(n2.failureCount, I), Xo(D).then(function() {
            if (!st.isFocused() || !Et.isOnline())
              return p();
          }).then(function() {
            r ? h(I) : A();
          });
        }
      });
    }
  };
  y();
};
var $o = function() {
  function e3() {
    this.queue = [], this.transactions = 0, this.notifyFn = function(n2) {
      n2();
    }, this.batchNotifyFn = function(n2) {
      n2();
    };
  }
  var t3 = e3.prototype;
  return t3.batch = function(r) {
    var o2;
    this.transactions++;
    try {
      o2 = r();
    } finally {
      this.transactions--, this.transactions || this.flush();
    }
    return o2;
  }, t3.schedule = function(r) {
    var o2 = this;
    this.transactions ? this.queue.push(r) : Vn(function() {
      o2.notifyFn(r);
    });
  }, t3.batchCalls = function(r) {
    var o2 = this;
    return function() {
      for (var s = arguments.length, l = new Array(s), u = 0; u < s; u++)
        l[u] = arguments[u];
      o2.schedule(function() {
        r.apply(void 0, l);
      });
    };
  }, t3.flush = function() {
    var r = this, o2 = this.queue;
    this.queue = [], o2.length && Vn(function() {
      r.batchNotifyFn(function() {
        o2.forEach(function(s) {
          r.notifyFn(s);
        });
      });
    });
  }, t3.setNotifyFunction = function(r) {
    this.notifyFn = r;
  }, t3.setBatchNotifyFunction = function(r) {
    this.batchNotifyFn = r;
  }, e3;
}();
var _ = new $o();
var Sr = console;
function kt() {
  return Sr;
}
function es(e3) {
  Sr = e3;
}
var ts = function() {
  function e3(n2) {
    this.abortSignalConsumed = false, this.hadObservers = false, this.defaultOptions = n2.defaultOptions, this.setOptions(n2.options), this.observers = [], this.cache = n2.cache, this.queryKey = n2.queryKey, this.queryHash = n2.queryHash, this.initialState = n2.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = n2.meta, this.scheduleGc();
  }
  var t3 = e3.prototype;
  return t3.setOptions = function(r) {
    var o2;
    this.options = U({}, this.defaultOptions, r), this.meta = r == null ? void 0 : r.meta, this.cacheTime = Math.max(this.cacheTime || 0, (o2 = this.options.cacheTime) != null ? o2 : 5 * 60 * 1e3);
  }, t3.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t3.scheduleGc = function() {
    var r = this;
    this.clearGcTimeout(), fn(this.cacheTime) && (this.gcTimeout = setTimeout(function() {
      r.optionalRemove();
    }, this.cacheTime));
  }, t3.clearGcTimeout = function() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }, t3.optionalRemove = function() {
    this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this));
  }, t3.setData = function(r, o2) {
    var s, l, u = this.state.data, f = _o(r, u);
    return (s = (l = this.options).isDataEqual) != null && s.call(l, u, f) ? f = u : this.options.structuralSharing !== false && (f = Pt(u, f)), this.dispatch({
      data: f,
      type: "success",
      dataUpdatedAt: o2 == null ? void 0 : o2.updatedAt
    }), f;
  }, t3.setState = function(r, o2) {
    this.dispatch({
      type: "setState",
      state: r,
      setStateOptions: o2
    });
  }, t3.cancel = function(r) {
    var o2, s = this.promise;
    return (o2 = this.retryer) == null || o2.cancel(r), s ? s.then(ae).catch(ae) : Promise.resolve();
  }, t3.destroy = function() {
    this.clearGcTimeout(), this.cancel({
      silent: true
    });
  }, t3.reset = function() {
    this.destroy(), this.setState(this.initialState);
  }, t3.isActive = function() {
    return this.observers.some(function(r) {
      return r.options.enabled !== false;
    });
  }, t3.isFetching = function() {
    return this.state.isFetching;
  }, t3.isStale = function() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(r) {
      return r.getCurrentResult().isStale;
    });
  }, t3.isStaleByTime = function(r) {
    return r === void 0 && (r = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !Er(this.state.dataUpdatedAt, r);
  }, t3.onFocus = function() {
    var r, o2 = this.observers.find(function(s) {
      return s.shouldFetchOnWindowFocus();
    });
    o2 && o2.refetch(), (r = this.retryer) == null || r.continue();
  }, t3.onOnline = function() {
    var r, o2 = this.observers.find(function(s) {
      return s.shouldFetchOnReconnect();
    });
    o2 && o2.refetch(), (r = this.retryer) == null || r.continue();
  }, t3.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && (this.observers.push(r), this.hadObservers = true, this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: r
    }));
  }, t3.removeObserver = function(r) {
    this.observers.indexOf(r) !== -1 && (this.observers = this.observers.filter(function(o2) {
      return o2 !== r;
    }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
      revert: true
    }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: r
    }));
  }, t3.getObserversCount = function() {
    return this.observers.length;
  }, t3.invalidate = function() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }, t3.fetch = function(r, o2) {
    var s = this, l, u, f;
    if (this.state.isFetching) {
      if (this.state.dataUpdatedAt && (o2 == null ? void 0 : o2.cancelRefetch))
        this.cancel({
          silent: true
        });
      else if (this.promise) {
        var h;
        return (h = this.retryer) == null || h.continueRetry(), this.promise;
      }
    }
    if (r && this.setOptions(r), !this.options.queryFn) {
      var p = this.observers.find(function(T) {
        return T.options.queryFn;
      });
      p && this.setOptions(p.options);
    }
    var y = Rt(this.queryKey), A = Cr(), v = {
      queryKey: y,
      pageParam: void 0,
      meta: this.meta
    };
    Object.defineProperty(v, "signal", {
      enumerable: true,
      get: function() {
        if (A)
          return s.abortSignalConsumed = true, A.signal;
      }
    });
    var I = function() {
      return s.options.queryFn ? (s.abortSignalConsumed = false, s.options.queryFn(v)) : Promise.reject("Missing queryFn");
    }, m = {
      fetchOptions: o2,
      options: this.options,
      queryKey: y,
      state: this.state,
      fetchFn: I,
      meta: this.meta
    };
    if ((l = this.options.behavior) != null && l.onFetch) {
      var w;
      (w = this.options.behavior) == null || w.onFetch(m);
    }
    if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((u = m.fetchOptions) == null ? void 0 : u.meta)) {
      var E;
      this.dispatch({
        type: "fetch",
        meta: (E = m.fetchOptions) == null ? void 0 : E.meta
      });
    }
    return this.retryer = new jr({
      fn: m.fetchFn,
      abort: A == null || (f = A.abort) == null ? void 0 : f.bind(A),
      onSuccess: function(D) {
        s.setData(D), s.cache.config.onSuccess == null || s.cache.config.onSuccess(D, s), s.cacheTime === 0 && s.optionalRemove();
      },
      onError: function(D) {
        Dt(D) && D.silent || s.dispatch({
          type: "error",
          error: D
        }), Dt(D) || (s.cache.config.onError == null || s.cache.config.onError(D, s), kt().error(D)), s.cacheTime === 0 && s.optionalRemove();
      },
      onFail: function() {
        s.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        s.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        s.dispatch({
          type: "continue"
        });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay
    }), this.promise = this.retryer.promise, this.promise;
  }, t3.dispatch = function(r) {
    var o2 = this;
    this.state = this.reducer(this.state, r), _.batch(function() {
      o2.observers.forEach(function(s) {
        s.onQueryUpdate(r);
      }), o2.cache.notify({
        query: o2,
        type: "queryUpdated",
        action: r
      });
    });
  }, t3.getDefaultState = function(r) {
    var o2 = typeof r.initialData == "function" ? r.initialData() : r.initialData, s = typeof r.initialData < "u", l = s ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0, u = typeof o2 < "u";
    return {
      data: o2,
      dataUpdateCount: 0,
      dataUpdatedAt: u ? l ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchMeta: null,
      isFetching: false,
      isInvalidated: false,
      isPaused: false,
      status: u ? "success" : "idle"
    };
  }, t3.reducer = function(r, o2) {
    var s, l;
    switch (o2.type) {
      case "failed":
        return U({}, r, {
          fetchFailureCount: r.fetchFailureCount + 1
        });
      case "pause":
        return U({}, r, {
          isPaused: true
        });
      case "continue":
        return U({}, r, {
          isPaused: false
        });
      case "fetch":
        return U({}, r, {
          fetchFailureCount: 0,
          fetchMeta: (s = o2.meta) != null ? s : null,
          isFetching: true,
          isPaused: false
        }, !r.dataUpdatedAt && {
          error: null,
          status: "loading"
        });
      case "success":
        return U({}, r, {
          data: o2.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: (l = o2.dataUpdatedAt) != null ? l : Date.now(),
          error: null,
          fetchFailureCount: 0,
          isFetching: false,
          isInvalidated: false,
          isPaused: false,
          status: "success"
        });
      case "error":
        var u = o2.error;
        return Dt(u) && u.revert && this.revertState ? U({}, this.revertState) : U({}, r, {
          error: u,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          isFetching: false,
          isPaused: false,
          status: "error"
        });
      case "invalidate":
        return U({}, r, {
          isInvalidated: true
        });
      case "setState":
        return U({}, r, o2.state);
      default:
        return r;
    }
  }, e3;
}();
var ns = function(e3) {
  ht(t3, e3);
  function t3(r) {
    var o2;
    return o2 = e3.call(this) || this, o2.config = r || {}, o2.queries = [], o2.queriesMap = {}, o2;
  }
  var n2 = t3.prototype;
  return n2.build = function(o2, s, l) {
    var u, f = s.queryKey, h = (u = s.queryHash) != null ? u : Cn(f, s), p = this.get(h);
    return p || (p = new ts({
      cache: this,
      queryKey: f,
      queryHash: h,
      options: o2.defaultQueryOptions(s),
      state: l,
      defaultOptions: o2.getQueryDefaults(f),
      meta: s.meta
    }), this.add(p)), p;
  }, n2.add = function(o2) {
    this.queriesMap[o2.queryHash] || (this.queriesMap[o2.queryHash] = o2, this.queries.push(o2), this.notify({
      type: "queryAdded",
      query: o2
    }));
  }, n2.remove = function(o2) {
    var s = this.queriesMap[o2.queryHash];
    s && (o2.destroy(), this.queries = this.queries.filter(function(l) {
      return l !== o2;
    }), s === o2 && delete this.queriesMap[o2.queryHash], this.notify({
      type: "queryRemoved",
      query: o2
    }));
  }, n2.clear = function() {
    var o2 = this;
    _.batch(function() {
      o2.queries.forEach(function(s) {
        o2.remove(s);
      });
    });
  }, n2.get = function(o2) {
    return this.queriesMap[o2];
  }, n2.getAll = function() {
    return this.queries;
  }, n2.find = function(o2, s) {
    var l = ze(o2, s), u = l[0];
    return typeof u.exact > "u" && (u.exact = true), this.queries.find(function(f) {
      return Gn(u, f);
    });
  }, n2.findAll = function(o2, s) {
    var l = ze(o2, s), u = l[0];
    return Object.keys(u).length > 0 ? this.queries.filter(function(f) {
      return Gn(u, f);
    }) : this.queries;
  }, n2.notify = function(o2) {
    var s = this;
    _.batch(function() {
      s.listeners.forEach(function(l) {
        l(o2);
      });
    });
  }, n2.onFocus = function() {
    var o2 = this;
    _.batch(function() {
      o2.queries.forEach(function(s) {
        s.onFocus();
      });
    });
  }, n2.onOnline = function() {
    var o2 = this;
    _.batch(function() {
      o2.queries.forEach(function(s) {
        s.onOnline();
      });
    });
  }, t3;
}(gt);
var rs = function() {
  function e3(n2) {
    this.options = U({}, n2.defaultOptions, n2.options), this.mutationId = n2.mutationId, this.mutationCache = n2.mutationCache, this.observers = [], this.state = n2.state || is2(), this.meta = n2.meta;
  }
  var t3 = e3.prototype;
  return t3.setState = function(r) {
    this.dispatch({
      type: "setState",
      state: r
    });
  }, t3.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && this.observers.push(r);
  }, t3.removeObserver = function(r) {
    this.observers = this.observers.filter(function(o2) {
      return o2 !== r;
    });
  }, t3.cancel = function() {
    return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(ae).catch(ae)) : Promise.resolve();
  }, t3.continue = function() {
    return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();
  }, t3.execute = function() {
    var r = this, o2, s = this.state.status === "loading", l = Promise.resolve();
    return s || (this.dispatch({
      type: "loading",
      variables: this.options.variables
    }), l = l.then(function() {
      r.mutationCache.config.onMutate == null || r.mutationCache.config.onMutate(r.state.variables, r);
    }).then(function() {
      return r.options.onMutate == null ? void 0 : r.options.onMutate(r.state.variables);
    }).then(function(u) {
      u !== r.state.context && r.dispatch({
        type: "loading",
        context: u,
        variables: r.state.variables
      });
    })), l.then(function() {
      return r.executeMutation();
    }).then(function(u) {
      o2 = u, r.mutationCache.config.onSuccess == null || r.mutationCache.config.onSuccess(o2, r.state.variables, r.state.context, r);
    }).then(function() {
      return r.options.onSuccess == null ? void 0 : r.options.onSuccess(o2, r.state.variables, r.state.context);
    }).then(function() {
      return r.options.onSettled == null ? void 0 : r.options.onSettled(o2, null, r.state.variables, r.state.context);
    }).then(function() {
      return r.dispatch({
        type: "success",
        data: o2
      }), o2;
    }).catch(function(u) {
      return r.mutationCache.config.onError == null || r.mutationCache.config.onError(u, r.state.variables, r.state.context, r), kt().error(u), Promise.resolve().then(function() {
        return r.options.onError == null ? void 0 : r.options.onError(u, r.state.variables, r.state.context);
      }).then(function() {
        return r.options.onSettled == null ? void 0 : r.options.onSettled(void 0, u, r.state.variables, r.state.context);
      }).then(function() {
        throw r.dispatch({
          type: "error",
          error: u
        }), u;
      });
    });
  }, t3.executeMutation = function() {
    var r = this, o2;
    return this.retryer = new jr({
      fn: function() {
        return r.options.mutationFn ? r.options.mutationFn(r.state.variables) : Promise.reject("No mutationFn found");
      },
      onFail: function() {
        r.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        r.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        r.dispatch({
          type: "continue"
        });
      },
      retry: (o2 = this.options.retry) != null ? o2 : 0,
      retryDelay: this.options.retryDelay
    }), this.retryer.promise;
  }, t3.dispatch = function(r) {
    var o2 = this;
    this.state = os(this.state, r), _.batch(function() {
      o2.observers.forEach(function(s) {
        s.onMutationUpdate(r);
      }), o2.mutationCache.notify(o2);
    });
  }, e3;
}();
function is2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
function os(e3, t3) {
  switch (t3.type) {
    case "failed":
      return U({}, e3, {
        failureCount: e3.failureCount + 1
      });
    case "pause":
      return U({}, e3, {
        isPaused: true
      });
    case "continue":
      return U({}, e3, {
        isPaused: false
      });
    case "loading":
      return U({}, e3, {
        context: t3.context,
        data: void 0,
        error: null,
        isPaused: false,
        status: "loading",
        variables: t3.variables
      });
    case "success":
      return U({}, e3, {
        data: t3.data,
        error: null,
        status: "success",
        isPaused: false
      });
    case "error":
      return U({}, e3, {
        data: void 0,
        error: t3.error,
        failureCount: e3.failureCount + 1,
        isPaused: false,
        status: "error"
      });
    case "setState":
      return U({}, e3, t3.state);
    default:
      return e3;
  }
}
var ss = function(e3) {
  ht(t3, e3);
  function t3(r) {
    var o2;
    return o2 = e3.call(this) || this, o2.config = r || {}, o2.mutations = [], o2.mutationId = 0, o2;
  }
  var n2 = t3.prototype;
  return n2.build = function(o2, s, l) {
    var u = new rs({
      mutationCache: this,
      mutationId: ++this.mutationId,
      options: o2.defaultMutationOptions(s),
      state: l,
      defaultOptions: s.mutationKey ? o2.getMutationDefaults(s.mutationKey) : void 0,
      meta: s.meta
    });
    return this.add(u), u;
  }, n2.add = function(o2) {
    this.mutations.push(o2), this.notify(o2);
  }, n2.remove = function(o2) {
    this.mutations = this.mutations.filter(function(s) {
      return s !== o2;
    }), o2.cancel(), this.notify(o2);
  }, n2.clear = function() {
    var o2 = this;
    _.batch(function() {
      o2.mutations.forEach(function(s) {
        o2.remove(s);
      });
    });
  }, n2.getAll = function() {
    return this.mutations;
  }, n2.find = function(o2) {
    return typeof o2.exact > "u" && (o2.exact = true), this.mutations.find(function(s) {
      return _n(o2, s);
    });
  }, n2.findAll = function(o2) {
    return this.mutations.filter(function(s) {
      return _n(o2, s);
    });
  }, n2.notify = function(o2) {
    var s = this;
    _.batch(function() {
      s.listeners.forEach(function(l) {
        l(o2);
      });
    });
  }, n2.onFocus = function() {
    this.resumePausedMutations();
  }, n2.onOnline = function() {
    this.resumePausedMutations();
  }, n2.resumePausedMutations = function() {
    var o2 = this.mutations.filter(function(s) {
      return s.state.isPaused;
    });
    return _.batch(function() {
      return o2.reduce(function(s, l) {
        return s.then(function() {
          return l.continue().catch(ae);
        });
      }, Promise.resolve());
    });
  }, t3;
}(gt);
function as() {
  return {
    onFetch: function(t3) {
      t3.fetchFn = function() {
        var n2, r, o2, s, l, u, f = (n2 = t3.fetchOptions) == null || (r = n2.meta) == null ? void 0 : r.refetchPage, h = (o2 = t3.fetchOptions) == null || (s = o2.meta) == null ? void 0 : s.fetchMore, p = h == null ? void 0 : h.pageParam, y = (h == null ? void 0 : h.direction) === "forward", A = (h == null ? void 0 : h.direction) === "backward", v = ((l = t3.state.data) == null ? void 0 : l.pages) || [], I = ((u = t3.state.data) == null ? void 0 : u.pageParams) || [], m = Cr(), w = m == null ? void 0 : m.signal, E = I, T = false, D = t3.options.queryFn || function() {
          return Promise.reject("Missing queryFn");
        }, P = function(Z, H, ee, Te) {
          return E = Te ? [H].concat(E) : [].concat(E, [H]), Te ? [ee].concat(Z) : [].concat(Z, [ee]);
        }, S = function(Z, H, ee, Te) {
          if (T)
            return Promise.reject("Cancelled");
          if (typeof ee > "u" && !H && Z.length)
            return Promise.resolve(Z);
          var Ie = {
            queryKey: t3.queryKey,
            signal: w,
            pageParam: ee,
            meta: t3.meta
          }, je = D(Ie), qe = Promise.resolve(je).then(function(se) {
            return P(Z, ee, se, Te);
          });
          if (zt(je)) {
            var G = qe;
            G.cancel = je.cancel;
          }
          return qe;
        }, O;
        if (!v.length)
          O = S([]);
        else if (y) {
          var K = typeof p < "u", x = K ? p : qn(t3.options, v);
          O = S(v, K, x);
        } else if (A) {
          var oe = typeof p < "u", $ = oe ? p : us(t3.options, v);
          O = S(v, oe, $, true);
        } else
          (function() {
            E = [];
            var k = typeof t3.options.getNextPageParam > "u", Z = f && v[0] ? f(v[0], 0, v) : true;
            O = Z ? S([], k, I[0]) : Promise.resolve(P([], I[0], v[0]));
            for (var H = function(Ie) {
              O = O.then(function(je) {
                var qe = f && v[Ie] ? f(v[Ie], Ie, v) : true;
                if (qe) {
                  var G = k ? I[Ie] : qn(t3.options, je);
                  return S(je, k, G);
                }
                return Promise.resolve(P(je, I[Ie], v[Ie]));
              });
            }, ee = 1; ee < v.length; ee++)
              H(ee);
          })();
        var j = O.then(function(k) {
          return {
            pages: k,
            pageParams: E
          };
        }), R = j;
        return R.cancel = function() {
          T = true, m == null ? void 0 : m.abort(), zt(O) && O.cancel();
        }, j;
      };
    }
  };
}
function qn(e3, t3) {
  return e3.getNextPageParam == null ? void 0 : e3.getNextPageParam(t3[t3.length - 1], t3);
}
function us(e3, t3) {
  return e3.getPreviousPageParam == null ? void 0 : e3.getPreviousPageParam(t3[0], t3);
}
var cs = function() {
  function e3(n2) {
    n2 === void 0 && (n2 = {}), this.queryCache = n2.queryCache || new ns(), this.mutationCache = n2.mutationCache || new ss(), this.defaultOptions = n2.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];
  }
  var t3 = e3.prototype;
  return t3.mount = function() {
    var r = this;
    this.unsubscribeFocus = st.subscribe(function() {
      st.isFocused() && Et.isOnline() && (r.mutationCache.onFocus(), r.queryCache.onFocus());
    }), this.unsubscribeOnline = Et.subscribe(function() {
      st.isFocused() && Et.isOnline() && (r.mutationCache.onOnline(), r.queryCache.onOnline());
    });
  }, t3.unmount = function() {
    var r, o2;
    (r = this.unsubscribeFocus) == null || r.call(this), (o2 = this.unsubscribeOnline) == null || o2.call(this);
  }, t3.isFetching = function(r, o2) {
    var s = ze(r, o2), l = s[0];
    return l.fetching = true, this.queryCache.findAll(l).length;
  }, t3.isMutating = function(r) {
    return this.mutationCache.findAll(U({}, r, {
      fetching: true
    })).length;
  }, t3.getQueryData = function(r, o2) {
    var s;
    return (s = this.queryCache.find(r, o2)) == null ? void 0 : s.state.data;
  }, t3.getQueriesData = function(r) {
    return this.getQueryCache().findAll(r).map(function(o2) {
      var s = o2.queryKey, l = o2.state, u = l.data;
      return [s, u];
    });
  }, t3.setQueryData = function(r, o2, s) {
    var l = wt(r), u = this.defaultQueryOptions(l);
    return this.queryCache.build(this, u).setData(o2, s);
  }, t3.setQueriesData = function(r, o2, s) {
    var l = this;
    return _.batch(function() {
      return l.getQueryCache().findAll(r).map(function(u) {
        var f = u.queryKey;
        return [f, l.setQueryData(f, o2, s)];
      });
    });
  }, t3.getQueryState = function(r, o2) {
    var s;
    return (s = this.queryCache.find(r, o2)) == null ? void 0 : s.state;
  }, t3.removeQueries = function(r, o2) {
    var s = ze(r, o2), l = s[0], u = this.queryCache;
    _.batch(function() {
      u.findAll(l).forEach(function(f) {
        u.remove(f);
      });
    });
  }, t3.resetQueries = function(r, o2, s) {
    var l = this, u = ze(r, o2, s), f = u[0], h = u[1], p = this.queryCache, y = U({}, f, {
      active: true
    });
    return _.batch(function() {
      return p.findAll(f).forEach(function(A) {
        A.reset();
      }), l.refetchQueries(y, h);
    });
  }, t3.cancelQueries = function(r, o2, s) {
    var l = this, u = ze(r, o2, s), f = u[0], h = u[1], p = h === void 0 ? {} : h;
    typeof p.revert > "u" && (p.revert = true);
    var y = _.batch(function() {
      return l.queryCache.findAll(f).map(function(A) {
        return A.cancel(p);
      });
    });
    return Promise.all(y).then(ae).catch(ae);
  }, t3.invalidateQueries = function(r, o2, s) {
    var l, u, f, h = this, p = ze(r, o2, s), y = p[0], A = p[1], v = U({}, y, {
      // if filters.refetchActive is not provided and filters.active is explicitly false,
      // e.g. invalidateQueries({ active: false }), we don't want to refetch active queries
      active: (l = (u = y.refetchActive) != null ? u : y.active) != null ? l : true,
      inactive: (f = y.refetchInactive) != null ? f : false
    });
    return _.batch(function() {
      return h.queryCache.findAll(y).forEach(function(I) {
        I.invalidate();
      }), h.refetchQueries(v, A);
    });
  }, t3.refetchQueries = function(r, o2, s) {
    var l = this, u = ze(r, o2, s), f = u[0], h = u[1], p = _.batch(function() {
      return l.queryCache.findAll(f).map(function(A) {
        return A.fetch(void 0, U({}, h, {
          meta: {
            refetchPage: f == null ? void 0 : f.refetchPage
          }
        }));
      });
    }), y = Promise.all(p).then(ae);
    return (h == null ? void 0 : h.throwOnError) || (y = y.catch(ae)), y;
  }, t3.fetchQuery = function(r, o2, s) {
    var l = wt(r, o2, s), u = this.defaultQueryOptions(l);
    typeof u.retry > "u" && (u.retry = false);
    var f = this.queryCache.build(this, u);
    return f.isStaleByTime(u.staleTime) ? f.fetch(u) : Promise.resolve(f.state.data);
  }, t3.prefetchQuery = function(r, o2, s) {
    return this.fetchQuery(r, o2, s).then(ae).catch(ae);
  }, t3.fetchInfiniteQuery = function(r, o2, s) {
    var l = wt(r, o2, s);
    return l.behavior = as(), this.fetchQuery(l);
  }, t3.prefetchInfiniteQuery = function(r, o2, s) {
    return this.fetchInfiniteQuery(r, o2, s).then(ae).catch(ae);
  }, t3.cancelMutations = function() {
    var r = this, o2 = _.batch(function() {
      return r.mutationCache.getAll().map(function(s) {
        return s.cancel();
      });
    });
    return Promise.all(o2).then(ae).catch(ae);
  }, t3.resumePausedMutations = function() {
    return this.getMutationCache().resumePausedMutations();
  }, t3.executeMutation = function(r) {
    return this.mutationCache.build(this, r).execute();
  }, t3.getQueryCache = function() {
    return this.queryCache;
  }, t3.getMutationCache = function() {
    return this.mutationCache;
  }, t3.getDefaultOptions = function() {
    return this.defaultOptions;
  }, t3.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t3.setQueryDefaults = function(r, o2) {
    var s = this.queryDefaults.find(function(l) {
      return Ye(r) === Ye(l.queryKey);
    });
    s ? s.defaultOptions = o2 : this.queryDefaults.push({
      queryKey: r,
      defaultOptions: o2
    });
  }, t3.getQueryDefaults = function(r) {
    var o2;
    return r ? (o2 = this.queryDefaults.find(function(s) {
      return Ut(r, s.queryKey);
    })) == null ? void 0 : o2.defaultOptions : void 0;
  }, t3.setMutationDefaults = function(r, o2) {
    var s = this.mutationDefaults.find(function(l) {
      return Ye(r) === Ye(l.mutationKey);
    });
    s ? s.defaultOptions = o2 : this.mutationDefaults.push({
      mutationKey: r,
      defaultOptions: o2
    });
  }, t3.getMutationDefaults = function(r) {
    var o2;
    return r ? (o2 = this.mutationDefaults.find(function(s) {
      return Ut(r, s.mutationKey);
    })) == null ? void 0 : o2.defaultOptions : void 0;
  }, t3.defaultQueryOptions = function(r) {
    if (r == null ? void 0 : r._defaulted)
      return r;
    var o2 = U({}, this.defaultOptions.queries, this.getQueryDefaults(r == null ? void 0 : r.queryKey), r, {
      _defaulted: true
    });
    return !o2.queryHash && o2.queryKey && (o2.queryHash = Cn(o2.queryKey, o2)), o2;
  }, t3.defaultQueryObserverOptions = function(r) {
    return this.defaultQueryOptions(r);
  }, t3.defaultMutationOptions = function(r) {
    return (r == null ? void 0 : r._defaulted) ? r : U({}, this.defaultOptions.mutations, this.getMutationDefaults(r == null ? void 0 : r.mutationKey), r, {
      _defaulted: true
    });
  }, t3.clear = function() {
    this.queryCache.clear(), this.mutationCache.clear();
  }, e3;
}();
var ls = function(e3) {
  ht(t3, e3);
  function t3(r, o2) {
    var s;
    return s = e3.call(this) || this, s.client = r, s.options = o2, s.trackedProps = [], s.selectError = null, s.bindMethods(), s.setOptions(o2), s;
  }
  var n2 = t3.prototype;
  return n2.bindMethods = function() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }, n2.onSubscribe = function() {
    this.listeners.length === 1 && (this.currentQuery.addObserver(this), Xn(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }, n2.onUnsubscribe = function() {
    this.listeners.length || this.destroy();
  }, n2.shouldFetchOnReconnect = function() {
    return hn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }, n2.shouldFetchOnWindowFocus = function() {
    return hn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }, n2.destroy = function() {
    this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this);
  }, n2.setOptions = function(o2, s) {
    var l = this.options, u = this.currentQuery;
    if (this.options = this.client.defaultQueryObserverOptions(o2), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = l.queryKey), this.updateQuery();
    var f = this.hasListeners();
    f && Kn(this.currentQuery, u, this.options, l) && this.executeFetch(), this.updateResult(s), f && (this.currentQuery !== u || this.options.enabled !== l.enabled || this.options.staleTime !== l.staleTime) && this.updateStaleTimeout();
    var h = this.computeRefetchInterval();
    f && (this.currentQuery !== u || this.options.enabled !== l.enabled || h !== this.currentRefetchInterval) && this.updateRefetchInterval(h);
  }, n2.getOptimisticResult = function(o2) {
    var s = this.client.defaultQueryObserverOptions(o2), l = this.client.getQueryCache().build(this.client, s);
    return this.createResult(l, s);
  }, n2.getCurrentResult = function() {
    return this.currentResult;
  }, n2.trackResult = function(o2, s) {
    var l = this, u = {}, f = function(p) {
      l.trackedProps.includes(p) || l.trackedProps.push(p);
    };
    return Object.keys(o2).forEach(function(h) {
      Object.defineProperty(u, h, {
        configurable: false,
        enumerable: true,
        get: function() {
          return f(h), o2[h];
        }
      });
    }), (s.useErrorBoundary || s.suspense) && f("error"), u;
  }, n2.getNextResult = function(o2) {
    var s = this;
    return new Promise(function(l, u) {
      var f = s.subscribe(function(h) {
        h.isFetching || (f(), h.isError && (o2 == null ? void 0 : o2.throwOnError) ? u(h.error) : l(h));
      });
    });
  }, n2.getCurrentQuery = function() {
    return this.currentQuery;
  }, n2.remove = function() {
    this.client.getQueryCache().remove(this.currentQuery);
  }, n2.refetch = function(o2) {
    return this.fetch(U({}, o2, {
      meta: {
        refetchPage: o2 == null ? void 0 : o2.refetchPage
      }
    }));
  }, n2.fetchOptimistic = function(o2) {
    var s = this, l = this.client.defaultQueryObserverOptions(o2), u = this.client.getQueryCache().build(this.client, l);
    return u.fetch().then(function() {
      return s.createResult(u, l);
    });
  }, n2.fetch = function(o2) {
    var s = this;
    return this.executeFetch(o2).then(function() {
      return s.updateResult(), s.currentResult;
    });
  }, n2.executeFetch = function(o2) {
    this.updateQuery();
    var s = this.currentQuery.fetch(this.options, o2);
    return (o2 == null ? void 0 : o2.throwOnError) || (s = s.catch(ae)), s;
  }, n2.updateStaleTimeout = function() {
    var o2 = this;
    if (this.clearStaleTimeout(), !(xt || this.currentResult.isStale || !fn(this.options.staleTime))) {
      var s = Er(this.currentResult.dataUpdatedAt, this.options.staleTime), l = s + 1;
      this.staleTimeoutId = setTimeout(function() {
        o2.currentResult.isStale || o2.updateResult();
      }, l);
    }
  }, n2.computeRefetchInterval = function() {
    var o2;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (o2 = this.options.refetchInterval) != null ? o2 : false;
  }, n2.updateRefetchInterval = function(o2) {
    var s = this;
    this.clearRefetchInterval(), this.currentRefetchInterval = o2, !(xt || this.options.enabled === false || !fn(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(function() {
      (s.options.refetchIntervalInBackground || st.isFocused()) && s.executeFetch();
    }, this.currentRefetchInterval));
  }, n2.updateTimers = function() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }, n2.clearTimers = function() {
    this.clearStaleTimeout(), this.clearRefetchInterval();
  }, n2.clearStaleTimeout = function() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }, n2.clearRefetchInterval = function() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }, n2.createResult = function(o2, s) {
    var l = this.currentQuery, u = this.options, f = this.currentResult, h = this.currentResultState, p = this.currentResultOptions, y = o2 !== l, A = y ? o2.state : this.currentQueryInitialState, v = y ? this.currentResult : this.previousQueryResult, I = o2.state, m = I.dataUpdatedAt, w = I.error, E = I.errorUpdatedAt, T = I.isFetching, D = I.status, P = false, S = false, O;
    if (s.optimisticResults) {
      var K = this.hasListeners(), x = !K && Xn(o2, s), oe = K && Kn(o2, l, s, u);
      (x || oe) && (T = true, m || (D = "loading"));
    }
    if (s.keepPreviousData && !I.dataUpdateCount && (v == null ? void 0 : v.isSuccess) && D !== "error")
      O = v.data, m = v.dataUpdatedAt, D = v.status, P = true;
    else if (s.select && typeof I.data < "u")
      if (f && I.data === (h == null ? void 0 : h.data) && s.select === this.selectFn)
        O = this.selectResult;
      else
        try {
          this.selectFn = s.select, O = s.select(I.data), s.structuralSharing !== false && (O = Pt(f == null ? void 0 : f.data, O)), this.selectResult = O, this.selectError = null;
        } catch (R) {
          kt().error(R), this.selectError = R;
        }
    else
      O = I.data;
    if (typeof s.placeholderData < "u" && typeof O > "u" && (D === "loading" || D === "idle")) {
      var $;
      if ((f == null ? void 0 : f.isPlaceholderData) && s.placeholderData === (p == null ? void 0 : p.placeholderData))
        $ = f.data;
      else if ($ = typeof s.placeholderData == "function" ? s.placeholderData() : s.placeholderData, s.select && typeof $ < "u")
        try {
          $ = s.select($), s.structuralSharing !== false && ($ = Pt(f == null ? void 0 : f.data, $)), this.selectError = null;
        } catch (R) {
          kt().error(R), this.selectError = R;
        }
      typeof $ < "u" && (D = "success", O = $, S = true);
    }
    this.selectError && (w = this.selectError, O = this.selectResult, E = Date.now(), D = "error");
    var j = {
      status: D,
      isLoading: D === "loading",
      isSuccess: D === "success",
      isError: D === "error",
      isIdle: D === "idle",
      data: O,
      dataUpdatedAt: m,
      error: w,
      errorUpdatedAt: E,
      failureCount: I.fetchFailureCount,
      errorUpdateCount: I.errorUpdateCount,
      isFetched: I.dataUpdateCount > 0 || I.errorUpdateCount > 0,
      isFetchedAfterMount: I.dataUpdateCount > A.dataUpdateCount || I.errorUpdateCount > A.errorUpdateCount,
      isFetching: T,
      isRefetching: T && D !== "loading",
      isLoadingError: D === "error" && I.dataUpdatedAt === 0,
      isPlaceholderData: S,
      isPreviousData: P,
      isRefetchError: D === "error" && I.dataUpdatedAt !== 0,
      isStale: Tn(o2, s),
      refetch: this.refetch,
      remove: this.remove
    };
    return j;
  }, n2.shouldNotifyListeners = function(o2, s) {
    if (!s)
      return true;
    var l = this.options, u = l.notifyOnChangeProps, f = l.notifyOnChangePropsExclusions;
    if (!u && !f || u === "tracked" && !this.trackedProps.length)
      return true;
    var h = u === "tracked" ? this.trackedProps : u;
    return Object.keys(o2).some(function(p) {
      var y = p, A = o2[y] !== s[y], v = h == null ? void 0 : h.some(function(m) {
        return m === p;
      }), I = f == null ? void 0 : f.some(function(m) {
        return m === p;
      });
      return A && !I && (!h || v);
    });
  }, n2.updateResult = function(o2) {
    var s = this.currentResult;
    if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !qo(this.currentResult, s)) {
      var l = {
        cache: true
      };
      (o2 == null ? void 0 : o2.listeners) !== false && this.shouldNotifyListeners(this.currentResult, s) && (l.listeners = true), this.notify(U({}, l, o2));
    }
  }, n2.updateQuery = function() {
    var o2 = this.client.getQueryCache().build(this.client, this.options);
    if (o2 !== this.currentQuery) {
      var s = this.currentQuery;
      this.currentQuery = o2, this.currentQueryInitialState = o2.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (s == null ? void 0 : s.removeObserver(this), o2.addObserver(this));
    }
  }, n2.onQueryUpdate = function(o2) {
    var s = {};
    o2.type === "success" ? s.onSuccess = true : o2.type === "error" && !Dt(o2.error) && (s.onError = true), this.updateResult(s), this.hasListeners() && this.updateTimers();
  }, n2.notify = function(o2) {
    var s = this;
    _.batch(function() {
      o2.onSuccess ? (s.options.onSuccess == null || s.options.onSuccess(s.currentResult.data), s.options.onSettled == null || s.options.onSettled(s.currentResult.data, null)) : o2.onError && (s.options.onError == null || s.options.onError(s.currentResult.error), s.options.onSettled == null || s.options.onSettled(void 0, s.currentResult.error)), o2.listeners && s.listeners.forEach(function(l) {
        l(s.currentResult);
      }), o2.cache && s.client.getQueryCache().notify({
        query: s.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }, t3;
}(gt);
function fs(e3, t3) {
  return t3.enabled !== false && !e3.state.dataUpdatedAt && !(e3.state.status === "error" && t3.retryOnMount === false);
}
function Xn(e3, t3) {
  return fs(e3, t3) || e3.state.dataUpdatedAt > 0 && hn(e3, t3, t3.refetchOnMount);
}
function hn(e3, t3, n2) {
  if (t3.enabled !== false) {
    var r = typeof n2 == "function" ? n2(e3) : n2;
    return r === "always" || r !== false && Tn(e3, t3);
  }
  return false;
}
function Kn(e3, t3, n2, r) {
  return n2.enabled !== false && (e3 !== t3 || r.enabled === false) && (!n2.suspense || e3.state.status !== "error") && Tn(e3, n2);
}
function Tn(e3, t3) {
  return e3.isStaleByTime(t3.staleTime);
}
var ds = import_react_dom.default.unstable_batchedUpdates;
_.setBatchNotifyFunction(ds);
var hs = console;
es(hs);
var Hn = import_react.default.createContext(void 0);
var Lr = import_react.default.createContext(false);
function Or(e3) {
  return e3 && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = Hn), window.ReactQueryClientContext) : Hn;
}
var gs = function() {
  var t3 = import_react.default.useContext(Or(import_react.default.useContext(Lr)));
  if (!t3)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t3;
};
var ps = function(t3) {
  var n2 = t3.client, r = t3.contextSharing, o2 = r === void 0 ? false : r, s = t3.children;
  import_react.default.useEffect(function() {
    return n2.mount(), function() {
      n2.unmount();
    };
  }, [n2]);
  var l = Or(o2);
  return (0, import_jsx_runtime.jsx)(Lr.Provider, {
    value: o2,
    children: (0, import_jsx_runtime.jsx)(l.Provider, {
      value: n2,
      children: s
    })
  });
};
function ys() {
  var e3 = false;
  return {
    clearReset: function() {
      e3 = false;
    },
    reset: function() {
      e3 = true;
    },
    isReset: function() {
      return e3;
    }
  };
}
var Ms = import_react.default.createContext(ys());
var vs = function() {
  return import_react.default.useContext(Ms);
};
function ms(e3, t3, n2) {
  return typeof t3 == "function" ? t3.apply(void 0, n2) : typeof t3 == "boolean" ? t3 : !!e3;
}
function As(e3, t3) {
  var n2 = import_react.default.useRef(false), r = import_react.default.useState(0), o2 = r[1], s = gs(), l = vs(), u = s.defaultQueryObserverOptions(e3);
  u.optimisticResults = true, u.onError && (u.onError = _.batchCalls(u.onError)), u.onSuccess && (u.onSuccess = _.batchCalls(u.onSuccess)), u.onSettled && (u.onSettled = _.batchCalls(u.onSettled)), u.suspense && (typeof u.staleTime != "number" && (u.staleTime = 1e3), u.cacheTime === 0 && (u.cacheTime = 1)), (u.suspense || u.useErrorBoundary) && (l.isReset() || (u.retryOnMount = false));
  var f = import_react.default.useState(function() {
    return new t3(s, u);
  }), h = f[0], p = h.getOptimisticResult(u);
  if (import_react.default.useEffect(function() {
    n2.current = true, l.clearReset();
    var y = h.subscribe(_.batchCalls(function() {
      n2.current && o2(function(A) {
        return A + 1;
      });
    }));
    return h.updateResult(), function() {
      n2.current = false, y();
    };
  }, [l, h]), import_react.default.useEffect(function() {
    h.setOptions(u, {
      listeners: false
    });
  }, [u, h]), u.suspense && p.isLoading)
    throw h.fetchOptimistic(u).then(function(y) {
      var A = y.data;
      u.onSuccess == null || u.onSuccess(A), u.onSettled == null || u.onSettled(A, null);
    }).catch(function(y) {
      l.clearReset(), u.onError == null || u.onError(y), u.onSettled == null || u.onSettled(void 0, y);
    });
  if (p.isError && !l.isReset() && !p.isFetching && ms(u.suspense, u.useErrorBoundary, [p.error, h.getCurrentQuery()]))
    throw p.error;
  return u.notifyOnChangeProps === "tracked" && (p = h.trackResult(p, u)), p;
}
function Ns(e3, t3, n2) {
  var r = wt(e3, t3, n2);
  return As(r, ls);
}
var xr = ((e3) => (e3.COIN_BALANCE = "SUIET_COIN_BALANCE", e3))(xr || {});
function Is(e3, t3) {
  const n2 = new URLSearchParams(t3);
  return e3 + "?" + n2.toString();
}
function bs(e3) {
  const t3 = dt();
  return e3 ? (0, import_react.useMemo)(() => t3.chains.find((n2) => n2.id === e3), [e3, t3.chains]) : t3.chain;
}
function ws(e3) {
  var _a2;
  const t3 = dt(), {
    address: n2 = t3.address,
    typeArg: r = SUI_TYPE_ARG,
    chainId: o2 = (_a2 = t3.chain) == null ? void 0 : _a2.id
  } = e3 || {}, s = bs(o2), l = Is(xr.COIN_BALANCE, {
    address: n2,
    typeArg: r,
    chainId: o2
  }), u = (0, import_react.useCallback)(() => !n2 || !s ? BigInt(0) : new Hi(n2, {
    chainRpcUrl: s.rpcUrl
  }).getCoinBalance(r), [s, n2]);
  return Ns(l, u, {
    initialData: BigInt(0)
  });
}
function Es(e3) {
  const {
    typeArg: t3,
    chainId: n2
  } = e3 || {}, r = ws({
    typeArg: t3,
    chainId: n2
  });
  return Object.assign(r, {
    // legacy interfaces
    balance: r.data,
    loading: r.isLoading
  });
}
function Ou(e3) {
  return (0, import_react.useMemo)(() => new SuiClient({ url: e3 }), [e3]);
}
function Oe(e3) {
  return Array.isArray(e3) && e3.length > 0;
}
function Ds() {
  const e3 = (0, import_react.useRef)(null), [t3, n2] = (0, import_react.useState)([]);
  return (0, import_react.useEffect)(() => {
    e3.current || (e3.current = new ko(), e3.current.activate());
    const r = e3.current.getDetectedWalletAdapters();
    return n2(r), e3.current.subscribe((o2) => {
      n2(o2);
    }), () => {
      e3.current && (e3.current.deactivate(), e3.current = null);
    };
  }, []), {
    data: t3
  };
}
var Cs = (e3) => {
  const { data: t3 } = Ds(), n2 = (0, import_react.useMemo)(() => Oe(e3) ? Oe(t3) ? e3.map((s) => {
    const l = t3.find(
      (u) => s.name === u.name
    );
    return l ? {
      ...s,
      adapter: l,
      installed: true
    } : {
      ...s,
      adapter: void 0,
      installed: false
    };
  }) : e3.map(
    (s) => ({
      ...s,
      adapter: void 0,
      installed: false
    })
  ) : [], [e3, t3]), r = (0, import_react.useMemo)(() => Oe(t3) ? t3.filter((s) => !e3.find((l) => l.name === s.name)).map((s) => ({
    name: s.name,
    label: s.name,
    adapter: s,
    installed: true,
    iconUrl: s.icon,
    downloadUrl: {
      browserExtension: ""
      // no need to know
    }
  })) : [], [e3, t3]);
  return {
    allAvailableWallets: (0, import_react.useMemo)(() => [...n2, ...r].filter(
      (s) => s.installed
    ), [n2, r]),
    configuredWallets: n2,
    detectedWallets: r
  };
};
var gn = class {
  constructor() {
    if (!window)
      throw new Error("window not found: storage should be used in browser env");
  }
  get length() {
    return window.localStorage.length;
  }
  setItem(t3, n2) {
    try {
      let r = JSON.stringify(n2);
      return window.localStorage.setItem(t3, r);
    } catch (r) {
      throw new Error("stringify data failed when setItem: " + r.message);
    }
  }
  getItem(t3) {
    const n2 = window.localStorage.getItem(t3);
    if (!n2)
      return n2;
    try {
      return JSON.parse(n2);
    } catch (r) {
      throw new Error("parse data failed when getItem: " + r.message);
    }
  }
  removeItem(t3) {
    return window.localStorage.removeItem(t3);
  }
  clear() {
    return window.localStorage.clear();
  }
};
var Qt = ((e3) => (e3.LAST_CONNECT_WALLET_NAME = "WK__LAST_CONNECT_WALLET_NAME", e3))(Qt || {});
function Ts(e3, t3, n2, r) {
  const o2 = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (!r || o2.current || !Oe(n2) || t3 !== me.DISCONNECTED)
      return;
    const l = new gn().getItem(
      Qt.LAST_CONNECT_WALLET_NAME
    );
    l && n2.find((u) => u.name == l) && e3(l).then(() => {
      o2.current = true;
    }).catch((u) => {
    });
  }, [n2]);
}
function js(e3) {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = e3 == null ? void 0 : e3.accounts) == null ? void 0 : _a2[0]) == null ? void 0 : _b.chains) == null ? void 0 : _c[0]) ? e3.accounts[0].chains[0] : "sui:unknown";
}
var xu = (e3) => {
  const {
    defaultWallets: t3 = Co,
    chains: n2 = Yo,
    autoConnect: r = true,
    children: o2
  } = e3, {
    allAvailableWallets: s,
    configuredWallets: l,
    detectedWallets: u
  } = Cs(t3), [f, h] = (0, import_react.useState)(), [p, y] = (0, import_react.useState)(me.DISCONNECTED), [A, v] = (0, import_react.useState)(() => Oe(n2) ? n2[0] : it), I = (0, import_react.useRef)([]), m = (j, R) => j && R === me.CONNECTED, w = (0, import_react.useMemo)(() => {
    if (m(f, p))
      return f.accounts[0];
  }, [f, p]), E = (j, R) => {
    if (!m(j, R))
      throw new ie("Failed to call function, wallet not connected");
  }, T = (0, import_react.useCallback)(async (j, R) => {
    if (!j)
      throw new ie("param adapter is missing");
    y(me.CONNECTING);
    try {
      const k = await j.connect(R);
      if (Oe(k == null ? void 0 : k.accounts)) {
        const H = js(k), ee = n2.find((Te) => Te.id === H);
        v(ee ?? it);
      }
      return h(j), y(me.CONNECTED), new gn().setItem(Qt.LAST_CONNECT_WALLET_NAME, j.name), k;
    } catch (k) {
      throw h(void 0), y(me.DISCONNECTED), k;
    }
  }, []), D = (0, import_react.useCallback)(async () => {
    E(f, p);
    const j = f;
    Oe(I.current) && (I.current.forEach((k) => {
      try {
        k();
      } catch (Z) {
        console.error("error when clearing wallet listener", Z.message);
      }
    }), I.current = []), new gn().removeItem(Qt.LAST_CONNECT_WALLET_NAME);
    try {
      j.hasFeature(Le.STANDARD__DISCONNECT) && await j.disconnect();
    } finally {
      h(void 0), y(me.DISCONNECTED), v((n2 == null ? void 0 : n2[0]) ?? it);
    }
  }, [f, p]), P = (0, import_react.useCallback)(async (j) => {
    if (m(f, p)) {
      if (j === f.name)
        return;
      await D();
    }
    const R = s.find((k) => k.name === j);
    if (!R) {
      const k = s.map((Z) => Z.name);
      throw new ie(`select failed: wallet ${j} is not available, all wallets are listed here: [${k.join(", ")}]`);
    }
    await T(R.adapter);
  }, [f, p, s]), S = (0, import_react.useCallback)((j, R) => {
    E(f, p);
    const Z = f.on("change", (H) => {
      var _a2, _b;
      if (j === "change") {
        R(H);
        return;
      }
      if (H.chains && j === "chainChange") {
        R({
          chain: (_a2 = H.chains) == null ? void 0 : _a2[0]
        });
        return;
      }
      if (H.accounts && j === "accountChange") {
        R({
          account: (_b = H.accounts) == null ? void 0 : _b[0]
        });
        return;
      }
      if (H.features && j === "featureChange") {
        R({
          features: H.features
        });
        return;
      }
    });
    return I.current.push(Z), Z;
  }, [f, p]), O = (0, import_react.useCallback)(() => (E(f, p), f.accounts), [f, p]), K = (0, import_react.useCallback)(async (j) => {
    if (E(f, p), !w)
      throw new ie("no active account");
    return await f.signAndExecuteTransactionBlock({
      account: w,
      chain: A.id,
      ...j
    });
  }, [f, p, A, w]), x = (0, import_react.useCallback)(async (j) => {
    if (E(f, p), !w)
      throw new ie("no active account");
    return await f.signTransactionBlock({
      account: w,
      chain: A.id,
      ...j
    });
  }, [f, p, A, w]), oe = (0, import_react.useCallback)(async (j) => {
    if (E(f, p), !w)
      throw new ie("no active account");
    return await f.signMessage({
      account: w,
      message: j.message
    });
  }, [f, w, p]), $ = (0, import_react.useCallback)(async (j) => {
    if (E(f, p), !w)
      throw new ie("no active account");
    return await f.signPersonalMessage({
      account: w,
      message: j.message
    });
  }, [f, w, p]);
  return Ts(P, p, s, r), (0, import_react.useEffect)(() => {
    if (!f || p !== "connected")
      return;
    const j = S("chainChange", (R) => {
      if (R.chain === A.id)
        return;
      const k = n2.find((Z) => Z.id === R.chain);
      if (!k) {
        v(it);
        return;
      }
      v(k);
    });
    return () => {
      j();
    };
  }, [f, p, A, n2, S]), (0, import_jsx_runtime.jsx)(wr.Provider, {
    value: {
      name: f == null ? void 0 : f.name,
      chains: n2,
      chain: A,
      allAvailableWallets: s,
      configuredWallets: l,
      detectedWallets: u,
      adapter: f,
      status: p,
      connecting: p === me.CONNECTING,
      connected: p === me.CONNECTED,
      select: P,
      disconnect: D,
      on: S,
      getAccounts: O,
      account: w,
      signAndExecuteTransactionBlock: K,
      signPersonalMessage: $,
      signMessage: oe,
      signTransactionBlock: x,
      verifySignedMessage: fo,
      address: w == null ? void 0 : w.address
    },
    children: (0, import_jsx_runtime.jsx)(ps, {
      client: new cs(),
      children: o2
    })
  });
};
function Ss(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
var Rr = { exports: {} };
(function(e3) {
  (function() {
    var t3 = {}.hasOwnProperty;
    function n2() {
      for (var r = [], o2 = 0; o2 < arguments.length; o2++) {
        var s = arguments[o2];
        if (s) {
          var l = typeof s;
          if (l === "string" || l === "number")
            r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var u = n2.apply(null, s);
              u && r.push(u);
            }
          } else if (l === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue;
            }
            for (var f in s)
              t3.call(s, f) && s[f] && r.push(f);
          }
        }
      }
      return r.join(" ");
    }
    e3.exports ? (n2.default = n2, e3.exports = n2) : window.classNames = n2;
  })();
})(Rr);
var Ls = Rr.exports;
var ut = Ss(Ls);
function ve() {
  return ve = Object.assign ? Object.assign.bind() : function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n2 = arguments[t3];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (e3[r] = n2[r]);
    }
    return e3;
  }, ve.apply(this, arguments);
}
function Qe(e3, t3, { checkForDefaultPrevented: n2 = true } = {}) {
  return function(o2) {
    if (e3 == null ? void 0 : e3(o2), n2 === false || !o2.defaultPrevented)
      return t3 == null ? void 0 : t3(o2);
  };
}
function Os(e3, t3) {
  typeof e3 == "function" ? e3(t3) : e3 != null && (e3.current = t3);
}
function Ur(...e3) {
  return (t3) => e3.forEach(
    (n2) => Os(n2, t3)
  );
}
function nt(...e3) {
  return (0, import_react.useCallback)(Ur(...e3), e3);
}
function xs(e3, t3 = []) {
  let n2 = [];
  function r(s, l) {
    const u = (0, import_react.createContext)(l), f = n2.length;
    n2 = [
      ...n2,
      l
    ];
    function h(y) {
      const { scope: A, children: v, ...I } = y, m = (A == null ? void 0 : A[e3][f]) || u, w = (0, import_react.useMemo)(
        () => I,
        Object.values(I)
      );
      return (0, import_react.createElement)(m.Provider, {
        value: w
      }, v);
    }
    function p(y, A) {
      const v = (A == null ? void 0 : A[e3][f]) || u, I = (0, import_react.useContext)(v);
      if (I)
        return I;
      if (l !== void 0)
        return l;
      throw new Error(`\`${y}\` must be used within \`${s}\``);
    }
    return h.displayName = s + "Provider", [
      h,
      p
    ];
  }
  const o2 = () => {
    const s = n2.map((l) => (0, import_react.createContext)(l));
    return function(u) {
      const f = (u == null ? void 0 : u[e3]) || s;
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${e3}`]: {
            ...u,
            [e3]: f
          }
        }),
        [
          u,
          f
        ]
      );
    };
  };
  return o2.scopeName = e3, [
    r,
    Rs(o2, ...t3)
  ];
}
function Rs(...e3) {
  const t3 = e3[0];
  if (e3.length === 1)
    return t3;
  const n2 = () => {
    const r = e3.map(
      (o2) => ({
        useScope: o2(),
        scopeName: o2.scopeName
      })
    );
    return function(s) {
      const l = r.reduce((u, { useScope: f, scopeName: h }) => {
        const y = f(s)[`__scope${h}`];
        return {
          ...u,
          ...y
        };
      }, {});
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${t3.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n2.scopeName = t3.scopeName, n2;
}
var pn = (globalThis == null ? void 0 : globalThis.document) ? import_react.useLayoutEffect : () => {
};
var Us = W.useId || (() => {
});
var Ps = 0;
function en(e3) {
  const [t3, n2] = W.useState(Us());
  return pn(() => {
    e3 || n2(
      (r) => r ?? String(Ps++)
    );
  }, [
    e3
  ]), e3 || (t3 ? `radix-${t3}` : "");
}
function Ze(e3) {
  const t3 = (0, import_react.useRef)(e3);
  return (0, import_react.useEffect)(() => {
    t3.current = e3;
  }), (0, import_react.useMemo)(
    () => (...n2) => {
      var r;
      return (r = t3.current) === null || r === void 0 ? void 0 : r.call(t3, ...n2);
    },
    []
  );
}
function zs({ prop: e3, defaultProp: t3, onChange: n2 = () => {
} }) {
  const [r, o2] = ks({
    defaultProp: t3,
    onChange: n2
  }), s = e3 !== void 0, l = s ? e3 : r, u = Ze(n2), f = (0, import_react.useCallback)((h) => {
    if (s) {
      const y = typeof h == "function" ? h(e3) : h;
      y !== e3 && u(y);
    } else
      o2(h);
  }, [
    s,
    e3,
    o2,
    u
  ]);
  return [
    l,
    f
  ];
}
function ks({ defaultProp: e3, onChange: t3 }) {
  const n2 = (0, import_react.useState)(e3), [r] = n2, o2 = (0, import_react.useRef)(r), s = Ze(t3);
  return (0, import_react.useEffect)(() => {
    o2.current !== r && (s(r), o2.current = r);
  }, [
    r,
    o2,
    s
  ]), n2;
}
function Fe() {
  return Fe = Object.assign ? Object.assign.bind() : function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n2 = arguments[t3];
      for (var r in n2)
        Object.prototype.hasOwnProperty.call(n2, r) && (e3[r] = n2[r]);
    }
    return e3;
  }, Fe.apply(this, arguments);
}
var jn = (0, import_react.forwardRef)((e3, t3) => {
  const { children: n2, ...r } = e3, o2 = import_react.Children.toArray(n2), s = o2.find(Fs);
  if (s) {
    const l = s.props.children, u = o2.map((f) => f === s ? import_react.Children.count(l) > 1 ? import_react.Children.only(null) : (0, import_react.isValidElement)(l) ? l.props.children : null : f);
    return (0, import_react.createElement)(yn, Fe({}, r, {
      ref: t3
    }), (0, import_react.isValidElement)(l) ? (0, import_react.cloneElement)(l, void 0, u) : null);
  }
  return (0, import_react.createElement)(yn, Fe({}, r, {
    ref: t3
  }), n2);
});
jn.displayName = "Slot";
var yn = (0, import_react.forwardRef)((e3, t3) => {
  const { children: n2, ...r } = e3;
  return (0, import_react.isValidElement)(n2) ? (0, import_react.cloneElement)(n2, {
    ...Bs(r, n2.props),
    ref: Ur(t3, n2.ref)
  }) : import_react.Children.count(n2) > 1 ? import_react.Children.only(null) : null;
});
yn.displayName = "SlotClone";
var Qs = ({ children: e3 }) => (0, import_react.createElement)(import_react.Fragment, null, e3);
function Fs(e3) {
  return (0, import_react.isValidElement)(e3) && e3.type === Qs;
}
function Bs(e3, t3) {
  const n2 = {
    ...t3
  };
  for (const r in t3) {
    const o2 = e3[r], s = t3[r];
    /^on[A-Z]/.test(r) ? o2 && s ? n2[r] = (...u) => {
      s(...u), o2(...u);
    } : o2 && (n2[r] = o2) : r === "style" ? n2[r] = {
      ...o2,
      ...s
    } : r === "className" && (n2[r] = [
      o2,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...e3,
    ...n2
  };
}
var Ws = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Ve = Ws.reduce((e3, t3) => {
  const n2 = (0, import_react.forwardRef)((r, o2) => {
    const { asChild: s, ...l } = r, u = s ? jn : t3;
    return (0, import_react.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []), (0, import_react.createElement)(u, Fe({}, l, {
      ref: o2
    }));
  });
  return n2.displayName = `Primitive.${t3}`, {
    ...e3,
    [t3]: n2
  };
}, {});
function Ys(e3, t3) {
  e3 && (0, import_react_dom.flushSync)(
    () => e3.dispatchEvent(t3)
  );
}
function Gs(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = Ze(e3);
  (0, import_react.useEffect)(() => {
    const r = (o2) => {
      o2.key === "Escape" && n2(o2);
    };
    return t3.addEventListener("keydown", r), () => t3.removeEventListener("keydown", r);
  }, [
    n2,
    t3
  ]);
}
var Mn = "dismissableLayer.update";
var _s = "dismissableLayer.pointerDownOutside";
var Zs = "dismissableLayer.focusOutside";
var Jn;
var Vs = (0, import_react.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var qs = (0, import_react.forwardRef)((e3, t3) => {
  var n2;
  const { disableOutsidePointerEvents: r = false, onEscapeKeyDown: o2, onPointerDownOutside: s, onFocusOutside: l, onInteractOutside: u, onDismiss: f, ...h } = e3, p = (0, import_react.useContext)(Vs), [y, A] = (0, import_react.useState)(null), v = (n2 = y == null ? void 0 : y.ownerDocument) !== null && n2 !== void 0 ? n2 : globalThis == null ? void 0 : globalThis.document, [, I] = (0, import_react.useState)({}), m = nt(
    t3,
    (x) => A(x)
  ), w = Array.from(p.layers), [E] = [
    ...p.layersWithOutsidePointerEventsDisabled
  ].slice(-1), T = w.indexOf(E), D = y ? w.indexOf(y) : -1, P = p.layersWithOutsidePointerEventsDisabled.size > 0, S = D >= T, O = Xs((x) => {
    const oe = x.target, $ = [
      ...p.branches
    ].some(
      (j) => j.contains(oe)
    );
    !S || $ || (s == null ? void 0 : s(x), u == null ? void 0 : u(x), x.defaultPrevented || (f == null ? void 0 : f()));
  }, v), K = Ks((x) => {
    const oe = x.target;
    [
      ...p.branches
    ].some(
      (j) => j.contains(oe)
    ) || (l == null ? void 0 : l(x), u == null ? void 0 : u(x), x.defaultPrevented || (f == null ? void 0 : f()));
  }, v);
  return Gs((x) => {
    D === p.layers.size - 1 && (o2 == null ? void 0 : o2(x), !x.defaultPrevented && f && (x.preventDefault(), f()));
  }, v), (0, import_react.useEffect)(() => {
    if (y)
      return r && (p.layersWithOutsidePointerEventsDisabled.size === 0 && (Jn = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), p.layersWithOutsidePointerEventsDisabled.add(y)), p.layers.add(y), $n(), () => {
        r && p.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = Jn);
      };
  }, [
    y,
    v,
    r,
    p
  ]), (0, import_react.useEffect)(() => () => {
    y && (p.layers.delete(y), p.layersWithOutsidePointerEventsDisabled.delete(y), $n());
  }, [
    y,
    p
  ]), (0, import_react.useEffect)(() => {
    const x = () => I({});
    return document.addEventListener(Mn, x), () => document.removeEventListener(Mn, x);
  }, []), (0, import_react.createElement)(Ve.div, Fe({}, h, {
    ref: m,
    style: {
      pointerEvents: P ? S ? "auto" : "none" : void 0,
      ...e3.style
    },
    onFocusCapture: Qe(e3.onFocusCapture, K.onFocusCapture),
    onBlurCapture: Qe(e3.onBlurCapture, K.onBlurCapture),
    onPointerDownCapture: Qe(e3.onPointerDownCapture, O.onPointerDownCapture)
  }));
});
function Xs(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = Ze(e3), r = (0, import_react.useRef)(false), o2 = (0, import_react.useRef)(() => {
  });
  return (0, import_react.useEffect)(() => {
    const s = (u) => {
      if (u.target && !r.current) {
        let h = function() {
          Pr(_s, n2, f, {
            discrete: true
          });
        };
        const f = {
          originalEvent: u
        };
        u.pointerType === "touch" ? (t3.removeEventListener("click", o2.current), o2.current = h, t3.addEventListener("click", o2.current, {
          once: true
        })) : h();
      }
      r.current = false;
    }, l = window.setTimeout(() => {
      t3.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t3.removeEventListener("pointerdown", s), t3.removeEventListener("click", o2.current);
    };
  }, [
    t3,
    n2
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = true
  };
}
function Ks(e3, t3 = globalThis == null ? void 0 : globalThis.document) {
  const n2 = Ze(e3), r = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(() => {
    const o2 = (s) => {
      s.target && !r.current && Pr(Zs, n2, {
        originalEvent: s
      }, {
        discrete: false
      });
    };
    return t3.addEventListener("focusin", o2), () => t3.removeEventListener("focusin", o2);
  }, [
    t3,
    n2
  ]), {
    onFocusCapture: () => r.current = true,
    onBlurCapture: () => r.current = false
  };
}
function $n() {
  const e3 = new CustomEvent(Mn);
  document.dispatchEvent(e3);
}
function Pr(e3, t3, n2, { discrete: r }) {
  const o2 = n2.originalEvent.target, s = new CustomEvent(e3, {
    bubbles: false,
    cancelable: true,
    detail: n2
  });
  t3 && o2.addEventListener(e3, t3, {
    once: true
  }), r ? Ys(o2, s) : o2.dispatchEvent(s);
}
var tn = "focusScope.autoFocusOnMount";
var nn = "focusScope.autoFocusOnUnmount";
var er = {
  bubbles: false,
  cancelable: true
};
var Hs = (0, import_react.forwardRef)((e3, t3) => {
  const { loop: n2 = false, trapped: r = false, onMountAutoFocus: o2, onUnmountAutoFocus: s, ...l } = e3, [u, f] = (0, import_react.useState)(null), h = Ze(o2), p = Ze(s), y = (0, import_react.useRef)(null), A = nt(
    t3,
    (m) => f(m)
  ), v = (0, import_react.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react.useEffect)(() => {
    if (r) {
      let m = function(E) {
        if (v.paused || !u)
          return;
        const T = E.target;
        u.contains(T) ? y.current = T : We(y.current, {
          select: true
        });
      }, w = function(E) {
        v.paused || !u || u.contains(E.relatedTarget) || We(y.current, {
          select: true
        });
      };
      return document.addEventListener("focusin", m), document.addEventListener("focusout", w), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", w);
      };
    }
  }, [
    r,
    u,
    v.paused
  ]), (0, import_react.useEffect)(() => {
    if (u) {
      nr.add(v);
      const m = document.activeElement;
      if (!u.contains(m)) {
        const E = new CustomEvent(tn, er);
        u.addEventListener(tn, h), u.dispatchEvent(E), E.defaultPrevented || (Js(ra(zr(u)), {
          select: true
        }), document.activeElement === m && We(u));
      }
      return () => {
        u.removeEventListener(tn, h), setTimeout(() => {
          const E = new CustomEvent(nn, er);
          u.addEventListener(nn, p), u.dispatchEvent(E), E.defaultPrevented || We(m ?? document.body, {
            select: true
          }), u.removeEventListener(nn, p), nr.remove(v);
        }, 0);
      };
    }
  }, [
    u,
    h,
    p,
    v
  ]);
  const I = (0, import_react.useCallback)((m) => {
    if (!n2 && !r || v.paused)
      return;
    const w = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, E = document.activeElement;
    if (w && E) {
      const T = m.currentTarget, [D, P] = $s(T);
      D && P ? !m.shiftKey && E === P ? (m.preventDefault(), n2 && We(D, {
        select: true
      })) : m.shiftKey && E === D && (m.preventDefault(), n2 && We(P, {
        select: true
      })) : E === T && m.preventDefault();
    }
  }, [
    n2,
    r,
    v.paused
  ]);
  return (0, import_react.createElement)(Ve.div, Fe({
    tabIndex: -1
  }, l, {
    ref: A,
    onKeyDown: I
  }));
});
function Js(e3, { select: t3 = false } = {}) {
  const n2 = document.activeElement;
  for (const r of e3)
    if (We(r, {
      select: t3
    }), document.activeElement !== n2)
      return;
}
function $s(e3) {
  const t3 = zr(e3), n2 = tr(t3, e3), r = tr(t3.reverse(), e3);
  return [
    n2,
    r
  ];
}
function zr(e3) {
  const t3 = [], n2 = document.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o2 = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o2 ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n2.nextNode(); )
    t3.push(n2.currentNode);
  return t3;
}
function tr(e3, t3) {
  for (const n2 of e3)
    if (!ea(n2, {
      upTo: t3
    }))
      return n2;
}
function ea(e3, { upTo: t3 }) {
  if (getComputedStyle(e3).visibility === "hidden")
    return true;
  for (; e3; ) {
    if (t3 !== void 0 && e3 === t3)
      return false;
    if (getComputedStyle(e3).display === "none")
      return true;
    e3 = e3.parentElement;
  }
  return false;
}
function ta(e3) {
  return e3 instanceof HTMLInputElement && "select" in e3;
}
function We(e3, { select: t3 = false } = {}) {
  if (e3 && e3.focus) {
    const n2 = document.activeElement;
    e3.focus({
      preventScroll: true
    }), e3 !== n2 && ta(e3) && t3 && e3.select();
  }
}
var nr = na();
function na() {
  let e3 = [];
  return {
    add(t3) {
      const n2 = e3[0];
      t3 !== n2 && (n2 == null ? void 0 : n2.pause()), e3 = rr(e3, t3), e3.unshift(t3);
    },
    remove(t3) {
      var n2;
      e3 = rr(e3, t3), (n2 = e3[0]) === null || n2 === void 0 || n2.resume();
    }
  };
}
function rr(e3, t3) {
  const n2 = [
    ...e3
  ], r = n2.indexOf(t3);
  return r !== -1 && n2.splice(r, 1), n2;
}
function ra(e3) {
  return e3.filter(
    (t3) => t3.tagName !== "A"
  );
}
var ia = (0, import_react.forwardRef)((e3, t3) => {
  var n2;
  const { container: r = globalThis == null || (n2 = globalThis.document) === null || n2 === void 0 ? void 0 : n2.body, ...o2 } = e3;
  return r ? import_react_dom.default.createPortal((0, import_react.createElement)(Ve.div, Fe({}, o2, {
    ref: t3
  })), r) : null;
});
function oa(e3, t3) {
  return (0, import_react.useReducer)((n2, r) => {
    const o2 = t3[n2][r];
    return o2 ?? n2;
  }, e3);
}
var Gt = (e3) => {
  const { present: t3, children: n2 } = e3, r = sa(t3), o2 = typeof n2 == "function" ? n2({
    present: r.isPresent
  }) : import_react.Children.only(n2), s = nt(r.ref, o2.ref);
  return typeof n2 == "function" || r.isPresent ? (0, import_react.cloneElement)(o2, {
    ref: s
  }) : null;
};
Gt.displayName = "Presence";
function sa(e3) {
  const [t3, n2] = (0, import_react.useState)(), r = (0, import_react.useRef)({}), o2 = (0, import_react.useRef)(e3), s = (0, import_react.useRef)("none"), l = e3 ? "mounted" : "unmounted", [u, f] = oa(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return (0, import_react.useEffect)(() => {
    const h = Mt(r.current);
    s.current = u === "mounted" ? h : "none";
  }, [
    u
  ]), pn(() => {
    const h = r.current, p = o2.current;
    if (p !== e3) {
      const A = s.current, v = Mt(h);
      e3 ? f("MOUNT") : v === "none" || (h == null ? void 0 : h.display) === "none" ? f("UNMOUNT") : f(p && A !== v ? "ANIMATION_OUT" : "UNMOUNT"), o2.current = e3;
    }
  }, [
    e3,
    f
  ]), pn(() => {
    if (t3) {
      const h = (y) => {
        const v = Mt(r.current).includes(y.animationName);
        y.target === t3 && v && (0, import_react_dom.flushSync)(
          () => f("ANIMATION_END")
        );
      }, p = (y) => {
        y.target === t3 && (s.current = Mt(r.current));
      };
      return t3.addEventListener("animationstart", p), t3.addEventListener("animationcancel", h), t3.addEventListener("animationend", h), () => {
        t3.removeEventListener("animationstart", p), t3.removeEventListener("animationcancel", h), t3.removeEventListener("animationend", h);
      };
    } else
      f("ANIMATION_END");
  }, [
    t3,
    f
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(u),
    ref: (0, import_react.useCallback)((h) => {
      h && (r.current = getComputedStyle(h)), n2(h);
    }, [])
  };
}
function Mt(e3) {
  return (e3 == null ? void 0 : e3.animationName) || "none";
}
var rn = 0;
function aa() {
  (0, import_react.useEffect)(() => {
    var e3, t3;
    const n2 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e3 = n2[0]) !== null && e3 !== void 0 ? e3 : ir()), document.body.insertAdjacentElement("beforeend", (t3 = n2[1]) !== null && t3 !== void 0 ? t3 : ir()), rn++, () => {
      rn === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), rn--;
    };
  }, []);
}
function ir() {
  const e3 = document.createElement("span");
  return e3.setAttribute("data-radix-focus-guard", ""), e3.tabIndex = 0, e3.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e3;
}
var ke = function() {
  return ke = Object.assign || function(t3) {
    for (var n2, r = 1, o2 = arguments.length; r < o2; r++) {
      n2 = arguments[r];
      for (var s in n2)
        Object.prototype.hasOwnProperty.call(n2, s) && (t3[s] = n2[s]);
    }
    return t3;
  }, ke.apply(this, arguments);
};
function ua(e3, t3) {
  var n2 = {};
  for (var r in e3)
    Object.prototype.hasOwnProperty.call(e3, r) && t3.indexOf(r) < 0 && (n2[r] = e3[r]);
  if (e3 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o2 = 0, r = Object.getOwnPropertySymbols(e3); o2 < r.length; o2++)
      t3.indexOf(r[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, r[o2]) && (n2[r[o2]] = e3[r[o2]]);
  return n2;
}
function ca(e3, t3, n2) {
  for (var r = 0, o2 = t3.length, s; r < o2; r++)
    (s || !(r in t3)) && (s || (s = Array.prototype.slice.call(t3, 0, r)), s[r] = t3[r]);
  return e3.concat(s || Array.prototype.slice.call(t3));
}
var Ct = "right-scroll-bar-position";
var Tt = "width-before-scroll-bar";
var la = "with-scroll-bars-hidden";
var fa = "--removed-body-scroll-bar-size";
function da(e3, t3) {
  return typeof e3 == "function" ? e3(t3) : e3 && (e3.current = t3), e3;
}
function ha(e3, t3) {
  var n2 = (0, import_react.useState)(function() {
    return {
      // value
      value: e3,
      // last callback
      callback: t3,
      // "memoized" public interface
      facade: {
        get current() {
          return n2.value;
        },
        set current(r) {
          var o2 = n2.value;
          o2 !== r && (n2.value = r, n2.callback(r, o2));
        }
      }
    };
  })[0];
  return n2.callback = t3, n2.facade;
}
function ga(e3, t3) {
  return ha(null, function(n2) {
    return e3.forEach(function(r) {
      return da(r, n2);
    });
  });
}
var Ft = function() {
  return Ft = Object.assign || function(t3) {
    for (var n2, r = 1, o2 = arguments.length; r < o2; r++) {
      n2 = arguments[r];
      for (var s in n2)
        Object.prototype.hasOwnProperty.call(n2, s) && (t3[s] = n2[s]);
    }
    return t3;
  }, Ft.apply(this, arguments);
};
function pa(e3, t3) {
  var n2 = {};
  for (var r in e3)
    Object.prototype.hasOwnProperty.call(e3, r) && t3.indexOf(r) < 0 && (n2[r] = e3[r]);
  if (e3 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o2 = 0, r = Object.getOwnPropertySymbols(e3); o2 < r.length; o2++)
      t3.indexOf(r[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, r[o2]) && (n2[r[o2]] = e3[r[o2]]);
  return n2;
}
function ya(e3) {
  return e3;
}
function Ma(e3, t3) {
  t3 === void 0 && (t3 = ya);
  var n2 = [], r = false, o2 = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n2.length ? n2[n2.length - 1] : e3;
    },
    useMedium: function(s) {
      var l = t3(s, r);
      return n2.push(l), function() {
        n2 = n2.filter(function(u) {
          return u !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = true; n2.length; ) {
        var l = n2;
        n2 = [], l.forEach(s);
      }
      n2 = {
        push: function(u) {
          return s(u);
        },
        filter: function() {
          return n2;
        }
      };
    },
    assignMedium: function(s) {
      r = true;
      var l = [];
      if (n2.length) {
        var u = n2;
        n2 = [], u.forEach(s), l = n2;
      }
      var f = function() {
        var p = l;
        l = [], p.forEach(s);
      }, h = function() {
        return Promise.resolve().then(f);
      };
      h(), n2 = {
        push: function(p) {
          l.push(p), h();
        },
        filter: function(p) {
          return l = l.filter(p), n2;
        }
      };
    }
  };
  return o2;
}
function va(e3) {
  e3 === void 0 && (e3 = {});
  var t3 = Ma(null);
  return t3.options = Ft({ async: true, ssr: false }, e3), t3;
}
var kr = function(e3) {
  var t3 = e3.sideCar, n2 = pa(e3, ["sideCar"]);
  if (!t3)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t3.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return (0, import_jsx_runtime.jsx)(r, {
    ...Ft({}, n2)
  });
};
kr.isSideCarExport = true;
function ma(e3, t3) {
  return e3.useMedium(t3), kr;
}
var Qr = va();
var on = function() {
};
var _t = W.forwardRef(function(e3, t3) {
  var n2 = W.useRef(null), r = W.useState({
    onScrollCapture: on,
    onWheelCapture: on,
    onTouchMoveCapture: on
  }), o2 = r[0], s = r[1], l = e3.forwardProps, u = e3.children, f = e3.className, h = e3.removeScrollBar, p = e3.enabled, y = e3.shards, A = e3.sideCar, v = e3.noIsolation, I = e3.inert, m = e3.allowPinchZoom, w = e3.as, E = w === void 0 ? "div" : w, T = ua(e3, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), D = A, P = ga([n2, t3]), S = ke(ke({}, T), o2);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [p && (0, import_jsx_runtime.jsx)(D, {
      sideCar: Qr,
      removeScrollBar: h,
      shards: y,
      noIsolation: v,
      inert: I,
      setCallbacks: s,
      allowPinchZoom: !!m,
      lockRef: n2
    }), l ? W.cloneElement(W.Children.only(u), ke(ke({}, S), {
      ref: P
    })) : (0, import_jsx_runtime.jsx)(E, {
      ...ke({}, S, {
        className: f,
        ref: P
      }),
      children: u
    })]
  });
});
_t.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
_t.classNames = {
  fullWidth: Tt,
  zeroRight: Ct
};
var Aa = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Na() {
  if (!document)
    return null;
  var e3 = document.createElement("style");
  e3.type = "text/css";
  var t3 = Aa();
  return t3 && e3.setAttribute("nonce", t3), e3;
}
function Ia(e3, t3) {
  e3.styleSheet ? e3.styleSheet.cssText = t3 : e3.appendChild(document.createTextNode(t3));
}
function ba(e3) {
  var t3 = document.head || document.getElementsByTagName("head")[0];
  t3.appendChild(e3);
}
var wa = function() {
  var e3 = 0, t3 = null;
  return {
    add: function(n2) {
      e3 == 0 && (t3 = Na()) && (Ia(t3, n2), ba(t3)), e3++;
    },
    remove: function() {
      e3--, !e3 && t3 && (t3.parentNode && t3.parentNode.removeChild(t3), t3 = null);
    }
  };
};
var Ea = function() {
  var e3 = wa();
  return function(t3, n2) {
    W.useEffect(function() {
      return e3.add(t3), function() {
        e3.remove();
      };
    }, [t3 && n2]);
  };
};
var Fr = function() {
  var e3 = Ea(), t3 = function(n2) {
    var r = n2.styles, o2 = n2.dynamic;
    return e3(r, o2), null;
  };
  return t3;
};
var Da = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var sn = function(e3) {
  return parseInt(e3 || "", 10) || 0;
};
var Ca = function(e3) {
  var t3 = window.getComputedStyle(document.body);
  t3.overflowY === "hidden" && console.error("react-remove-scroll-bar: cannot calculate scrollbar size because it is removed (overflow:hidden on body");
  var n2 = t3[e3 === "padding" ? "paddingLeft" : "marginLeft"], r = t3[e3 === "padding" ? "paddingTop" : "marginTop"], o2 = t3[e3 === "padding" ? "paddingRight" : "marginRight"];
  return [sn(n2), sn(r), sn(o2)];
};
var Ta = function(e3) {
  if (e3 === void 0 && (e3 = "margin"), typeof window > "u")
    return Da;
  var t3 = Ca(e3), n2 = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t3[0],
    top: t3[1],
    right: t3[2],
    gap: Math.max(0, r - n2 + t3[2] - t3[0])
  };
};
var ja = Fr();
var Sa = function(e3, t3, n2, r) {
  var o2 = e3.left, s = e3.top, l = e3.right, u = e3.gap;
  return n2 === void 0 && (n2 = "margin"), `
  .`.concat(la, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t3 && "position: relative ".concat(r, ";"), n2 === "margin" && `
    padding-left: `.concat(o2, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `), n2 === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Ct, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Tt, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Ct, " .").concat(Ct, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Tt, " .").concat(Tt, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(fa, ": ").concat(u, `px;
  }
`);
};
var La = function(e3) {
  var t3 = e3.noRelative, n2 = e3.noImportant, r = e3.gapMode, o2 = r === void 0 ? "margin" : r, s = W.useMemo(function() {
    return Ta(o2);
  }, [o2]);
  return (0, import_jsx_runtime.jsx)(ja, {
    styles: Sa(s, !t3, o2, n2 ? "" : "!important")
  });
};
var vn = false;
if (typeof window < "u")
  try {
    vt = Object.defineProperty({}, "passive", {
      get: function() {
        return vn = true, true;
      }
    });
    window.addEventListener("test", vt, vt), window.removeEventListener("test", vt, vt);
  } catch {
    vn = false;
  }
var vt;
var Je = vn ? { passive: false } : false;
var Oa = function(e3) {
  return e3.tagName === "TEXTAREA";
};
var Br = function(e3, t3) {
  var n2 = window.getComputedStyle(e3);
  return (
    // not-not-scrollable
    n2[t3] !== "hidden" && // contains scroll inside self
    !(n2.overflowY === n2.overflowX && !Oa(e3) && n2[t3] === "visible")
  );
};
var xa = function(e3) {
  return Br(e3, "overflowY");
};
var Ra = function(e3) {
  return Br(e3, "overflowX");
};
var or = function(e3, t3) {
  var n2 = t3;
  do {
    typeof ShadowRoot < "u" && n2 instanceof ShadowRoot && (n2 = n2.host);
    var r = Wr(e3, n2);
    if (r) {
      var o2 = Yr(e3, n2), s = o2[1], l = o2[2];
      if (s > l)
        return true;
    }
    n2 = n2.parentNode;
  } while (n2 && n2 !== document.body);
  return false;
};
var Ua = function(e3) {
  var t3 = e3.scrollTop, n2 = e3.scrollHeight, r = e3.clientHeight;
  return [
    t3,
    n2,
    r
  ];
};
var Pa = function(e3) {
  var t3 = e3.scrollLeft, n2 = e3.scrollWidth, r = e3.clientWidth;
  return [
    t3,
    n2,
    r
  ];
};
var Wr = function(e3, t3) {
  return e3 === "v" ? xa(t3) : Ra(t3);
};
var Yr = function(e3, t3) {
  return e3 === "v" ? Ua(t3) : Pa(t3);
};
var za = function(e3, t3) {
  return e3 === "h" && t3 === "rtl" ? -1 : 1;
};
var ka = function(e3, t3, n2, r, o2) {
  var s = za(e3, window.getComputedStyle(t3).direction), l = s * r, u = n2.target, f = t3.contains(u), h = false, p = l > 0, y = 0, A = 0;
  do {
    var v = Yr(e3, u), I = v[0], m = v[1], w = v[2], E = m - w - s * I;
    (I || E) && Wr(e3, u) && (y += E, A += I), u = u.parentNode;
  } while (
    // portaled content
    !f && u !== document.body || // self content
    f && (t3.contains(u) || t3 === u)
  );
  return (p && (y === 0 || !o2) || !p && (A === 0 || !o2)) && (h = true), h;
};
var mt = function(e3) {
  return "changedTouches" in e3 ? [e3.changedTouches[0].clientX, e3.changedTouches[0].clientY] : [0, 0];
};
var sr = function(e3) {
  return [e3.deltaX, e3.deltaY];
};
var ar = function(e3) {
  return e3 && "current" in e3 ? e3.current : e3;
};
var Qa = function(e3, t3) {
  return e3[0] === t3[0] && e3[1] === t3[1];
};
var Fa = function(e3) {
  return `
  .block-interactivity-`.concat(e3, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e3, ` {pointer-events: all;}
`);
};
var Ba = 0;
var $e = [];
function Wa(e3) {
  var t3 = W.useRef([]), n2 = W.useRef([0, 0]), r = W.useRef(), o2 = W.useState(Ba++)[0], s = W.useState(function() {
    return Fr();
  })[0], l = W.useRef(e3);
  W.useEffect(function() {
    l.current = e3;
  }, [e3]), W.useEffect(function() {
    if (e3.inert) {
      document.body.classList.add("block-interactivity-".concat(o2));
      var m = ca([e3.lockRef.current], (e3.shards || []).map(ar)).filter(Boolean);
      return m.forEach(function(w) {
        return w.classList.add("allow-interactivity-".concat(o2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o2)), m.forEach(function(w) {
          return w.classList.remove("allow-interactivity-".concat(o2));
        });
      };
    }
  }, [e3.inert, e3.lockRef.current, e3.shards]);
  var u = W.useCallback(function(m, w) {
    if ("touches" in m && m.touches.length === 2)
      return !l.current.allowPinchZoom;
    var E = mt(m), T = n2.current, D = "deltaX" in m ? m.deltaX : T[0] - E[0], P = "deltaY" in m ? m.deltaY : T[1] - E[1], S, O = m.target, K = Math.abs(D) > Math.abs(P) ? "h" : "v";
    if ("touches" in m && K === "h" && O.type === "range")
      return false;
    var x = or(K, O);
    if (!x)
      return true;
    if (x ? S = K : (S = K === "v" ? "h" : "v", x = or(K, O)), !x)
      return false;
    if (!r.current && "changedTouches" in m && (D || P) && (r.current = S), !S)
      return true;
    var oe = r.current || S;
    return ka(oe, w, m, oe === "h" ? D : P, true);
  }, []), f = W.useCallback(function(m) {
    var w = m;
    if (!(!$e.length || $e[$e.length - 1] !== s)) {
      var E = "deltaY" in w ? sr(w) : mt(w), T = t3.current.filter(function(S) {
        return S.name === w.type && S.target === w.target && Qa(S.delta, E);
      })[0];
      if (T && T.should) {
        w.cancelable && w.preventDefault();
        return;
      }
      if (!T) {
        var D = (l.current.shards || []).map(ar).filter(Boolean).filter(function(S) {
          return S.contains(w.target);
        }), P = D.length > 0 ? u(w, D[0]) : !l.current.noIsolation;
        P && w.cancelable && w.preventDefault();
      }
    }
  }, []), h = W.useCallback(function(m, w, E, T) {
    var D = {
      name: m,
      delta: w,
      target: E,
      should: T
    };
    t3.current.push(D), setTimeout(function() {
      t3.current = t3.current.filter(function(P) {
        return P !== D;
      });
    }, 1);
  }, []), p = W.useCallback(function(m) {
    n2.current = mt(m), r.current = void 0;
  }, []), y = W.useCallback(function(m) {
    h(m.type, sr(m), m.target, u(m, e3.lockRef.current));
  }, []), A = W.useCallback(function(m) {
    h(m.type, mt(m), m.target, u(m, e3.lockRef.current));
  }, []);
  W.useEffect(function() {
    return $e.push(s), e3.setCallbacks({
      onScrollCapture: y,
      onWheelCapture: y,
      onTouchMoveCapture: A
    }), document.addEventListener("wheel", f, Je), document.addEventListener("touchmove", f, Je), document.addEventListener("touchstart", p, Je), function() {
      $e = $e.filter(function(m) {
        return m !== s;
      }), document.removeEventListener("wheel", f, Je), document.removeEventListener("touchmove", f, Je), document.removeEventListener("touchstart", p, Je);
    };
  }, []);
  var v = e3.removeScrollBar, I = e3.inert;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [I ? (0, import_jsx_runtime.jsx)(s, {
      styles: Fa(o2)
    }) : null, v ? (0, import_jsx_runtime.jsx)(La, {
      gapMode: "margin"
    }) : null]
  });
}
var Ya = ma(Qr, Wa);
var Gr = W.forwardRef(function(e3, t3) {
  return (0, import_jsx_runtime.jsx)(_t, {
    ...ke({}, e3, {
      ref: t3,
      sideCar: Ya
    })
  });
});
Gr.classNames = _t.classNames;
var Ga = function(e3) {
  if (typeof document > "u")
    return null;
  var t3 = Array.isArray(e3) ? e3[0] : e3;
  return t3.ownerDocument.body;
};
var et = /* @__PURE__ */ new WeakMap();
var At = /* @__PURE__ */ new WeakMap();
var Nt = {};
var an = 0;
var _a = function(e3, t3, n2, r) {
  var o2 = Array.isArray(e3) ? e3 : [e3];
  Nt[n2] || (Nt[n2] = /* @__PURE__ */ new WeakMap());
  var s = Nt[n2], l = [], u = /* @__PURE__ */ new Set(), f = new Set(o2), h = function(y) {
    !y || u.has(y) || (u.add(y), h(y.parentNode));
  };
  o2.forEach(h);
  var p = function(y) {
    !y || f.has(y) || Array.prototype.forEach.call(y.children, function(A) {
      if (u.has(A))
        p(A);
      else {
        var v = A.getAttribute(r), I = v !== null && v !== "false", m = (et.get(A) || 0) + 1, w = (s.get(A) || 0) + 1;
        et.set(A, m), s.set(A, w), l.push(A), m === 1 && I && At.set(A, true), w === 1 && A.setAttribute(n2, "true"), I || A.setAttribute(r, "true");
      }
    });
  };
  return p(t3), u.clear(), an++, function() {
    l.forEach(function(y) {
      var A = et.get(y) - 1, v = s.get(y) - 1;
      et.set(y, A), s.set(y, v), A || (At.has(y) || y.removeAttribute(r), At.delete(y)), v || y.removeAttribute(n2);
    }), an--, an || (et = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), Nt = {});
  };
};
var Za = function(e3, t3, n2) {
  n2 === void 0 && (n2 = "data-aria-hidden");
  var r = Array.from(Array.isArray(e3) ? e3 : [e3]), o2 = Ga(e3);
  return o2 ? (r.push.apply(r, Array.from(o2.querySelectorAll("[aria-live]"))), _a(r, o2, n2, "aria-hidden")) : function() {
    return null;
  };
};
var _r = "Dialog";
var [Zr, Ru] = xs(_r);
var [Va, Ce] = Zr(_r);
var qa = (e3) => {
  const { __scopeDialog: t3, children: n2, open: r, defaultOpen: o2, onOpenChange: s, modal: l = true } = e3, u = (0, import_react.useRef)(null), f = (0, import_react.useRef)(null), [h = false, p] = zs({
    prop: r,
    defaultProp: o2,
    onChange: s
  });
  return (0, import_react.createElement)(Va, {
    scope: t3,
    triggerRef: u,
    contentRef: f,
    contentId: en(),
    titleId: en(),
    descriptionId: en(),
    open: h,
    onOpenChange: p,
    onOpenToggle: (0, import_react.useCallback)(
      () => p(
        (y) => !y
      ),
      [
        p
      ]
    ),
    modal: l
  }, n2);
};
var Xa = "DialogTrigger";
var Ka = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, o2 = Ce(Xa, n2), s = nt(t3, o2.triggerRef);
  return (0, import_react.createElement)(Ve.button, ve({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": o2.open,
    "aria-controls": o2.contentId,
    "data-state": Sn(o2.open)
  }, r, {
    ref: s,
    onClick: Qe(e3.onClick, o2.onOpenToggle)
  }));
});
var Vr = "DialogPortal";
var [Ha, qr] = Zr(Vr, {
  forceMount: void 0
});
var Ja = (e3) => {
  const { __scopeDialog: t3, forceMount: n2, children: r, container: o2 } = e3, s = Ce(Vr, t3);
  return (0, import_react.createElement)(Ha, {
    scope: t3,
    forceMount: n2
  }, import_react.Children.map(
    r,
    (l) => (0, import_react.createElement)(Gt, {
      present: n2 || s.open
    }, (0, import_react.createElement)(ia, {
      asChild: true,
      container: o2
    }, l))
  ));
};
var mn = "DialogOverlay";
var $a = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = qr(mn, e3.__scopeDialog), { forceMount: r = n2.forceMount, ...o2 } = e3, s = Ce(mn, e3.__scopeDialog);
  return s.modal ? (0, import_react.createElement)(Gt, {
    present: r || s.open
  }, (0, import_react.createElement)(eu, ve({}, o2, {
    ref: t3
  }))) : null;
});
var eu = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, o2 = Ce(mn, n2);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    (0, import_react.createElement)(Gr, {
      as: jn,
      allowPinchZoom: true,
      shards: [
        o2.contentRef
      ]
    }, (0, import_react.createElement)(Ve.div, ve({
      "data-state": Sn(o2.open)
    }, r, {
      ref: t3,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
});
var ct = "DialogContent";
var tu = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = qr(ct, e3.__scopeDialog), { forceMount: r = n2.forceMount, ...o2 } = e3, s = Ce(ct, e3.__scopeDialog);
  return (0, import_react.createElement)(Gt, {
    present: r || s.open
  }, s.modal ? (0, import_react.createElement)(nu, ve({}, o2, {
    ref: t3
  })) : (0, import_react.createElement)(ru, ve({}, o2, {
    ref: t3
  })));
});
var nu = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = Ce(ct, e3.__scopeDialog), r = (0, import_react.useRef)(null), o2 = nt(t3, n2.contentRef, r);
  return (0, import_react.useEffect)(() => {
    const s = r.current;
    if (s)
      return Za(s);
  }, []), (0, import_react.createElement)(Xr, ve({}, e3, {
    ref: o2,
    trapFocus: n2.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: Qe(e3.onCloseAutoFocus, (s) => {
      var l;
      s.preventDefault(), (l = n2.triggerRef.current) === null || l === void 0 || l.focus();
    }),
    onPointerDownOutside: Qe(e3.onPointerDownOutside, (s) => {
      const l = s.detail.originalEvent, u = l.button === 0 && l.ctrlKey === true;
      (l.button === 2 || u) && s.preventDefault();
    }),
    onFocusOutside: Qe(
      e3.onFocusOutside,
      (s) => s.preventDefault()
    )
  }));
});
var ru = (0, import_react.forwardRef)((e3, t3) => {
  const n2 = Ce(ct, e3.__scopeDialog), r = (0, import_react.useRef)(false);
  return (0, import_react.createElement)(Xr, ve({}, e3, {
    ref: t3,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (o2) => {
      var s;
      if ((s = e3.onCloseAutoFocus) === null || s === void 0 || s.call(e3, o2), !o2.defaultPrevented) {
        var l;
        r.current || (l = n2.triggerRef.current) === null || l === void 0 || l.focus(), o2.preventDefault();
      }
      r.current = false;
    },
    onInteractOutside: (o2) => {
      var s, l;
      (s = e3.onInteractOutside) === null || s === void 0 || s.call(e3, o2), o2.defaultPrevented || (r.current = true);
      const u = o2.target;
      ((l = n2.triggerRef.current) === null || l === void 0 ? void 0 : l.contains(u)) && o2.preventDefault();
    }
  }));
});
var Xr = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, trapFocus: r, onOpenAutoFocus: o2, onCloseAutoFocus: s, ...l } = e3, u = Ce(ct, n2), f = (0, import_react.useRef)(null), h = nt(t3, f);
  return aa(), (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(Hs, {
    asChild: true,
    loop: true,
    trapped: r,
    onMountAutoFocus: o2,
    onUnmountAutoFocus: s
  }, (0, import_react.createElement)(qs, ve({
    role: "dialog",
    id: u.contentId,
    "aria-describedby": u.descriptionId,
    "aria-labelledby": u.titleId,
    "data-state": Sn(u.open)
  }, l, {
    ref: h,
    onDismiss: () => u.onOpenChange(false)
  }))), false);
});
var iu = "DialogTitle";
var ou = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, o2 = Ce(iu, n2);
  return (0, import_react.createElement)(Ve.h2, ve({
    id: o2.titleId
  }, r, {
    ref: t3
  }));
});
var su = "DialogClose";
var au = (0, import_react.forwardRef)((e3, t3) => {
  const { __scopeDialog: n2, ...r } = e3, o2 = Ce(su, n2);
  return (0, import_react.createElement)(Ve.button, ve({
    type: "button"
  }, r, {
    ref: t3,
    onClick: Qe(
      e3.onClick,
      () => o2.onOpenChange(false)
    )
  }));
});
function Sn(e3) {
  return e3 ? "open" : "closed";
}
var uu = qa;
var cu = Ka;
var lu = Ja;
var fu = $a;
var du = tu;
var lt = ou;
var hu = au;
var gu = (e3) => (0, import_jsx_runtime.jsxs)(uu, {
  open: e3.open,
  onOpenChange: e3.onOpenChange,
  children: [(0, import_jsx_runtime.jsx)(cu, {
    asChild: true,
    children: e3.trigger
  }), (0, import_jsx_runtime.jsx)(lu, {
    children: (0, import_jsx_runtime.jsx)(fu, {
      className: "wkit-dialog__overlay",
      children: (0, import_jsx_runtime.jsx)(du, {
        ...e3.contentProps,
        className: ut("wkit-dialog__content", e3.className),
        style: e3.style,
        children: e3.children
      })
    })
  })]
});
function Kr() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.8332 10.0003H4.1665M4.1665 10.0003L9.99984 15.8337M4.1665 10.0003L9.99984 4.16699",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function pu() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15 5L5 15M5 5L15 15",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function yu() {
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime.jsx)("g", {
      clipPath: "url(#clip0_1790_28273)",
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M9.99989 10.9766L14.1249 6.85156L15.3032 8.0299L9.99989 13.3332L4.69656 8.0299L5.87489 6.85156L9.99989 10.9766Z",
        fill: "currentColor"
      })
    }), (0, import_jsx_runtime.jsx)("defs", {
      children: (0, import_jsx_runtime.jsx)("clipPath", {
        id: "clip0_1790_28273",
        children: (0, import_jsx_runtime.jsx)("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(20) rotate(90)"
        })
      })
    })]
  });
}
var Mu = (e3) => {
  const {
    icon: t3,
    alt: n2 = "icon"
  } = e3;
  return (0, import_jsx_runtime.jsx)("div", {
    onClick: e3.onClick,
    className: e3.className,
    style: e3.style,
    children: typeof t3 == "string" ? (0, import_jsx_runtime.jsx)("img", {
      src: t3,
      alt: n2,
      className: e3.elClassName,
      style: e3.elStyle
    }) : import_react.default.cloneElement(t3)
  });
};
var vu = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-dialog__header",
  children: [(0, import_jsx_runtime.jsx)(lt, {
    className: "wkit-dialog__title",
    children: "Connect Wallet"
  }), (0, import_jsx_runtime.jsx)(hu, {
    style: {
      position: "absolute",
      right: "16px",
      top: "16px"
    },
    className: "wkit-dialog__close",
    children: (0, import_jsx_runtime.jsx)(pu, {})
  })]
});
var mu = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-new-to-sui",
  children: [(0, import_jsx_runtime.jsx)("span", {
    className: "wkit-new-to-sui__text",
    children: "New to sui? "
  }), (0, import_jsx_runtime.jsx)("a", {
    className: "wkit-new-to-sui__link",
    href: "https://suiet.app/docs/getting-started",
    target: "_blank",
    children: "Learn More Here"
  })]
});
var Au = (e3) => {
  const {
    wallet: t3
  } = e3, [n2, r] = (0, import_react.useState)("");
  return (0, import_react.useEffect)(() => {
    t3.iconUrl && r(t3.iconUrl);
  }, [t3.iconUrl]), (0, import_jsx_runtime.jsxs)("div", {
    className: "wkit-select-item",
    onClick: () => {
      var _a2;
      (_a2 = e3.onSelect) == null ? void 0 : _a2.call(e3, t3);
    },
    children: [(0, import_jsx_runtime.jsx)(Mu, {
      icon: n2,
      className: "wkit-select-item__icon",
      elClassName: "wkit-select-item__icon"
    }), t3.label ?? t3.name]
  }, t3.name);
};
var ur = (e3) => Oe(e3.wallets) ? (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-select__container",
  children: [(0, import_jsx_runtime.jsx)("div", {
    className: "wkit-select__title",
    children: e3.title
  }), Oe(e3.wallets) && e3.wallets.map((t3) => (0, import_jsx_runtime.jsx)(Au, {
    wallet: t3,
    onSelect: e3.onSelect
  }, t3.name))]
}) : null;
var Nu = (e3) => {
  const {
    wallet: t3
  } = e3;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(lt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-8px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e3.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Kr, {})
        })
      }), (0, import_jsx_runtime.jsx)(lt, {
        className: "wkit-dialog__title",
        children: "Install Wallet"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-install",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-install__logo",
        src: t3.iconUrl,
        alt: `${t3.name} logo`
      }), (0, import_jsx_runtime.jsx)("h1", {
        className: "wkit-install__title",
        children: "You havent install this wallet"
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-install__description",
        children: "Install wallet via Chrome Extension Store"
      }), (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-button wkit-install__button",
        onClick: () => {
          var _a2;
          if (!((_a2 = t3.downloadUrl) == null ? void 0 : _a2.browserExtension))
            throw new ie(`no downloadUrl config on this wallet: ${t3.name}`);
          window.open(t3.downloadUrl.browserExtension, "_blank");
        },
        children: "Get Wallet"
      })]
    })]
  });
};
var Iu = (e3) => {
  const {
    wallet: t3
  } = e3;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(lt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-6px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e3.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Kr, {})
        })
      }), (0, import_jsx_runtime.jsx)(lt, {
        className: "wkit-dialog__title",
        children: "Connecting"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-connecting",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-connecting__logo",
        src: t3.iconUrl,
        alt: `logo of ${t3.name}`
      }), (0, import_jsx_runtime.jsxs)("h1", {
        className: "wkit-connecting__title",
        children: ["Opening ", t3.name]
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-connecting__description",
        children: "Confirm connection in the extension"
      })]
    })]
  });
};
var bu = (e3) => {
  const {
    configuredWallets: t3,
    detectedWallets: n2,
    select: r,
    connecting: o2
  } = dt(), {
    onConnectSuccess: s = () => {
    },
    onConnectError: l = (y) => {
      throw y;
    }
  } = e3, [u, f] = (0, import_react.useState)(), h = (0, import_react.useCallback)(async (y) => {
    if (f(y), y.installed) {
      try {
        await r(y.name);
      } catch (A) {
        l(A);
        return;
      }
      s(y.name);
    }
  }, [r]);
  function p() {
    if (u) {
      if (!u.installed)
        return (0, import_jsx_runtime.jsx)(Nu, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
      if (o2)
        return (0, import_jsx_runtime.jsx)(Iu, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
    }
    return (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(vu, {}), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-select__scroll",
        children: [(0, import_jsx_runtime.jsx)(ur, {
          title: "Popular",
          wallets: t3,
          onSelect: h
        }), (0, import_jsx_runtime.jsx)(ur, {
          title: "Others",
          wallets: n2,
          onSelect: h
        })]
      }), (0, import_jsx_runtime.jsx)("div", {
        style: {
          height: "41px",
          flexShrink: "0"
        }
      }), (0, import_jsx_runtime.jsx)(mu, {})]
    });
  }
  return (0, import_jsx_runtime.jsx)(gu, {
    open: e3.open,
    onOpenChange: e3.onOpenChange,
    trigger: e3.children,
    contentProps: {
      onOpenAutoFocus: (y) => {
        y.preventDefault();
      }
    },
    children: p()
  });
};
function wu(e3) {
  const {
    disconnect: t3,
    account: n2,
    chain: r,
    connected: o2,
    name: s
  } = dt(), {
    balance: l
  } = Es(), [u, f] = (0, import_react.useState)(false), h = (0, import_react.useCallback)(() => !r || r.id === it.id ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: "Unknown Chain"
  }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [Ji(l ?? 0), " SUI"]
  }), [l, r]);
  return o2 ? (0, import_jsx_runtime.jsxs)("div", {
    className: ut("wkit-connected-container", e3.className),
    style: e3.style,
    children: [(0, import_jsx_runtime.jsxs)("button", {
      className: ut("wkit-connected-button"),
      onClick: () => {
        f(!u);
      },
      children: [(0, import_jsx_runtime.jsx)("span", {
        className: "wkit-connected-button__balance",
        children: h()
      }), (0, import_jsx_runtime.jsx)("div", {
        className: "wkit-connected-button__divider"
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-address-select",
        children: [(0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__address",
          children: to(n2 == null ? void 0 : n2.address)
        }), (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__right-arrow",
          children: (0, import_jsx_runtime.jsx)(yu, {})
        })]
      })]
    }), u && (0, import_jsx_runtime.jsx)("div", {
      className: "wkit-disconnect-button__container",
      children: (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-disconnect-button",
        onClick: async () => {
          var _a2, _b;
          f(false);
          try {
            await t3();
          } catch (p) {
            (_a2 = e3 == null ? void 0 : e3.onDisconnectError) == null ? void 0 : _a2.call(e3, p);
            return;
          }
          (_b = e3 == null ? void 0 : e3.onDisconnectSuccess) == null ? void 0 : _b.call(e3, s);
        },
        children: "Disconnect"
      })
    })]
  }) : null;
}
var Uu = (e3) => {
  const {
    label: t3 = "Connect Button"
  } = e3, [n2, r] = (0, import_react.useState)(false), {
    connected: o2
  } = dt();
  return (0, import_react.useEffect)(() => {
    o2 && r(false);
  }, [o2]), (0, import_jsx_runtime.jsx)(bu, {
    open: n2,
    onOpenChange: (s) => {
      o2 || r(s);
    },
    onConnectSuccess: e3.onConnectSuccess,
    onConnectError: e3.onConnectError,
    children: (0, import_jsx_runtime.jsx)("div", {
      children: o2 ? (0, import_jsx_runtime.jsx)(wu, {
        className: ut(e3.className),
        style: e3.style,
        onDisconnectSuccess: (s) => {
          var _a2;
          r(false), (_a2 = e3 == null ? void 0 : e3.onDisconnectSuccess) == null ? void 0 : _a2.call(e3, s);
        },
        onDisconnectError: e3.onDisconnectError
      }) : (0, import_jsx_runtime.jsx)("button", {
        className: ut("wkit-button", e3.className),
        style: e3.style,
        children: e3.children || t3
      })
    })
  });
};
function Hr(e3) {
  if (typeof e3 == "string") {
    console.warn(`[DEPRECATED] ${e3}`);
    return;
  }
  const { name: t3, message: n2, migrationDoc: r } = e3;
  console.warn(`[DEPRECATED] ${t3} is no longer supported. ` + n2 + (r ? ` | Check migration doc: ${r}` : ""));
}
function Pu() {
  return Hr({
    name: "getDefaultWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
function zu() {
  return Hr({
    name: "getAllWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
export {
  Hi as AccountAssetManager,
  Ki as AccountCoinManager,
  Xi as AccountObjectManager,
  Co as AllDefaultWallets,
  br as BaseError,
  En as CoinObject,
  Uu as ConnectButton,
  bu as ConnectModal,
  me as ConnectionStatus,
  Yo as DefaultChains,
  wo as ElliWallet,
  ue as ErrorCode,
  po as EthosWallet,
  Le as FeatureName,
  Do as FrontierWallet,
  vo as GlassWallet,
  ie as KitError,
  yo as MartianWallet,
  mo as MorphisWallet,
  bo as NightlyWallet,
  Ao as OneKeyWallet,
  Ue as PresetWallet,
  Io as SensuiWallet,
  No as SpacecyWallet,
  Qo as SuiChainId,
  Fo as SuiDevnetChain,
  Wo as SuiMainnetChain,
  Bo as SuiTestnetChain,
  go as SuiWallet,
  ho as SuietWallet,
  Mo as SurfWallet,
  Eo as TokenPocketWallet,
  lo as Uint8arrayTool,
  it as UnknownChain,
  So as WalletAdapter,
  wr as WalletContext,
  Pe as WalletError,
  To as WalletNotImplementError,
  xu as WalletProvider,
  ko as WalletRadar,
  to as addressEllipsis,
  he as defineWallet,
  vr as formatCurrency,
  Ji as formatSUI,
  zu as getAllWallets,
  Pu as getDefaultWallets,
  jo as handleConnectionError,
  Ot as has,
  Lu as stringBytesToString,
  Nr as stringBytesToUint8Array,
  Es as useAccountBalance,
  bs as useChain,
  ws as useCoinBalance,
  Ou as useSuiProvider,
  dt as useWallet,
  fo as verifySignedMessage
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@suiet/wallet-kit/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@suiet_wallet-kit.js.map
